'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/','title':"개발가이드",'section':"Docs",'content':"Collapsed Level of Menu #  Cognita laeva illo fracta #  Lorem markdownum pavent auras, surgit nunc cingentibus libet Laomedonque que est. Pastor An arbor filia foedat, ne fugit aliter, per. Helicona illas et callida neptem est Oresitrophos caput, dentibus est venit. Tenet reddite famuli praesentem fortibus, quaeque vis foret si frondes gelidos gravidae circumtulit inpulit armenta nativum.\n Te at cruciabere vides rubentis manebo Maturuit in praetemptat ruborem ignara postquam habitasse Subitarum supplevit quoque fontesque venabula spretis modo Montis tot est mali quasque gravis Quinquennem domus arsit ipse Pellem turis pugnabant locavit  "});index.add({'id':1,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/','title':"Php",'section':"개발가이드",'content':"PHP Standards Recommendations 한글 버전 #  주의사항 #   모든 내용은 공식 문서인 https://www.php-fig.org/psr/의 내용이 더 우선시 됩니다. PHP Standards Recommendations 한글 번역본입니다. 개인이 학습용도로 번역한 내용이니 일부 오역이 있을 수 있습니다. 일부 내용은 한글로 번역 후 어색하지 않기 위해 의역을 하였습니다.  번역 가이드 #   Class, Method, Properties 같은 개발자라면 번역하면 어색한 문장은 원문을 그대로 사용합니다  "});index.add({'id':2,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/javascript/javascript/','title':"Javascript",'section':"개발가이드",'content':"원문: https://github.com/airbnb/javascript '\u0026rsquo;\nLaonstory JavaScript 스타일 가이드() { #  대체로 합리적인 JavaScript 접근 방법\n 참고: 이 가이드는 사용자가 Babel과 babel-preset-airbnb 또는 이와 동등한 것을 사용한다고 가정합니다. 또한 사용자가 어플리케이션에 airbnb-browser-shims와 함께 shims/polyfills 또는 이와 동등한 것을 설치했다고 가정합니다.\n   \n이 스타일 가이드는 다른 언어로도 제공됩니다. Translation을 보세요.\n다른 스타일 가이드\n ES5 (구버전) React CSS-in-JavaScript CSS \u0026amp; Sass Ruby  목차 #   형 (Types) 참조 (References) 객체 (Objects) 배열 (Arrays) 비구조화 Destructuring 문자열 (Strings) 함수 (Functions) 화살표 함수 (Arrow Functions) 클래스 \u0026amp; 생성자 (Classes \u0026amp; Constructors) 모듈 (Modules) 이터레이터와 제너레이터 (Iterators and Generators) 속성 (Properties) 변수 (Variables) 호이스팅 (Hoisting) 비교 연산자 (Comparison Operators \u0026amp; Equality) 블록 (Blocks) 제어문 (Control Statements) 주석 (Comments) 공백 (Whitespace) 쉼표 (Commas) 세미콜론 (Semicolons) 형변환과 강제 (Type Casting \u0026amp; Coercion) 명명규칙 (Naming Conventions) 접근자 (Accessors) 이벤트 (Events) 제이쿼리 (jQuery) ES5 호환성 (ECMAScript 5 Compatibility) ECMAScript 6+ (ES 2015+) 스타일 표준 라이브러리 (Standard Library) 테스트 (Testing) 성능 (Performance) 자료 (Resources) In the Wild Translation The JavaScript Style Guide Guide Chat With Us About JavaScript Contributors License Amendments  형 (Types) #    1.1 원시형: 원시형에 접근하면 값을 직접 조작하게 됩니다.\n string number boolean null undefined symbol bigint  const foo = 1; let bar = foo; bar = 9; console.log(foo, bar); // =\u0026gt; 1, 9  symbol과 bigint는 완전히 폴리필되지 않으므로, 이를 지원하지 않는 브라우저/환경을 대상으로 사용해서는 안 됩니다.      1.2 참조형: 참조형에 접근하면 참조를 통해 값을 조작하게 됩니다.\n object array function  const foo = [1, 2]; const bar = foo; bar[0] = 9; console.log(foo[0], bar[0]); // =\u0026gt; 9, 9   ⬆ back to top\n참조 (References) #    2.1 모든 참조에는 var 대신 const를 사용하세요. eslint: prefer-const, no-const-assign\n 왜? 참조를 재할당 할 수 없게 함으로써, 이해하기 어려운 동시에 버그로 이어지는 코드를 방지합니다.\n // bad var a = 1; var b = 2; // good const a = 1; const b = 2;     2.2 만약 참조를 재할당 해야 한다면 var 대신 let을 사용하세요. eslint: no-var\n 왜? var처럼 함수스코프를 취하는 것 보다는 블록스코프를 취하는 let이 더 낫습니다.\n // bad var count = 1; if (true) { count += 1; } // good, use the let. let count = 1; if (true) { count += 1; }     2.3 let 과 const 는 둘 다 블록스코프라는 것을 유의하세요.\n// const와 let은 선언된 블록 안에서만 존재합니다. { let a = 1; const b = 1; } console.log(a); // ReferenceError console.log(b); // ReferenceError   ⬆ back to top\n객체 (Objects) #    3.1 객체를 생성할 때는 리터럴 문법을 사용하세요. eslint: no-new-object\n// bad const item = new Object(); // good const item = {};     3.2 동적 속성을 갖는 객체를 생성할 때는 속성 계산명을 사용하세요.\n 왜? 이렇게 하면 객체의 모든 속성을 한 곳에서 정의할 수 있습니다.\n function getKey(k) { return `a key named ${k}`; } // bad const obj = { id: 5, name: \u0026#39;San Francisco\u0026#39;, }; obj[getKey(\u0026#39;enabled\u0026#39;)] = true; // good const obj = { id: 5, name: \u0026#39;San Francisco\u0026#39;, [getKey(\u0026#39;enabled\u0026#39;)]: true, };     3.3 메소드의 단축구문을 사용하세요. eslint: object-shorthand\n// bad const atom = { value: 1, addValue: function (value) { return atom.value + value; }, }; // good const atom = { value: 1, addValue(value) { return atom.value + value; }, };     3.4 속성의 단축구문을 사용하세요. eslint: object-shorthand\n 왜? 설명이 간결해지기 때문입니다.\n const lukeSkywalker = \u0026#39;Luke Skywalker\u0026#39;; // bad const obj = { lukeSkywalker: lukeSkywalker, }; // good const obj = { lukeSkywalker, };     3.5 속성의 단축구문은 객체 선언의 시작 부분에 모아주세요.\n 왜? 어떤 속성이 단축구문을 사용하고 있는지 알기 쉽게 해줍니다.\n const anakinSkywalker = \u0026#39;Anakin Skywalker\u0026#39;; const lukeSkywalker = \u0026#39;Luke Skywalker\u0026#39;; // bad const obj = { episodeOne: 1, twoJediWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker, }; // good const obj = { lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJediWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4, };     3.6 유효하지 않은 식별자에만 따옴표 속성을 사용하세요. eslint: quote-props\n 왜? 더 읽기 쉽습니다. 이렇게 하면 구문 하이라이팅이 잘 되고, 많은 자바스크립트 엔진이 더 쉽게 최적화 할 수 있습니다.\n // bad const bad = { \u0026#39;foo\u0026#39;: 3, \u0026#39;bar\u0026#39;: 4, \u0026#39;data-blah\u0026#39;: 5, }; // good const good = { foo: 3, bar: 4, \u0026#39;data-blah\u0026#39;: 5, };     3.7 hasOwnProperty, propertyIsEnumerable, isPrototypeOf와 같은 Object.prototype 메소드를 직접 호출하지 마세요. eslint: no-prototype-builtins\n 왜? 이러한 메소드들은 객체의 속성에 의해 가려질 수 있습니다. - { hasOwnProperty: false } - 또는, 객체가 null 객체(Object.create(null))일 수도 있습니다.\n // bad console.log(object.hasOwnProperty(key)); // good console.log(Object.prototype.hasOwnProperty.call(object, key)); // best const has = Object.prototype.hasOwnProperty; // 모듈스코프에서 한 번 캐시하세요. console.log(has.call(object, key)); /* or */ import has from \u0026#39;has\u0026#39;; // https://www.npmjs.com/package/has console.log(has(object, key));     3.8 객체에 대해 얕은 복사를 할 때는 Object.assign대신 객체 전개 연산자를 사용하세요. 특정 속성이 생략된 새로운 개체를 가져올 때는 객체 나머지 연산자(object rest operator)를 사용하세요.\n// very bad const original = { a: 1, b: 2 }; const copy = Object.assign(original, { c: 3 }); // `original`을 변조합니다 ಠ_ಠ delete copy.a; // 그래서 이렇게 합니다  // bad const original = { a: 1, b: 2 }; const copy = Object.assign({}, original, { c: 3 }); // copy =\u0026gt; { a: 1, b: 2, c: 3 }  // good const original = { a: 1, b: 2 }; const copy = { ...original, c: 3 }; // copy =\u0026gt; { a: 1, b: 2, c: 3 }  const { a, ...noA } = copy; // noA =\u0026gt; { b: 2, c: 3 }   ⬆ back to top\n배열 (Arrays) #    4.1 배열을 생성할 때 리터럴 구문을 사용하세요. eslint: no-array-constructor\n// bad const items = new Array(); // good const items = [];     4.2 배열에 직접 값을 할당하지 말고 Array#push를 사용하세요.\nconst someStack = []; // bad someStack[someStack.length] = \u0026#39;abracadabra\u0026#39;; // good someStack.push(\u0026#39;abracadabra\u0026#39;);     4.3 배열을 복사할 때는 배열 전개 연산자 ... 를 사용하세요.\n// bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i \u0026lt; len; i += 1) { itemsCopy[i] = items[i]; } // good const itemsCopy = [...items];     4.4 순회 가능한 객체(iterable object)를 배열로 변환할 때는 Array.from 대신 전개 연산자 ...를 사용하세요.\nconst foo = document.querySelectorAll(\u0026#39;.foo\u0026#39;); // good const nodes = Array.from(foo); // best const nodes = [...foo];     4.5 array-like 객체를 배열로 변환할 때는 Array.from을 사용하세요.\nconst arrLike = { 0: \u0026#39;foo\u0026#39;, 1: \u0026#39;bar\u0026#39;, 2: \u0026#39;baz\u0026#39;, length: 3 }; // bad const arr = Array.prototype.slice.call(arrLike); // good const arr = Array.from(arrLike);     4.6 매핑할 때는 전개 연산자 ... 대신 Array.from을 사용하세요. 중간 배열 생성을 방지하기 때문입니다.\n// bad const baz = [...foo].map(bar); // good const baz = Array.from(foo, bar);     4.7 배열 메소드 콜백에는 리턴 구문을 사용하세요. 만약 함수가 8.2와 같이 부작용 없는 단일 표현식을 반환하는 구문으로 구성되어 있다면 리턴 구문을 생략해도 됩니다. eslint: array-callback-return\n// good [1, 2, 3].map((x) =\u0026gt; { const y = x + 1; return x * y; }); // good [1, 2, 3].map(x =\u0026gt; x + 1); // bad - no returned value means `acc` becomes undefined after the first iteration [[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =\u0026gt; { const flatten = acc.concat(item); acc[index] = flatten; }); // good [[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =\u0026gt; { const flatten = acc.concat(item); acc[index] = flatten; return flatten; }); // bad inbox.filter((msg) =\u0026gt; { const { subject, author } = msg; if (subject === \u0026#39;Mockingbird\u0026#39;) { return author === \u0026#39;Harper Lee\u0026#39;; } else { return false; } }); // good inbox.filter((msg) =\u0026gt; { const { subject, author } = msg; if (subject === \u0026#39;Mockingbird\u0026#39;) { return author === \u0026#39;Harper Lee\u0026#39;; } return false; });     4.8 배열이 여러 줄에 걸쳐 있다면 배열을 연 이후와 닫기 이전에 줄바꿈을 해주세요.\n// bad const arr = [ [0, 1], [2, 3], [4, 5], ]; const objectInArray = [{ id: 1, }, { id: 2, }]; const numberInArray = [ 1, 2, ]; // good const arr = [[0, 1], [2, 3], [4, 5]]; const objectInArray = [ { id: 1, }, { id: 2, }, ]; const numberInArray = [ 1, 2, ];   ⬆ back to top\n비구조화 (Destructuring) #    5.1 하나의 객체에서 여러 속성에 접근할 때는 객체 비구조화를 사용하세요. eslint: prefer-destructuring\n 왜? 비구조화는 속성들을 위한 임시 참조를 만들지 않도록 해줍니다.\n // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; return `${firstName}${lastName}`; } // good function getFullName(user) { const { firstName, lastName } = user; return `${firstName}${lastName}`; } // best function getFullName({ firstName, lastName }) { return `${firstName}${lastName}`; }     5.2 배열 비구조화를 사용하세요. eslint: prefer-destructuring\nconst arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr;     5.3 여러 값을 반환하는 경우 배열 비구조화가 아닌 객체 비구조화를 사용하세요.\n 왜? 이렇게 하면 이후 호출처에 영향을 주지 않고 새로운 속성을 추가하거나 순서를 변경할 수 있습니다.\n // bad function processInput(input) { // 기적이 일어납니다  return [left, right, top, bottom]; } // 반환되는 데이터의 순서를 생각해야합다 const [left, __, top] = processInput(input); // good function processInput(input) { // 기적이 일어납니다  return { left, right, top, bottom }; } // 필요한 데이터만 선택하면 됩니다 const { left, top } = processInput(input);   ⬆ back to top\n문자열 (Strings) #    6.1 문자열에는 작은 따옴표 ''를 사용하세요. eslint: quotes\n// bad const name = \u0026#34;Capt. Janeway\u0026#34;; // bad - template literals should contain interpolation or newlines const name = `Capt. Janeway`; // good const name = \u0026#39;Capt. Janeway\u0026#39;;     6.2 100자가 넘는 문자열을 문자열 연결을 이용해 여러 줄에 걸쳐 쓰지 마세요.\n 왜? 문자열이 끊어지면 작업하기 어렵고, 코드를 찾기 어렵게 됩니다.\n // bad const errorMessage = \u0026#39;This is a super long error that was thrown because \\ of Batman. When you stop to think about how Batman had anything to do \\ with this, you would get nowhere \\ fast.\u0026#39;; // bad const errorMessage = \u0026#39;This is a super long error that was thrown because \u0026#39; + \u0026#39;of Batman. When you stop to think about how Batman had anything to do \u0026#39; + \u0026#39;with this, you would get nowhere fast.\u0026#39;; // good const errorMessage = \u0026#39;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.\u0026#39;;     6.3 문자열을 생성하는 경우, 문자열 연결 대신 템플릿 문자열을 사용하세요. eslint: prefer-template template-curly-spacing\n 왜? 템플릿 문자열은 덧붙이기와 줄바꿈을 제공하는 간결한 문법으로, 가독성을 높여줍니다.\n // bad function sayHi(name) { return \u0026#39;How are you, \u0026#39; + name + \u0026#39;?\u0026#39;; } // bad function sayHi(name) { return [\u0026#39;How are you, \u0026#39;, name, \u0026#39;?\u0026#39;].join(); } // bad function sayHi(name) { return `How are you, ${ name }?`; } // good function sayHi(name) { return `How are you, ${name}?`; }    6.4 절대로 문자열에 eval()을 사용하지 마세요. 너무나 많은 취약점을 만듭니다. eslint: no-eval    6.5 문자열에 불필요한 이스케이프 문자를 사용하지 마세요. eslint: no-useless-escape\n 왜? 백슬래시는 가독성을 해치기 때문에 필요할 때만 사용해야 합니다.\n // bad const foo = \u0026#39;\\\u0026#39;this\\\u0026#39; \\i\\s \\\u0026#34;quoted\\\u0026#34;\u0026#39;; // good const foo = \u0026#39;\\\u0026#39;this\\\u0026#39; is \u0026#34;quoted\u0026#34;\u0026#39;; const foo = `my name is \u0026#39;${name}\u0026#39;`;   ⬆ back to top\n함수 (Functions) #    7.1 함수선언식 대신 기명 함수표현식을 사용하세요. eslint: func-style\n 왜? 함수선언은 호이스트됩니다. 즉, 파일에서 함수를 정의하기 전에 함수를 참조하는 것이 쉽다는 것 - 너무 쉽다는 것 - 을 의미합니다. 이것은 가독성과 유지관리성를 해칩니다. 만약 함수의 정의가 나머지 파일을 이해하는데 방해가 될 정도로 크거나 복잡하다면, 이제 함수를 모듈 밖으로 추출해내야 할 때입니다! 포함된 변수로부터 추론된 이름인지와 관계 없이(현대 브라우저 또는 Babel과 같은 컴파일러를 쓸 때 흔히 볼 수 있듯이) 표현의 이름을 명시적으로 짓는 것을 잊지 마세요. 이를 통해 Error 콜 스택에 대한 모든 추정을 제거할 수 있습니다. (토론)\n // bad function foo() { // ... } // bad const foo = function () { // ... }; // good // 변수 참조 호출과 구분되는 이름 const short = function longUniqueMoreDescriptiveLexicalFoo() { // ... };     7.2 즉시 호출 함수 표현식을 괄호로 감싸세요. eslint: wrap-iife\n 왜? 즉시 호출 함수 표현식은 하나의 단위이며, 괄호로 이것을 감싸면 괄호 안의 표현을 명확하게 해주기 때문입니다. 모듈을 어디에서나 사용한다면 즉시 호출 표현식은 전혀 필요하지 않다는 점을 주의하세요.\n // 즉시 호출 함수 표현식 (IIFE) (function () { console.log(\u0026#39;Welcome to the Internet. Please follow me.\u0026#39;); }());    7.3 함수 이외의 불록(if, while, 등)에서 함수를 선언하지 마세요. 브라우저는 이를 허용하겠지만, 모두 다르게 해석합니다. eslint: no-loop-func    7.4 참고: ECMA-262 명세는 블록을 구문의 일종으로 정의하고 있지만 함수선언은 구문이 아닙니다.\n// bad if (currentUser) { function test() { console.log(\u0026#39;Nope.\u0026#39;); } } // good let test; if (currentUser) { test = () =\u0026gt; { console.log(\u0026#39;Yup.\u0026#39;); }; }     7.5 절대 매개변수 이름을 arguments라고 짓지 마세요. 이것은 함수 스코프에 전해지는 arguments 객체의 참조를 덮어써 버립니다.\n// bad function foo(name, options, arguments) { // ... } // good function foo(name, options, args) { // ... }     7.6 절대 arguments를 사용하지마세요. 대신 나머지 문법(rest syntax) ...를 사용하세요. eslint: prefer-rest-params\n 왜? ...을 사용하면 몇 개의 매개변수를 이용하고 싶은지 확실히 할 수 있습니다. 더 나아가, 나머지 인자(rest arguments)는 arguments 와 같은 Array-like 객체가 아닌 진짜 Array입니다.\n // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(\u0026#39;\u0026#39;); } // good function concatenateAll(...args) { return args.join(\u0026#39;\u0026#39;); }     7.7 함수의 인자를 변조하기 보다는 기본 매개변수 문법을 사용하세요.\n// really bad function handleThings(opts) { // 안돼요! 우리는 함수 인자를 변경하면 안됩니다.  // 더 안 좋은 경우: 만약 opts가 falsy한 값일 경우 당신이 원하는 객체로  // 설정되겠지만, 이는 미묘한 버그를 일으킬 수 있습니다.  opts = opts || {}; // ... } // still bad function handleThings(opts) { if (opts === void 0) { opts = {}; } // ... } // good function handleThings(opts = {}) { // ... }     7.8 부작용이 있을만한 기본 매개변수는 사용하지 마세요.\n 왜? 혼란을 야기하기 때문입니다.\n var b = 1; // bad function count(a = b++) { console.log(a); } count(); // 1 count(); // 2 count(3); // 3 count(); // 3     7.9 기본 매개변수는 항상 뒤쪽에 두세요.\n// bad function handleThings(opts = {}, name) { // ... } // good function handleThings(name, opts = {}) { // ... }     7.10 절대로 새로운 함수를 만들기 위해 함수 생성자를 사용하지 마세요. eslint: no-new-func\n 왜? 이러한 방법으로 문자열을 평가해 함수를 만드는 것은 eval()과 같은 수준의 취약점을 만듭니다.\n // bad var add = new Function(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;return a + b\u0026#39;); // still bad var subtract = Function(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;return a - b\u0026#39;);     7.11 함수 시그니처에 공백을 넣으세요. eslint: space-before-function-paren space-before-blocks\n 왜? 일관성을 갖는 것은 좋으니까요. 그리고 이렇게 하면 이름을 추가하거나 지울 때 공백을 건드릴 필요가 없게 됩니다.\n // bad const f = function(){}; const g = function (){}; const h = function() {}; // good const x = function () {}; const y = function a() {};     7.12 절대로 매개변수를 바꾸지 마세요. eslint: no-param-reassign\n 왜? 매개변수로 전달된 객체를 조작하면 원래 호출처에서 원치 않는 부작용을 일으킬 수 있습니다.\n // bad function f1(obj) { obj.key = 1; } // good function f2(obj) { const key = Object.prototype.hasOwnProperty.call(obj, \u0026#39;key\u0026#39;) ? obj.key : 1; }     7.13 절대로 매개변수를 재할당하지 마세요. eslint: no-param-reassign\n 왜? 매개변수를 재할당하는 것은 예측할 수 없는 결과를 불러 일으킵니다. 특히 arguments 객체에 접근할 때 말이죠. 또한 V8에서 최적화 문제를 일으킬 수도 있습니다.\n // bad function f1(a) { a = 1; // ... } function f2(a) { if (!a) { a = 1; } // ... } // good function f3(a) { const b = a || 1; // ... } function f4(a = 1) { // ... }     7.14 가변 인자 함수를 호출할 때는 전개 연산자 ...을 사용하세요. eslint: prefer-spread\n 왜? 이게 더 깔끔합니다. 컨텍스트를 제공할 필요도 없고, apply로 new를 쉽게 구성할 수도 없습니다.\n // bad const x = [1, 2, 3, 4, 5]; console.log.apply(console, x); // good const x = [1, 2, 3, 4, 5]; console.log(...x); // bad new (Function.prototype.bind.apply(Date, [null, 2016, 8, 5])); // good new Date(...[2016, 8, 5]);     7.15 여러 줄의 시그니처 또는 호출을 취하는 함수는 이 가이드에 있는 다른 것들처럼 들여쓰기가 되어야 합니다. 한줄에 각 항목을 하나씩 두고, 마지막 항목에 쉼표를 넣습니다. eslint: function-paren-newline\n// bad function foo(bar, baz, quux) { // ... } // good function foo( bar, baz, quux, ) { // ... } // bad console.log(foo, bar, baz); // good console.log( foo, bar, baz, );   ⬆ back to top\n화살표 함수 (Arrow Functions) #    8.1 (인라인 콜백을 전달하는 듯한) 익명함수를 사용할 때는 화살표 함수 표현을 사용하세요. eslint: prefer-arrow-callback, arrow-spacing\n 왜? 화살표 함수는 그 컨텍스트의 this에서 실행하는 버전의 함수를 만듭니다. 이것은 보통 원하는대로 작동하고, 보다 간결합니다.\n  사용해야만 하지 않아? 복잡한 함수에서 로직을 정의한 함수의 바깥으로 이동하고 싶을 때.\n // bad [1, 2, 3].map(function (x) { const y = x + 1; return x * y; }); // good [1, 2, 3].map((x) =\u0026gt; { const y = x + 1; return x * y; });     8.2 하나의 식으로 구성된 함수가 부작용이 없는 표현식을 반환하는 경우, 중괄호를 생략하고 암시적 반환을 사용할 수 있습니다. 그 외에는 중괄호를 그대로 두고, return문도 사용하세요. eslint: arrow-parens, arrow-body-style\n 왜? 문법적 설탕이니까요. 여러 함수가 연결된 경우 읽기 쉬워집니다.\n // bad [1, 2, 3].map(number =\u0026gt; { const nextNumber = number + 1; `A string containing the ${nextNumber}.`; }); // good [1, 2, 3].map(number =\u0026gt; `A string containing the ${number}.`); // good [1, 2, 3].map((number) =\u0026gt; { const nextNumber = number + 1; return `A string containing the ${nextNumber}.`; }); // good [1, 2, 3].map((number, index) =\u0026gt; ({ [index]: number, })); // 암시적 반환없이 부작용을 수반합니다 function foo(callback) { const val = callback(); if (val === true) { // callback이 참을 반환하면 뭔가를 수행합니다  } } let bool = false; // bad foo(() =\u0026gt; bool = true); // good foo(() =\u0026gt; { bool = true; });     8.3 표현식이 여러 줄에 걸쳐 있을 때는 가독성을 높이기 위해 소괄호로 감싸주세요.\n 왜? 함수의 시작과 끝 부분을 알기 쉽게 해주기 때문입니다.\n // bad [\u0026#39;get\u0026#39;, \u0026#39;post\u0026#39;, \u0026#39;put\u0026#39;].map(httpMethod =\u0026gt; Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ) ); // good [\u0026#39;get\u0026#39;, \u0026#39;post\u0026#39;, \u0026#39;put\u0026#39;].map(httpMethod =\u0026gt; ( Object.prototype.hasOwnProperty.call( httpMagicObjectWithAVeryLongName, httpMethod, ) ));     8.4 명확성과 읽관성을 위해 항상 인자를 괄호로 감싸세요. eslint: arrow-parens\n 왜? 인자를 추가하거나 제거할 때 변경 사항을 최소화할 수 있습니다.\n // bad [1, 2, 3].map(x =\u0026gt; x * x); // good [1, 2, 3].map((x) =\u0026gt; x * x); // bad [1, 2, 3].map(number =\u0026gt; ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!` )); // good [1, 2, 3].map((number) =\u0026gt; ( `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!` )); // bad [1, 2, 3].map(x =\u0026gt; { const y = x + 1; return x * y; }); // good [1, 2, 3].map((x) =\u0026gt; { const y = x + 1; return x * y; });     8.5 화살표 함수 구문(=\u0026gt;)과 비교 연산자(\u0026lt;=, \u0026gt;=)를 헷갈리게 하지 마세요. eslint: no-confusing-arrow\n// bad const itemHeight = item =\u0026gt; item.height \u0026gt; 256 ? item.largeSize : item.smallSize; // bad const itemHeight = (item) =\u0026gt; item.height \u0026gt; 256 ? item.largeSize : item.smallSize; // good const itemHeight = item =\u0026gt; (item.height \u0026gt; 256 ? item.largeSize : item.smallSize); // good const itemHeight = (item) =\u0026gt; { const { height, largeSize, smallSize } = item; return height \u0026gt; 256 ? largeSize : smallSize; };     8.6 암시적 반환을 하는 화살표 함수 몸체의 위치를 적절히 설정하세요. eslint: implicit-arrow-linebreak\n// bad (foo) =\u0026gt; bar; (foo) =\u0026gt; (bar); // good (foo) =\u0026gt; bar; (foo) =\u0026gt; (bar); (foo) =\u0026gt; ( bar )   ⬆ back to top\n클래스 \u0026amp; 생성자 (Classes \u0026amp; Constructors) #    9.1 prototype 을 직접 조작하는것을 피하고 항상 class 를 사용하세요.\n 왜? class 구문은 간결하고 의미를 알기 쉽기 때문입니다.\n // bad function Queue(contents = []) { this.queue = [...contents]; } Queue.prototype.pop = function () { const value = this.queue[0]; this.queue.splice(0, 1); return value; }; // good class Queue { constructor(contents = []) { this.queue = [...contents]; } pop() { const value = this.queue[0]; this.queue.splice(0, 1); return value; } }     9.2 상속에는 extends를 사용하세요.\n 왜? instanceof를 파괴하지 않고 프토로타입 상속을 하기 위해 내장된 방법이기 때문입니다.\n // bad const inherits = require(\u0026#39;inherits\u0026#39;); function PeekableQueue(contents) { Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function () { return this.queue[0]; }; // good class PeekableQueue extends Queue { peek() { return this.queue[0]; } }     9.3 메소드가 this를 반환하게 함으로써 메소드 체이닝을 할 수 있습니다.\n// bad Jedi.prototype.jump = function () { this.jumping = true; return true; }; Jedi.prototype.setHeight = function (height) { this.height = height; }; const luke = new Jedi(); luke.jump(); // =\u0026gt; true luke.setHeight(20); // =\u0026gt; undefined  // good class Jedi { jump() { this.jumping = true; return this; } setHeight(height) { this.height = height; return this; } } const luke = new Jedi(); luke.jump() .setHeight(20);     9.4 toString()을 사용해도 되지만, 올바르게 동작하는지와 부작용이 없는지 확인해 주세요.\nclass Jedi { constructor(options = {}) { this.name = options.name || \u0026#39;no name\u0026#39;; } getName() { return this.name; } toString() { return `Jedi - ${this.getName()}`; } }     9.5 클래스는 생성자가 명시되지 않은 경우 기본 생성자를 갖습니다. 빈 생성자 함수나 부모 클래스로 위임하는 함수는 불필요합니다. eslint: no-useless-constructor\n// bad class Jedi { constructor() {} getName() { return this.name; } } // bad class Rey extends Jedi { constructor(...args) { super(...args); } } // good class Rey extends Jedi { constructor(...args) { super(...args); this.name = \u0026#39;Rey\u0026#39;; } }     9.6 중복되는 클래스 멤버를 만들지 마세요. eslint: no-dupe-class-members\n 왜? 중복된 클래스 멤버를 선언하면 암묵적으로 마지막 멤버가 적용됩니다. 중복은 확실히 버그입니다.\n // bad class Foo { bar() { return 1; } bar() { return 2; } } // good class Foo { bar() { return 1; } } // good class Foo { bar() { return 2; } }     9.7 클래스 메소드는 외부 라이브러리나 프레임워크가 구체적으로 비정적 메소드를 요구하지 않는 이상 this를 사용하거나 해당 메소드를 정적 메소드로 만들어야 합니다. 인스턴스 메서드는 수신자의 속성에 따라 다르게 동작함을 나타내야 합니다. eslint: class-methods-use-this\n// bad class Foo { bar() { console.log(\u0026#39;bar\u0026#39;); } } // good - this를 사용했습니다 class Foo { bar() { console.log(this.bar); } } // good - constructor가 면제됩니다 class Foo { constructor() { // ...  } } // good - 정적 메소드는 this를 사용하지 않는다고 예상할 수 있습니다 class Foo { static bar() { console.log(\u0026#39;bar\u0026#39;); } }   ⬆ back to top\n모듈 (Modules) #    10.1 비표준 모듈 시스템에는 항상 모듈(import/export)을 사용하세요. 이를 통해 선호하는 모듈 시스템으로 트랜스파일할 수 있습ㄴ니다.\n 왜? 모듈은 미래입니다. 지금 그 미래를 사용해 시작합니다.\n // bad const AirbnbStyleGuide = require(\u0026#39;./AirbnbStyleGuide\u0026#39;); module.exports = AirbnbStyleGuide.es6; // ok import AirbnbStyleGuide from \u0026#39;./AirbnbStyleGuide\u0026#39;; export default AirbnbStyleGuide.es6; // best import { es6 } from \u0026#39;./AirbnbStyleGuide\u0026#39;; export default es6;     10.2 와일드카드 import는 사용하지 마세요.\n 왜? single default export임을 확실히 할 수 있습니다.\n // bad import * as AirbnbStyleGuide from \u0026#39;./AirbnbStyleGuide\u0026#39;; // good import AirbnbStyleGuide from \u0026#39;./AirbnbStyleGuide\u0026#39;;     10.3 import문으로부터 직접 export하지 마세요.\n 왜? 한줄이 간결하기는 하지만, 명확한 import와 명확한 export를 통해 일관성을 가질 수 있기 때문입니다.\n // bad // filename es6.js export { es6 as default } from \u0026#39;./AirbnbStyleGuide\u0026#39;; // good // filename es6.js import { es6 } from \u0026#39;./AirbnbStyleGuide\u0026#39;; export default es6;     10.4 같은 경로는 한 곳에서 import하세요. eslint: no-duplicate-imports\n 왜? 같은 경로에서 import하는 여러 줄의 코드는 유지보수를 어렵게 만듭니다.\n // bad import foo from \u0026#39;foo\u0026#39;; // … 또 다른 imports … // import { named1, named2 } from \u0026#39;foo\u0026#39;; // good import foo, { named1, named2 } from \u0026#39;foo\u0026#39;; // good import foo, { named1, named2, } from \u0026#39;foo\u0026#39;;     10.5 가변 바인딩을 export하지 마세요. eslint: import/no-mutable-exports\n 왜? 변조는 일반적으로 피해야 하지만, 가변 바인딩을 export할 때는 특히 그렇습니다. 이 기술이 어떤 특별한 상황에 필요할 수도 있지만, 일반적으로는 상수 참조만 export되어야 합니다.\n // bad let foo = 3; export { foo }; // good const foo = 3; export { foo };     10.6 한가지만 export하는 모듈에서는 이름 붙여진 export보다는 default export를 사용하세요. eslint: import/prefer-default-export\n 왜? 하나만 export하는 파일의 가독성과 유지보수성이 더 좋기 때문입니다.\n // bad export function foo() {} // good export default function foo() {}     10.7 모든 import구문을 다른 구문들 위에 두세요. eslint: import/first\n 왜? import구문은 호이스트되기 때문에 이것을 가장 위에 두면 예상치 못한 결과를 막을 수 있습니다.\n // bad import foo from \u0026#39;foo\u0026#39;; foo.init(); import bar from \u0026#39;bar\u0026#39;; // good import foo from \u0026#39;foo\u0026#39;; import bar from \u0026#39;bar\u0026#39;; foo.init();     10.8 여러 줄에 걸친 import는 여러 줄의 배열이나 객체 리터럴처럼 들여쓰기하세요.\n 왜? 스타일 가이드에 있는 다른 모든 중괄호 블록들 처럼 중괄호는 같은 들여쓰기 규칙을 따릅니다. 콤마가 그렇듯이 말이죠.\n // bad import {longNameA, longNameB, longNameC, longNameD, longNameE} from \u0026#39;path\u0026#39;; // good import { longNameA, longNameB, longNameC, longNameD, longNameE, } from \u0026#39;path\u0026#39;;     10.9 모듈 import 구문에서 Webpack loader 구문을 사용하지 마세요. eslint: import/no-webpack-loader-syntax\n 왜? import에서 Webpack 구문을 사용하면 이 코드가 모듈 번들러에 연결되기 때문입니다. loader 구문은 webpack.config.js에서 사용하세요.\n // bad import fooSass from \u0026#39;css!sass!foo.scss\u0026#39;; import barCss from \u0026#39;style!css!bar.css\u0026#39;; // good import fooSass from \u0026#39;foo.scss\u0026#39;; import barCss from \u0026#39;bar.css\u0026#39;;     10.10 자바스크립트 파일 확장자를 명시하지 마세요. eslint: import/extensions\n 왜? 확장자를 명시하면 모든 소비자에서 import하는 모듈의 세부적 구현을 부적절하게 하드코딩하고, 리팩토링을 막게 됩니다.\n // bad import foo from \u0026#39;./foo.js\u0026#39;; import bar from \u0026#39;./bar.jsx\u0026#39;; import baz from \u0026#39;./baz/index.jsx\u0026#39;; // good import foo from \u0026#39;./foo\u0026#39;; import bar from \u0026#39;./bar\u0026#39;; import baz from \u0026#39;./baz\u0026#39;;   ⬆ back to top\n이터레이터와 제너레이터 (Iterators and Generators) #    11.1 이터레이터를 사용하지 마세요. for-in이나 for-of같은 루프 대신 자바스크립트의 고급함수를 사용하세요. eslint: no-iterator no-restricted-syntax\n 왜? 고급함수는 불변 규칙을 적용합니다. 부작용에 대해 추측하는 것보다 값을 반환하는 순수 함수를 다루는 것이 더 간단합니다.\n  배열을 이터레이트할 때 map() / every() / filter() / find() / findIndex() / reduce() / some() / \u0026hellip; 를 사용하세요. 배열을 생성할 때는 Object.keys() / Object.values() / Object.entries()를 사용해서 모든 객체를 이터레이트 할 수 있습니다.\n const numbers = [1, 2, 3, 4, 5]; // bad let sum = 0; for (let num of numbers) { sum += num; } sum === 15; // good let sum = 0; numbers.forEach((num) =\u0026gt; { sum += num; }); sum === 15; // best (use the functional force) const sum = numbers.reduce((total, num) =\u0026gt; total + num, 0); sum === 15; // bad const increasedByOne = []; for (let i = 0; i \u0026lt; numbers.length; i++) { increasedByOne.push(numbers[i] + 1); } // good const increasedByOne = []; numbers.forEach((num) =\u0026gt; { increasedByOne.push(num + 1); }); // best (keeping it functional) const increasedByOne = numbers.map(num =\u0026gt; num + 1);     11.2 지금은 제너레이터를 사용하지 마세요.\n 왜? ES5로 잘 트랜스파일되지 않기 때문입니다.\n     11.3 만약 반드시 제너레이터를 사용해야 하거나 우리의 조언을 무시하는 경우, 함수 시그니처의 공백이 적절한지 확인하세요. eslint: generator-star-spacing\n 왜? function과 *는 같은 개념의 키워드입니다. - *은 function, function*의 제어자가 아니며, 이들은 function과 다른 고유한 구조입니다.\n // bad function * foo() { // ... } // bad const bar = function * () { // ... }; // bad const baz = function *() { // ... }; // bad const quux = function*() { // ... }; // bad function*foo() { // ... } // bad function *foo() { // ... } // very bad function * foo() { // ... } // very bad const wat = function * () { // ... }; // good function* foo() { // ... } // good const foo = function* () { // ... };   ⬆ back to top\n속성 (Properties) #    12.1 속성에 접근할 때는 마침표를 사용하세요. eslint: dot-notation\nconst luke = { jedi: true, age: 28, }; // bad const isJedi = luke[\u0026#39;jedi\u0026#39;]; // good const isJedi = luke.jedi;     12.2 변수를 사용해 속성에 접근할 때는 대괄호 []를 사용하세요.\nconst luke = { jedi: true, age: 28, }; function getProp(prop) { return luke[prop]; } const isJedi = getProp(\u0026#39;jedi\u0026#39;);     12.3 제곱 계산을 할 때는 제곱 연산자 **을 사용하세요. eslint: no-restricted-properties.\n// bad const binary = Math.pow(2, 10); // good const binary = 2 ** 10;   ⬆ back to top\n변수 (Variables) #    13.1 변수를 선언할 때는 항상 const나 let을 사용하세요. 이렇게 하지 않으면 전역 변수로 선언됩니다. 우리는 전역 네임스페이스를 오염시키지 않기를 바랍니다. Captain Planet이 우리에게 경고했어요. eslint: no-undef prefer-const\n// bad superPower = new SuperPower(); // good const superPower = new SuperPower();     13.2 하나의 변수 선언/할당에는 하나의 const 또는 let을 사용하세요. eslint: one-var\n 왜? 이렇게 하면 쉽게 새로운 변수를 추가할 수 있고, ,를 ;로 바꿔버리는 것에 대해 걱정할 필요가 없습니다. 또한 한번에 모든 선언을 건너뛰는 대신 디버거를 사용해 각 선언을 단계별로 살펴볼 수 있습니다.\n // bad const items = getItems(), goSportsTeam = true, dragonball = \u0026#39;z\u0026#39;; // bad // (위 코드와 비교해 실수를 짚어보세요) const items = getItems(), goSportsTeam = true; dragonball = \u0026#39;z\u0026#39;; // good const items = getItems(); const goSportsTeam = true; const dragonball = \u0026#39;z\u0026#39;;     13.3 const를 그룹화한 다음에 let을 그룹화 하세요.\n 왜? 이전에 할당한 변수에 대해 새 변수를 추가하는 경우 유용하기 때문입니다.\n // bad let i, len, dragonball, items = getItems(), goSportsTeam = true; // bad let i; const items = getItems(); let dragonball; const goSportsTeam = true; let len; // good const goSportsTeam = true; const items = getItems(); let dragonball; let i; let length;     13.4 필요한 곳에서 변수를 할당하되, 합당한 곳에 두세요.\n 왜? let과 const는 블록스코프이기 때문입니다. 함수스코프가 아닙니다.\n // bad - unnecessary function call function checkName(hasName) { const name = getName(); if (hasName === \u0026#39;test\u0026#39;) { return false; } if (name === \u0026#39;test\u0026#39;) { this.setName(\u0026#39;\u0026#39;); return false; } return name; } // good function checkName(hasName) { if (hasName === \u0026#39;test\u0026#39;) { return false; } const name = getName(); if (name === \u0026#39;test\u0026#39;) { this.setName(\u0026#39;\u0026#39;); return false; } return name; }     13.5 변수 할당 체이닝을 하지 마세요. eslint: no-multi-assign\n 왜? 변수 할당 체이닝은 암시적인 전역 변수를 만들기 때문입니다.\n // bad (function example() { // 자바스크립트는 이것을  // let a = ( b = ( c = 1 ) );  // 로 해석합니다.  // let 키워드는 변수 a에만 적용됩니다.  // 변수 b와 c는 전역 변수가 됩니다.  let a = b = c = 1; }()); console.log(a); // throws ReferenceError console.log(b); // 1 console.log(c); // 1  // good (function example() { let a = 1; let b = a; let c = a; }()); console.log(a); // throws ReferenceError console.log(b); // throws ReferenceError console.log(c); // throws ReferenceError  // `const`에도 동일하게 적용됩니다     13.6 단항 증감 연산자(++, --)를 사용하지 마세요. eslint no-plusplus\n 왜? eslint 문서에 따르면, 단항 증감 구문은 자동으로 세미콜론을 삽입하며, 어플리케이션에서 값을 증감할 때 오류를 일으킬 수 있습니다. 또한 num += 1과 같은 구문을 통해 값을 변경하는 것이 num++이나 num ++와 같은 구문을 사용하는 것보다 더 의미있는 일이라고 생각합니다. 단항 증감 구문을 사용하지 않으면 프로그램에서 예기치 않은 동작을 일으키는 전위 증감 연산을 막을 수 있습니다.\n // bad  const array = [1, 2, 3]; let num = 1; num++; --num; let sum = 0; let truthyCount = 0; for (let i = 0; i \u0026lt; array.length; i++) { let value = array[i]; sum += value; if (value) { truthyCount++; } } // good  const array = [1, 2, 3]; let num = 1; num += 1; num -= 1; const sum = array.reduce((a, b) =\u0026gt; a + b, 0); const truthyCount = array.filter(Boolean).length;     13.7 값을 할당할 때 =의 앞 또는 뒤에서 줄바꿈을 하지 마세요. 만약 할당이 max-len을 넘기는 경우, 값을 괄호로 둘러싸세요. eslint operator-linebreak.\n 왜? = 주위에서 줄바꿈을 하는 것은 할당 값을 모호하게 합니다.\n // bad const foo = superLongLongLongLongLongLongLongLongFunctionName(); // bad const foo = \u0026#39;superLongLongLongLongLongLongLongLongString\u0026#39;; // good const foo = ( superLongLongLongLongLongLongLongLongFunctionName() ); // good const foo = \u0026#39;superLongLongLongLongLongLongLongLongString\u0026#39;;     13.8 사용하지 않는 변수를 남겨두지 마세요. eslint: no-unused-vars\n 왜? 선언되었지만 사용되지 않는 변수는 완벽하지 않은 리팩토링으로 인한 에러일 수 있습니다. 그런 변수는 코드의 자리를 차지하며, 읽는 사람이 혼란에 빠지도록 만듭니다.\n // bad  var some_unused_var = 42; // 쓰기 전용 변수는 사용한 것으로 간주되지 않습니다. var y = 10; y = 5; // 자신의 변경을 읽는 것은 사용한 것으로 간주되지 않습니다. var z = 0; z = z + 1; // 사용되지 않은 함수 인자. function getX(x, y) { return x; } // good  function getXPlusY(x, y) { return x + y; } var x = 1; var y = a + 2;   ㅣ alert(getXPlusY(x, y));\n// 'type'은 사용되지 않을 경우 무시됩니다. 나머지 속성의 형제이기 때문입니다. // 이것은 특정 키를 생략하는 객체를 추출하는 형식입니다. var { type, ...coords } = data; // 'coords'는 이제 'data' 객체에서 'type' 속성이 빠진 'data' 객체입니다. ```  ⬆ back to top\n호이스팅 (Hoisting) #    14.1 var 선언은 할당없이 가장 가까운 함수 스코프의 꼭대기에 호이스트됩니다. const와 let 선언은 Temporal Dead Zones (TDZ)라고 불리는 새로운 개념의 혜택을 받습니다. 왜 typeof는 더 이상 안전하지 않은가에 대해서 알고있는 것이 중요합니다.\n// (전역 변수 notDefined가 존재하지 않는다고 판정한 경우) // 동작하지 않습니다 function example() { console.log(notDefined); // =\u0026gt; throws a ReferenceError } // 그 변수를 참조하는 코드의 뒤에서 그 변수를 선언한 경우 // 변수가 호이스트된 상태에서 동작합니다. // 주의：`true` 라는 값 자체는 호이스트되지 않습니다. function example() { console.log(declaredButNotAssigned); // =\u0026gt; undefined  var declaredButNotAssigned = true; } // 인터프리터는 변수선언을 스코프의 선두에 호이스트합니다 // 위의 예는 다음과 같이 다시 쓸수 있습니다: function example() { let declaredButNotAssigned; console.log(declaredButNotAssigned); // =\u0026gt; undefined  declaredButNotAssigned = true; } // const와 let을 이용한 경우 function example() { console.log(declaredButNotAssigned); // =\u0026gt; throws a ReferenceError  console.log(typeof declaredButNotAssigned); // =\u0026gt; throws a ReferenceError  const declaredButNotAssigned = true; }     14.2 익명함수의 경우 함수가 할당되기 전의 변수가 호이스트됩니다.\nfunction example() { console.log(anonymous); // =\u0026gt; undefined  anonymous(); // =\u0026gt; TypeError anonymous is not a function  var anonymous = function () { console.log(\u0026#39;anonymous function expression\u0026#39;); }; }     14.3 명명함수의 경우에도 똑같이 변수가 호이스트됩니다. 함수의 이름이나 본체는 호이스트되지 않습니다.\nfunction example() { console.log(named); // =\u0026gt; undefined  named(); // =\u0026gt; TypeError named is not a function  superPower(); // =\u0026gt; ReferenceError superPower is not defined  var named = function superPower() { console.log(\u0026#39;Flying\u0026#39;); }; } // 함수 이름이 변수 이름과 동일할 때도 마찬가지다. function example() { console.log(named); // =\u0026gt; undefined  named(); // =\u0026gt; TypeError named is not a function  var named = function named() { console.log(\u0026#39;named\u0026#39;); }; }     14.4 함수선언은 함수명과 함수본체가 호이스트됩니다.\nfunction example() { superPower(); // =\u0026gt; Flying  function superPower() { console.log(\u0026#39;Flying\u0026#39;); } }   더 자세한 정보는 이곳을 참고해주세요 JavaScript Scoping \u0026amp; Hoisting by Ben Cherry.\n  ⬆ back to top\n비교 연산자 (Comparison Operators \u0026amp; Equality) #   15.1 ==와 != 대신 ===와 !==를 사용하세요. eslint: eqeqeq    15.2 if문과 같은 조건식은 ToBoolean 메소드에 의한 강제형변환으로 평가되어 항상 다음과 같은 간단한 규칙을 따릅니다:\n Objects는 true로 평가됩니다. Undefined는 false로 평가됩니다. Null는 false로 평가됩니다. Booleans는 boolean형의 값으로 평가됩니다. Numbers는 true로 평가됩니다. 하지만 +0, -0, NaN의 경우 false로 평가됩니다. Strings는 true로 평가됩니다. 하지만 빈 문자열 ''은, false로 평가됩니다.  if ([0] \u0026amp;\u0026amp; []) { // true  // 배열(빈 배열 포함)은 객체이며, 객체는 참으로 평가됩니다. }     15.3 불리언 비교에는 단축형을 사용하세요. 단, 숫자나 문자열은 명시적으로 비교하세요.\n// bad if (isValid === true) { // ... } // good if (isValid) { // ... } // bad if (name) { // ... } // good if (name !== \u0026#39;\u0026#39;) { // ... } // bad if (collection.length) { // ... } // good if (collection.length \u0026gt; 0) { // ... }    15.4 더 자세한 정보는 이곳을 참고해주세요. Truth Equality and JavaScript by Angus Croll.    15.5 렉시컬 선언 (e.g. let, const, function, and class)을 포함하는 case와 default 구문 안에 블록을 만들 때는 괄호를 사용하세요. eslint: no-case-declarations\n 왜? 렉시컬 선언은 switch 블록 전체에서 접근할 수 있지만, 할당된 경우에만 초기화됩니다. case에 다달았을 때 말이죠. 이것은 여러 case 구문이 같은 것을 정의하려 할 때 문제를 일으킵니다.\n // bad switch (foo) { case 1: let x = 1; break; case 2: const y = 2; break; case 3: function f() { // ...  } break; default: class C {} } // good switch (foo) { case 1: { let x = 1; break; } case 2: { const y = 2; break; } case 3: { function f() { // ...  } break; } case 4: bar(); break; default: { class C {} } }     15.6 삼항 연산자를 중첩해서는 안되며, 일반적으로 한줄에 표현해야 합니다. eslint: no-nested-ternary\n// bad const foo = maybe1 \u0026gt; maybe2 ? \u0026#34;bar\u0026#34; : value1 \u0026gt; value2 ? \u0026#34;baz\u0026#34; : null; // split into 2 separated ternary expressions const maybeNull = value1 \u0026gt; value2 ? \u0026#39;baz\u0026#39; : null; // better const foo = maybe1 \u0026gt; maybe2 ? \u0026#39;bar\u0026#39; : maybeNull; // best const foo = maybe1 \u0026gt; maybe2 ? \u0026#39;bar\u0026#39; : maybeNull;     15.7 불필요한 삼항 연산자를 사용하지 마세요. eslint: no-unneeded-ternary\n// bad const foo = a ? a : b; const bar = c ? true : false; const baz = c ? false : true; // good const foo = a || b; const bar = !!c; const baz = !c;     15.8 연산자를 섞어 사용할 때 해당 연산자들을 괄호로 둘러싸세요. 유일한 예외는 산술 연산자 (+, -, **)입니다. 이들의 우선순위는 상식적으로 이해할 수 있습니다. /와 *은 섞일 경우 순서가 모호할 수 있으므로 괄호로 감싸는 것을 추천합니다. eslint: no-mixed-operators\n 왜? 이렇게 하면 코드가 더 읽기 쉬워지며, 개발자의 의도가 명확해집니다.\n // bad const foo = a \u0026amp;\u0026amp; b \u0026lt; 0 || c \u0026gt; 0 || d + 1 === 0; // bad const bar = a ** b - 5 % d; // bad // (a || b) \u0026amp;\u0026amp; c 으로 혼동할 수 있습니다. if (a || b \u0026amp;\u0026amp; c) { return d; } // good const foo = (a \u0026amp;\u0026amp; b \u0026lt; 0) || c \u0026gt; 0 || (d + 1 === 0); // good const bar = (a ** b) - (5 % d); // good if (a || (b \u0026amp;\u0026amp; c)) { return d; } // good const bar = a + b / c * d;   ⬆ back to top\n블록 (Blocks) #    16.1 여러 줄의 블록에는 중괄호를 사용하세요. eslint: nonblock-statement-body-position\n// bad if (test) return false; // good if (test) return false; // good if (test) { return false; } // bad function foo() { return false; } // good function bar() { return false; }     16.2 여러 줄의 if와 else문을 사용할 때는 else를 if 블록의 닫는 중괄호와 같은 줄에 두세요. eslint: brace-style\n// bad if (test) { thing1(); thing2(); } else { thing3(); } // good if (test) { thing1(); thing2(); } else { thing3(); }     16.3 만약 if 블록이 항상 return 구문을 실행시킨다면, else 블록은 불필요합니다. return을 포함한 if블록을 잇는 else if 블록 안에 return 구문이 있으면 여러 if 블록으로 나눠질 수 있습니다. eslint: no-else-return\n// bad function foo() { if (x) { return x; } else { return y; } } // bad function cats() { if (x) { return x; } else if (y) { return y; } } // bad function dogs() { if (x) { return x; } else { if (y) { return y; } } } // good function foo() { if (x) { return x; } return y; } // good function cats() { if (x) { return x; } if (y) { return y; } } // good function dogs(x) { if (x) { if (z) { return y; } } else { return z; } }   ⬆ back to top\n제어문 (Control Statements) #    17.1 제어문 (if, while 등)이 너무 길거나 최대 길이를 넘긴 경우, 각 조건을 새로운 줄에 두세요. 논리 연산자는 줄의 시작부분에 있어야 합니다.\n 왜? 줄의 맨 처음에 연산자를 두면 연산자의 정렬을 유지하고, 메소드 체이닝과 비슷한 패턴을 따를 수 있습니다. 또, 이렇게 하면 복잡한 로직을 쉽게 볼 수 있도록 만들어 가독성을 높입니다.\n // bad if ((foo === 123 || bar === \u0026#39;abc\u0026#39;) \u0026amp;\u0026amp; doesItLookGoodWhenItBecomesThatLong() \u0026amp;\u0026amp; isThisReallyHappening()) { thing1(); } // bad if (foo === 123 \u0026amp;\u0026amp; bar === \u0026#39;abc\u0026#39;) { thing1(); } // bad if (foo === 123 \u0026amp;\u0026amp; bar === \u0026#39;abc\u0026#39;) { thing1(); } // bad if ( foo === 123 \u0026amp;\u0026amp; bar === \u0026#39;abc\u0026#39; ) { thing1(); } // good if ( foo === 123 \u0026amp;\u0026amp; bar === \u0026#39;abc\u0026#39; ) { thing1(); } // good if ( (foo === 123 || bar === \u0026#39;abc\u0026#39;) \u0026amp;\u0026amp; doesItLookGoodWhenItBecomesThatLong() \u0026amp;\u0026amp; isThisReallyHappening() ) { thing1(); } // good if (foo === 123 \u0026amp;\u0026amp; bar === \u0026#39;abc\u0026#39;) { thing1(); }     17.2. 선택 연산자를 제어 구문 대신 쓰지 마세요.\n// bad !isRunning \u0026amp;\u0026amp; startRunning(); // good if (!isRunning) { startRunning(); }   ⬆ back to top\n주석 (Comments) #    18.1 여러 줄에 걸친 주석을 쓸 때는 /** ... */을 사용하세요.\n// bad // make()는 전달된 태그명을 기반으로 // 새로운 요소를 반환한다. // // @param {String} tag // @return {Element} element function make(tag) { // ...  return element; } // good /** * make()는 전달된 태그명을 기반으로 * 새로운 요소를 반환한다. */ function make(tag) { // ...  return element; }     18.2 한줄 주석을 쓸 때는 //을 사용하세요. 주석 전에는 빈 행을 넣어주세요.\n// bad const active = true; // is current tab  // good // is current tab const active = true; // bad function getType() { console.log(\u0026#39;fetching type...\u0026#39;); // set the default type to \u0026#39;no type\u0026#39;  const type = this.type || \u0026#39;no type\u0026#39;; return type; } // good function getType() { console.log(\u0026#39;fetching type...\u0026#39;); // set the default type to \u0026#39;no type\u0026#39;  const type = this.type || \u0026#39;no type\u0026#39;; return type; } // also good function getType() { // set the default type to \u0026#39;no type\u0026#39;  const type = this.type || \u0026#39;no type\u0026#39;; return type; }     18.3 모든 주석은 공백으로 시작해야 합니다. eslint: spaced-comment\n// bad //is current tab const active = true; // good // is current tab const active = true; // bad /** *make()는 전달된 태그명을 기반으로 *새로운 요소를 반환한다. */ function make(tag) { // ...  return element; } // good /** * make()는 전달된 태그명을 기반으로 * 새로운 요소를 반환한다. */ function make(tag) { // ...  return element; }    18.4 문제를 지적하고 재고를 촉구하는 경우나 문제의 해결책을 제안하는 경우 등에는 주석 앞에 FIXME 나 TODO 를 붙임으로써 다른 개발자의 빠른 이해를 도울수 있습니다. 이런 것들은 어떤 행동을 따른다는 의미로 통상의 주석와는 다릅니다. 행동이라는 것은 FIXME -- 해결이 필요 또는 TODO -- 구현이 필요 를 뜻합니다.    18.5 문제에 대한 주석으로 // FIXME:를 사용하세요.\nclass Calculator extends Abacus { constructor() { super(); // FIXME: 전역 변수를 사용해서는 안 됨  total = 0; } }     18.6 문제의 해결책에 대한 주석으로 // TODO:를 사용하세요.\nclass Calculator extends Abacus { constructor() { super(); // TODO: total은 옵션 파라메터로 설정해야함  this.total = 0; } }   ⬆ back to top\n공백 (Whitespace) #    19.1 탭은 공백문자 2개로 설정하세요. eslint: indent\n// bad function foo() { ∙∙∙∙let name; } // bad function bar() { ∙let name; } // good function baz() { ∙∙let name; }     19.2 주요 중괄호 앞에는 공백을 1개 넣으세요. eslint: space-before-blocks\n// bad function test(){ console.log(\u0026#39;test\u0026#39;); } // good function test() { console.log(\u0026#39;test\u0026#39;); } // bad dog.set(\u0026#39;attr\u0026#39;,{ age: \u0026#39;1 year\u0026#39;, breed: \u0026#39;Bernese Mountain Dog\u0026#39;, }); // good dog.set(\u0026#39;attr\u0026#39;, { age: \u0026#39;1 year\u0026#39;, breed: \u0026#39;Bernese Mountain Dog\u0026#39;, });     19.3 제어문 (if, while 등)의 소괄호 앞에는 공백을 1개 넣으세요. 함수선언이나 함수호출시 인자 리스트 앞에는 공백을 넣지 마세요. eslint: keyword-spacing\n// bad if(isJedi) { fight (); } // good if (isJedi) { fight(); } // bad function fight () { console.log (\u0026#39;Swooosh!\u0026#39;); } // good function fight() { console.log(\u0026#39;Swooosh!\u0026#39;); }     19.4 연산자 사이에 공백을 넣으세요. eslint: space-infix-ops\n// bad const x=y+5; // good const x = y + 5;     19.5 파일 끝에는 개행문자를 1개 넣으세요. eslint: eol-last\n// bad import { es6 } from \u0026#39;./AirbnbStyleGuide\u0026#39;; // ... export default es6; // bad import { es6 } from \u0026#39;./AirbnbStyleGuide\u0026#39;; // ... export default es6;↵ ↵ // good import { es6 } from \u0026#39;./AirbnbStyleGuide\u0026#39;; // ... export default es6;↵     19.6 길게 메소드를 체이닝하는 경우 (2개 메소드 이상) 들여쓰기를 하세요. 또한 해당 줄이 새로운 구문이 아니라 메소드 호출임을 강조하는 마침표를 맨 앞에 두세요. eslint: newline-per-chained-call no-whitespace-before-property\n// bad $(\u0026#39;#items\u0026#39;).find(\u0026#39;.selected\u0026#39;).highlight().end().find(\u0026#39;.open\u0026#39;).updateCount(); // bad $(\u0026#39;#items\u0026#39;). find(\u0026#39;.selected\u0026#39;). highlight(). end(). find(\u0026#39;.open\u0026#39;). updateCount(); // good $(\u0026#39;#items\u0026#39;) .find(\u0026#39;.selected\u0026#39;) .highlight() .end() .find(\u0026#39;.open\u0026#39;) .updateCount(); // bad const leds = stage.selectAll(\u0026#39;.led\u0026#39;).data(data).enter().append(\u0026#39;svg:svg\u0026#39;).classed(\u0026#39;led\u0026#39;, true) .attr(\u0026#39;width\u0026#39;, (radius + margin) * 2).append(\u0026#39;svg:g\u0026#39;) .attr(\u0026#39;transform\u0026#39;, `translate(${radius + margin},${radius + margin})`) .call(tron.led); // good const leds = stage.selectAll(\u0026#39;.led\u0026#39;) .data(data) .enter().append(\u0026#39;svg:svg\u0026#39;) .classed(\u0026#39;led\u0026#39;, true) .attr(\u0026#39;width\u0026#39;, (radius + margin) * 2) .append(\u0026#39;svg:g\u0026#39;) .attr(\u0026#39;transform\u0026#39;, `translate(${radius + margin},${radius + margin})`) .call(tron.led); // good const leds = stage.selectAll(\u0026#39;.led\u0026#39;).data(data);     19.7 구문의 앞과 블록의 뒤에는 빈 행을 두세요.\n// bad if (foo) { return bar; } return baz; // good if (foo) { return bar; } return baz; // bad const obj = { foo() { }, bar() { }, }; return obj; // good const obj = { foo() { }, bar() { }, }; return obj; // bad const arr = [ function foo() { }, function bar() { }, ]; return arr; // good const arr = [ function foo() { }, function bar() { }, ]; return arr;     19.8 블록에 빈 행을 끼워 넣지 마세요. eslint: padded-blocks\n// bad function bar() { console.log(foo); } // bad if (baz) { console.log(qux); } else { console.log(foo); } // bad class Foo { constructor(bar) { this.bar = bar; } } // good function bar() { console.log(foo); } // good if (baz) { console.log(qux); } else { console.log(foo); }     19.9 여러 빈 행을 두지 마세요. eslint: no-multiple-empty-lines\n// bad class Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = this.getAge(today, birthday); this.age = age; } getAge(today, birthday) { // ..  } } // good class Person { constructor(fullName, email, birthday) { this.fullName = fullName; this.email = email; this.setAge(birthday); } setAge(birthday) { const today = new Date(); const age = getAge(today, birthday); this.age = age; } getAge(today, birthday) { // ..  } }     19.10 소괄호 안쪽에 공백을 두지 마세요. eslint: space-in-parens\n// bad function bar( foo ) { return foo; } // good function bar(foo) { return foo; } // bad if ( foo ) { console.log(foo); } // good if (foo) { console.log(foo); }     19.11 대괄호 안쪽에 공백을 두지 마세요. eslint: array-bracket-spacing\n// bad const foo = [ 1, 2, 3 ]; console.log(foo[ 0 ]); // good const foo = [1, 2, 3]; console.log(foo[0]);     19.12 중괄호 안쪽에 공백을 두세요. eslint: object-curly-spacing\n// bad const foo = {clark: \u0026#39;kent\u0026#39;}; // good const foo = { clark: \u0026#39;kent\u0026#39; };     19.13 한줄의 코드가 100자를 넘기는 것을 피하세요. (공백 포함) 주의: 앞의 규칙에 따르면, 긴 문자열은 이 규칙에서 제외되며, 분리되어서는 안 됩니다. eslint: max-len\n 왜? 가독성과 유지보수성을 보장해주기 때문입니다.\n // bad const foo = jsonData \u0026amp;\u0026amp; jsonData.foo \u0026amp;\u0026amp; jsonData.foo.bar \u0026amp;\u0026amp; jsonData.foo.bar.baz \u0026amp;\u0026amp; jsonData.foo.bar.baz.quux \u0026amp;\u0026amp; jsonData.foo.bar.baz.quux.xyzzy; // bad $.ajax({ method: \u0026#39;POST\u0026#39;, url: \u0026#39;https://airbnb.com/\u0026#39;, data: { name: \u0026#39;John\u0026#39; } }).done(() =\u0026gt; console.log(\u0026#39;Congratulations!\u0026#39;)).fail(() =\u0026gt; console.log(\u0026#39;You have failed this city.\u0026#39;)); // good const foo = jsonData \u0026amp;\u0026amp; jsonData.foo \u0026amp;\u0026amp; jsonData.foo.bar \u0026amp;\u0026amp; jsonData.foo.bar.baz \u0026amp;\u0026amp; jsonData.foo.bar.baz.quux \u0026amp;\u0026amp; jsonData.foo.bar.baz.quux.xyzzy; // good $.ajax({ method: \u0026#39;POST\u0026#39;, url: \u0026#39;https://airbnb.com/\u0026#39;, data: { name: \u0026#39;John\u0026#39; }, }) .done(() =\u0026gt; console.log(\u0026#39;Congratulations!\u0026#39;)) .fail(() =\u0026gt; console.log(\u0026#39;You have failed this city.\u0026#39;));   19.14 여는 블록 토큰과 같은 행의 다음 토큰 내의 공백을 일관성있게 하세요. 이 규칙은 닫는 블록 토큰과 같은 행의 이전 토큰에도 적용됩니다. eslint: block-spacing\n// bad function foo() {return true;} if (foo) { bar = 0;} // good function foo() { return true; } if (foo) { bar = 0; }     19.15 쉼표 이전에는 공백을 넣지 말고, 쉼표 이후에는 공백을 넣으세요. eslint: comma-spacing\n// bad var foo = 1,bar = 2; var arr = [1 , 2]; // good var foo = 1, bar = 2; var arr = [1, 2];     19.16 계산된 속성 내에는 공백을 넣으세요. eslint: computed-property-spacing\n// bad obj[foo ] obj[ \u0026#39;foo\u0026#39;] var x = {[ b ]: a} obj[foo[ bar ]] // good obj[foo] obj[\u0026#39;foo\u0026#39;] var x = { [b]: a } obj[foo[bar]]     19.17 함수를 호출할 때는 공백을 넣지 마세요. eslint: func-call-spacing\n// bad func (); func (); // good func();   19.18 객체 리터럴 속성의 키와 값 사이에는 공백을 넣으세요. eslint: key-spacing\n// bad var obj = { \u0026#34;foo\u0026#34; : 42 }; var obj2 = { \u0026#34;foo\u0026#34;:42 }; // good var obj = { \u0026#34;foo\u0026#34;: 42 };   19.19 해의 마지막에 공백을 남겨두지 마세요. eslint: no-trailing-spaces\n    19.20 여러 빈 행을 쓰지 마세요. 단, 파일의 마지막 행에는 빈 행을 두세요. 파일의 시작에는 빈 행을 두지 마세요. eslint: no-multiple-empty-lines\n// bad - 여러 개의 빈 줄 var x = 1; var y = 2; // bad - 파일 끝에 2개 이상의 빈 줄 var x = 1; var y = 2; // bad - 파일 시작에 1개 이상의 빈 줄  var x = 1; var y = 2; // good var x = 1; var y = 2;   ⬆ back to top\n쉼표 (Commas) #    20.1 맨 앞의 쉼표: 안 됩니다. eslint: comma-style\n// bad const story = [ once , upon , aTime ]; // good const story = [ once, upon, aTime, ]; // bad const hero = { firstName: \u0026#39;Ada\u0026#39; , lastName: \u0026#39;Lovelace\u0026#39; , birthYear: 1815 , superPower: \u0026#39;computers\u0026#39; }; // good const hero = { firstName: \u0026#39;Ada\u0026#39;, lastName: \u0026#39;Lovelace\u0026#39;, birthYear: 1815, superPower: \u0026#39;computers\u0026#39;, };     20.2 끝의 쉼표: 좋아요. eslint: comma-dangle\n 왜? 이것은 깨끗한 git의 diffs로 이어집니다. 또한 Babel과 같은 트랜스파일러는 트랜스파일하는 사이에 쓸데없는 끝의 쉼표를 제거합니다. 이것은 레거시 브라우저에서의 불필요한 쉼표 문제를 고민할 필요가 없는 것을 의미합니다.\n // bad - 마지막에 쉼표가 없는 경우 git diff const hero = { firstName: \u0026#39;Florence\u0026#39;, - lastName: \u0026#39;Nightingale\u0026#39; + lastName: \u0026#39;Nightingale\u0026#39;, + inventorOf: [\u0026#39;coxcomb chart\u0026#39;, \u0026#39;modern nursing\u0026#39;] }; // good - 마지막에 쉼표가 있는 경우 git diff const hero = { firstName: \u0026#39;Florence\u0026#39;, lastName: \u0026#39;Nightingale\u0026#39;, + inventorOf: [\u0026#39;coxcomb chart\u0026#39;, \u0026#39;modern nursing\u0026#39;], }; // bad const hero = { firstName: \u0026#39;Dana\u0026#39;, lastName: \u0026#39;Scully\u0026#39; }; const heroes = [ \u0026#39;Batman\u0026#39;, \u0026#39;Superman\u0026#39; ]; // good const hero = { firstName: \u0026#39;Dana\u0026#39;, lastName: \u0026#39;Scully\u0026#39;, }; const heroes = [ \u0026#39;Batman\u0026#39;, \u0026#39;Superman\u0026#39;, ]; // bad function createHero( firstName, lastName, inventorOf ) { // does nothing } // good function createHero( firstName, lastName, inventorOf, ) { // does nothing } // good (\u0026#34;나머지\u0026#34; 요소 뒤에 쉼표가 없다는 점에 주의하세요) function createHero( firstName, lastName, inventorOf, ...heroArgs ) { // does nothing } // bad createHero( firstName, lastName, inventorOf ); // good createHero( firstName, lastName, inventorOf, ); // good (\u0026#34;나머지\u0026#34; 요소 뒤에 쉼표가 없다는 점에 주의하세요) createHero( firstName, lastName, inventorOf, ...heroArgs );   ⬆ back to top\n세미콜론 (Semicolons) #    21.1 씁시다. eslint: semi\n 왜? 자바스크립트가 세미콜론이 없는 줄바꿈을 만났을 때, 자동 세미콜론 삽입 규칙에 따라 그 줄바꿈을 구문의 끝으로 간주할지 여부를 결정하고, (이름이 암시하듯) 세미콜론을 줄바꿈 이전에 삽입합니다. ASI는 몇가지 별난 동작을 포함하고 있지만, 만약 자바스크립트가 줄바꿈을 잘못 해석한다면 코드가 망가져버릴 것입니다. 이 규칙은 새로운 기능이 자바스크립트의 일부가 되면서 더 복잡해집니다. 구문의 끝을 명시하고, 빠뜨린 세미콜론을 잡도록 linter를 설정하면 문제가 발생하는 것을 막을 수 있습니다.\n // bad - 예외 발생 const luke = {} const leia = {} [luke, leia].forEach(jedi =\u0026gt; jedi.father = \u0026#39;vader\u0026#39;) // bad - 예외 발생 const reaction = \u0026#34;No! That\u0026#39;s impossible!\u0026#34; (async function meanwhileOnTheFalcon() { // handle `leia`, `lando`, `chewie`, `r2`, `c3p0`  // ... }()) // bad - returns `undefined` instead of the value on the next line - always happens when `return` is on a line by itself because of ASI! function foo() { return \u0026#39;search your feelings, you know it to be foo\u0026#39; } // good const luke = {}; const leia = {}; [luke, leia].forEach((jedi) =\u0026gt; { jedi.father = \u0026#39;vader\u0026#39;; }); // good const reaction = \u0026#34;No! That\u0026#39;s impossible!\u0026#34;; (async function meanwhileOnTheFalcon() { // handle `leia`, `lando`, `chewie`, `r2`, `c3p0`  // ... }()); // good function foo() { return \u0026#39;search your feelings, you know it to be foo\u0026#39;; } Read more.\n  ⬆ back to top\n형변환과 강제 (Type Casting \u0026amp; Coercion) #   22.1 구문의 선두에서 형을 강제합니다.    22.2 문자열: eslint: no-new-wrappers\n// =\u0026gt; this.reviewScore = 9;  // bad const totalScore = new String(this.reviewScore); // typeof totalScore is \u0026#34;object\u0026#34; not \u0026#34;string\u0026#34;  // bad const totalScore = this.reviewScore + \u0026#39;\u0026#39;; // invokes this.reviewScore.valueOf()  // bad const totalScore = this.reviewScore.toString(); // isn’t guaranteed to return a string  // good const totalScore = String(this.reviewScore);     22.3 숫자: 형변환을 하는 경우 Number를 사용하고, 문자열을 파싱하는 경우에는 기수를 인자로 넘겨 parseInt를 사용하세요. eslint: radix no-new-wrappers\nconst inputValue = \u0026#39;4\u0026#39;; // bad const val = new Number(inputValue); // bad const val = +inputValue; // bad const val = inputValue \u0026gt;\u0026gt; 0; // bad const val = parseInt(inputValue); // good const val = Number(inputValue); // good const val = parseInt(inputValue, 10);     22.4 어떤 이유로 인해 parseInt가 병목현상을 일으켜 성능적인 이유로 비트 시프트를 사용해야 하는 경우 하려고 했던 것을 왜(why)와 무엇(what)으로 설명해 주석으로 남겨주세요.\n// good /** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. * 코드가 느린 원인은 parseInt였음. * 비트 시프트를 통해 문자열을 강제 형변환하여 * 성능을 개선시킴. */ const val = inputValue \u0026gt;\u0026gt; 0;     22.5 주의: 비트 연산자를 사용하는 경우. 숫자는 64비트 값으로 표현되어 있으나, 비트 시프트 연산을 한 경우 32비트 정수로 넘겨집니다. (소스). 32비트 이상의 정수를 비트 시프트하는 경우 예기치못한 현상을 야기할 수 있습니다. 토론. 부호가 포함된 32비트 정수의 최대치는 2,147,483,647입니다:\n2147483647 \u0026gt;\u0026gt; 0; // =\u0026gt; 2147483647 2147483648 \u0026gt;\u0026gt; 0; // =\u0026gt; -2147483648 2147483649 \u0026gt;\u0026gt; 0; // =\u0026gt; -2147483647     22.6 불리언: eslint: no-new-wrappers\nconst age = 0; // bad const hasAge = new Boolean(age); // good const hasAge = Boolean(age); // best const hasAge = !!age;   ⬆ back to top\n명명규칙 (Naming Conventions) #    23.1 한 문자로 된 이름은 피하세요. 이름으로부터 의도가 읽혀질 수 있게 해주세요. eslint: id-length\n// bad function q() { // ... } // good function query() { // ... }     23.2 객체, 함수, 인스턴스에는 캐멀케이스(camelCase)를 사용하세요. eslint: camelcase\n// bad const OBJEcttsssss = {}; const this_is_my_object = {}; function c() {} // good const thisIsMyObject = {}; function thisIsMyFunction() {}     23.3 클래스나 생성자에는 파스칼케이스(PascalCase)를 사용하세요. eslint: new-cap\n// bad function user(options) { this.name = options.name; } const bad = new user({ name: \u0026#39;nope\u0026#39;, }); // good class User { constructor(options) { this.name = options.name; } } const good = new User({ name: \u0026#39;yup\u0026#39;, });     23.4 언더스코어를 사용하지 마세요. eslint: no-underscore-dangle\n 왜? 자바스크립트는 속성이나 메소드 측면에서 은닉된 정보라는 개념을 가지고 있지 않습니다. 언더스코어는 일반적으로 “private”을 의미하지만, 사실 자바스크립트에서 해당 속성은 완전히 public하며, 이는 공공 API의 일부입니다. 이 관례는 개발자들로 하여금 변화가 깨지지 않는 것으로 간주하거나 테스트가 필요하지 않다고 잘못 생각하게 만듭니다. 요약: 만약 뭔가를 “private”하게 사용하고 싶다면, 그것은 있을 수 없는 일입니다.\n // bad this.__firstName__ = \u0026#39;Panda\u0026#39;; this.firstName_ = \u0026#39;Panda\u0026#39;; this._firstName = \u0026#39;Panda\u0026#39;; // good this.firstName = \u0026#39;Panda\u0026#39;; // good, in environments where WeakMaps are available // see https://kangax.github.io/compat-table/es6/#test-WeakMap const firstNames = new WeakMap(); firstNames.set(this, \u0026#39;Panda\u0026#39;);     23.5 참조를 this에 저장하지 마세요. 화살표 함수나 Function#bind를 사용하세요.\n// bad function foo() { const self = this; return function () { console.log(self); }; } // bad function foo() { const that = this; return function () { console.log(that); }; } // good function foo() { return () =\u0026gt; { console.log(this); }; }     23.6 파일 이름은 default export의 이름과 일치해야 합니다.\n// 파일 1 내용 class CheckBox { // ... } export default CheckBox; // 파일 2 내용 export default function fortyTwo() { return 42; } // 파일 3 내용 export default function insideDirectory() {} // 다른 파일 // bad import CheckBox from \u0026#39;./checkBox\u0026#39;; // PascalCase import/export, camelCase filename import FortyTwo from \u0026#39;./FortyTwo\u0026#39;; // PascalCase import/filename, camelCase export import InsideDirectory from \u0026#39;./InsideDirectory\u0026#39;; // PascalCase import/filename, camelCase export  // bad import CheckBox from \u0026#39;./check_box\u0026#39;; // PascalCase import/export, snake_case filename import forty_two from \u0026#39;./forty_two\u0026#39;; // snake_case import/filename, camelCase export import inside_directory from \u0026#39;./inside_directory\u0026#39;; // snake_case import, camelCase export import index from \u0026#39;./inside_directory/index\u0026#39;; // requiring the index file explicitly import insideDirectory from \u0026#39;./insideDirectory/index\u0026#39;; // requiring the index file explicitly  // good import CheckBox from \u0026#39;./CheckBox\u0026#39;; // PascalCase export/import/filename import fortyTwo from \u0026#39;./fortyTwo\u0026#39;; // camelCase export/import/filename import insideDirectory from \u0026#39;./insideDirectory\u0026#39;; // camelCase export/import/directory name/implicit \u0026#34;index\u0026#34; // ^ supports both insideDirectory.js and insideDirectory/index.js     23.7 함수를 export-default할 때 캐멀케이스(camelCase)를 사용하세요. 파일 이름은 함수 이름과 같아야 합니다.\nfunction makeStyleGuide() { // ... } export default makeStyleGuide;     23.8 생성자 / 클래스 / 싱글톤 / 함수 라이브러리 / 단순 객체를 export할 때 파스칼케이스(PascalCase)를 사용하세요.\nconst AirbnbStyleGuide = { es6: { }, }; export default AirbnbStyleGuide;     23.9 두문자어와 이니셜은 모두 대문자이거나 모두 소문자이어야 합니다.\n 왜? 이름은 가독성을 위한 것이지 컴퓨터 알고리즘을 위한 것이 아니기 때문입니다.\n // bad import SmsContainer from \u0026#39;./containers/SmsContainer\u0026#39;; // bad const HttpRequests = [ // ... ]; // good import SMSContainer from \u0026#39;./containers/SMSContainer\u0026#39;; // good const HTTPRequests = [ // ... ]; // also good const httpRequests = [ // ... ]; // best import TextMessageContainer from \u0026#39;./containers/TextMessageContainer\u0026#39;; // best const requests = [ // ... ];     23.10 상수 이름을 대문자로 짓는 것은 해당 상수가 (1) 내보내기 될 때, (2) const 타입일 때 (값이 재할당되지 못할 때), (3) 그 상수와 상수가 중첩된 속성이 절대 변하지 않는다는 것을 신뢰할 수 있을 때만 하세요.\n 왜? 이것은 변수가 영원히 변하지 않는다는 것을 확신할 수 없을 때 도움을 주기 위한 추가적인 도구입니다. 대문자 변수는 변수와 변수의 속성이 변하지 않는다는 것을 프로그래머에게 알려줍니다.\n   모든 const 변수 이름을 대문자로 짓나요? - 이것은 필수사항이 아니며, 파일 내 상수 이름을 꼭 대문자로 지을 필요는 없습니다. 하지만 내보내기되는 상수 이름은 대문자로 지어야 합니다.\n  내보내기 되는 객체 이름을 대문자로 짓나요? - 최상위 수준의 내보내기를 할 때 대문자로 이름짓고 (예시: EXPORTED_OBJECT.key) 모든 중첩된 속성이 변경되지 않도록 유지합니다.\n  // bad const PRIVATE_VARIABLE = \u0026#39;should not be unnecessarily uppercased within a file\u0026#39;; // bad export const THING_TO_BE_CHANGED = \u0026#39;should obviously not be uppercased\u0026#39;; // bad export let REASSIGNABLE_VARIABLE = \u0026#39;do not use let with uppercase variables\u0026#39;; // ---  // allowed but does not supply semantic value export const apiKey = \u0026#39;SOMEKEY\u0026#39;; // better in most cases export const API_KEY = \u0026#39;SOMEKEY\u0026#39;; // ---  // bad - unnecessarily uppercases key while adding no semantic value export const MAPPING = { KEY: \u0026#39;value\u0026#39; }; // good export const MAPPING = { key: \u0026#39;value\u0026#39; };   ⬆ back to top\n접근자 (Accessors) #   24.1 속성을 위한 접근자 함수는 필수가 아닙니다.    24.2 자바스크립트 getters/setters를 사용하지 마세요. 예기치못한 부작용를 일으키고 테스트와 유지보수를 어렵게 만듭니다. 접근자 함수를 만들고 싶다면 대신, getVal()과 setVal('hello')를 사용하세요.\n// bad class Dragon { get age() { // ...  } set age(value) { // ...  } } // good class Dragon { getAge() { // ...  } setAge(value) { // ...  } }     24.3 속성이나 메소드가 boolean이라면, isVal()이나 hasVal()을 사용하세요.\n// bad if (!dragon.age()) { return false; } // good if (!dragon.hasAge()) { return false; }     24.4 get()과 set() 함수를 만들되, 일관성있게 만드세요.\nclass Jedi { constructor(options = {}) { const lightsaber = options.lightsaber || \u0026#39;blue\u0026#39;; this.set(\u0026#39;lightsaber\u0026#39;, lightsaber); } set(key, val) { this[key] = val; } get(key) { return this[key]; } }   ⬆ back to top\n이벤트 (Events) #    25.1 (DOM이벤트나 Backbone 이벤트와 같은) 이벤트로 payload의 값을 넘길 경우 raw값 보다는 해시값을 넘겨주세요. 이렇게하면 이후 기여자가 이벤트에 관련한 모든 핸들러를 찾아서 바꾸는 대신 이벤트 payload에 값을 추가할 수 있습니다. 예를 들면 이렇게요:\n// bad $(this).trigger(\u0026#39;listingUpdated\u0026#39;, listing.id); // ...  $(this).on(\u0026#39;listingUpdated\u0026#39;, (e, listingID) =\u0026gt; { // do something with listingID }); 이쪽이 더 좋습니다:\n// good $(this).trigger(\u0026#39;listingUpdated\u0026#39;, { listingID: listing.id }); // ...  $(this).on(\u0026#39;listingUpdated\u0026#39;, (e, data) =\u0026gt; { // do something with data.listingID });   ⬆ back to top\n제이쿼리 (jQuery) #    26.1 제이쿼리 객체 변수의 앞에는 $를 붙여주세요.\n// bad const sidebar = $(\u0026#39;.sidebar\u0026#39;); // good const $sidebar = $(\u0026#39;.sidebar\u0026#39;); // good const $sidebarBtn = $(\u0026#39;.sidebar-btn\u0026#39;);     26.2 제이쿼리의 검색결과를 캐시하세요.\n// bad function setSidebar() { $(\u0026#39;.sidebar\u0026#39;).hide(); // ...  $(\u0026#39;.sidebar\u0026#39;).css({ \u0026#39;background-color\u0026#39;: \u0026#39;pink\u0026#39;, }); } // good function setSidebar() { const $sidebar = $(\u0026#39;.sidebar\u0026#39;); $sidebar.hide(); // ...  $sidebar.css({ \u0026#39;background-color\u0026#39;: \u0026#39;pink\u0026#39;, }); }    26.3 DOM 검색에는 $('.sidebar ul')이나 parent \u0026gt; child $('.sidebar \u0026gt; ul')와 같은 캐스케이딩를 사용하세요. jsPerf    26.4 한정된 제이쿼리 객체 쿼리에는 find를 사용하세요.\n// bad $(\u0026#39;ul\u0026#39;, \u0026#39;.sidebar\u0026#39;).hide(); // bad $(\u0026#39;.sidebar\u0026#39;).find(\u0026#39;ul\u0026#39;).hide(); // good $(\u0026#39;.sidebar ul\u0026#39;).hide(); // good $(\u0026#39;.sidebar \u0026gt; ul\u0026#39;).hide(); // good $sidebar.find(\u0026#39;ul\u0026#39;).hide();   ⬆ back to top\nES5 호환성 (ECMAScript 5 Compatibility) #   27.1 Kangax의 ES5 호환성 표를 참고하세요.  ⬆ back to top\nECMAScript 6+ (ES 2015+) 스타일 #   28.1 여러 ES6+ 기능과 관련된 링크 모음입니다.   화살표 함수 (Arrow Functions) 클래스 (Classes) 객체 단축형 (Object Shorthand) 객체 속성 단축형 (Object Concise) 객체 속성 계산 (Object Computed Properties) 템플릿 문자열 (Template Strings) 비구조화 (Destructuring) 기본 매개변수 (Default Parameters) 나머지 구문 (Rest) 배열 전개 (Array Spreads) Let과 Const (Let and Const) 제곱 연산자 (Exponentiation Operator) 이터레이터와 제너레이터 (Iterators and Generators) 모듈 (Modules)    28.2 스테이지3에 이르지 못하는 TC39 proposals를 사용하지 마세요.\n 왜? 그것들은 확정되지 않았습니다. 그리고 이들은 변경되거나 완전히 폐기될 수도 있습니다. 우리는 자바스크립트를 사용하기를 원하지만, proposals는 아직 자바스크립트가 아닙니다.\n   ⬆ back to top\n표준 라이브러리 (Standard Library) #  표준 라이브러리는 기능적으로 문제가 있지만 레거시 이유로 아직 남아있는 유틸리티들을 포함하고 있습니다.\n  29.1 전역 isNaN 대신 Number.isNaN을 사용하세요. eslint: no-restricted-globals\n 왜? 전역 isNaN은 숫자가 아닌 것을 숫자로 강제하고, NaN으로 간주되는 모든 것을 true로 반환합니다. 만약 이것을 사용해야 한다면 명시적으로 사용하세요.\n // bad isNaN(\u0026#39;1.2\u0026#39;); // false isNaN(\u0026#39;1.2.3\u0026#39;); // true  // good Number.isNaN(\u0026#39;1.2.3\u0026#39;); // false Number.isNaN(Number(\u0026#39;1.2.3\u0026#39;)); // true     29.2 전역 isFinite 대신 Number.isFinite을 사용하세요. eslint: no-restricted-globals\n 왜? 전역 isFinite은 숫자가 아닌 것을 숫자로 강제하고, 유한한 숫자로 간주되는 모든 것을 true로 반환합니다. 만약 이것을 사용해야 한다면 명시적으로 사용하세요.\n // bad isFinite(\u0026#39;2e3\u0026#39;); // true  // good Number.isFinite(\u0026#39;2e3\u0026#39;); // false Number.isFinite(parseInt(\u0026#39;2e3\u0026#39;, 10)); // true   ⬆ back to top\n테스트 (Testing) #    30.1 Yup.   30.1 합시다.\nfunction foo() { return true; }    30.2 진지하게 생각해보죠:  어떤 테스트 프레임워크를 사용하든 테스트를 작성하세요! 작고 순수한 기능을 쓰도록 노력하고, 조작이 일어나는 곳을 최소화하세요. stubs과 mocks에 주의하세요 - 테스트를 더 다루기 힘들게 만들 수 있습니다. Airbnb에서는 mocha와 jest를 주로 사용합니다. tape도 때때로 작은 개별 모듈에 사용됩니다. 100% 테스트 적용 범위에 도달하는 것이 항상 실용적이지는 않지만, 좋은 목표입니다. 버그를 고칠 때마다 회귀 테스트 를 작성하세요. 회귀 테스트 없이 고쳐진 버그는 미래에 거의 분명히 문제를 다시 일으킵니다.    ⬆ back to top\n성능 (Performance) #   On Layout \u0026amp; Web Performance String vs Array Concat Try/Catch Cost In a Loop Bang Function jQuery Find vs Context, Selector innerHTML vs textContent for script text Long String Concatenation Are Javascript functions like map(), reduce(), and filter() optimized for traversing arrays? Loading\u0026hellip;  ⬆ back to top\n자료 (Resources) #  Learning ES6+\n Latest ECMA spec ExploringJS ES6 Compatibility Table Comprehensive Overview of ES6 Features  Read This\n Standard ECMA-262  Tools\n Code Style Linters  ESlint - Airbnb Style .eslintrc JSHint - Airbnb Style .jshintrc   Neutrino Preset - @neutrinojs/airbnb  Other Style Guides\n Google JavaScript Style Guide jQuery Core Style Guidelines Principles of Writing Consistent, Idiomatic JavaScript StandardJS  Other Styles\n Naming this in nested functions - Christian Johansen Conditional Callbacks - Ross Allen Popular JavaScript Coding Conventions on GitHub - JeongHoon Byun Multiple var statements in JavaScript, not superfluous - Ben Alman  Further Reading\n Understanding JavaScript Closures - Angus Croll Basic JavaScript for the impatient programmer - Dr. Axel Rauschmayer You Might Not Need jQuery - Zack Bloom \u0026amp; Adam Schwartz ES6 Features - Luke Hoban Frontend Guidelines - Benjamin De Cock  Books\n JavaScript: The Good Parts - Douglas Crockford JavaScript Patterns - Stoyan Stefanov Pro JavaScript Design Patterns - Ross Harmes and Dustin Diaz High Performance Web Sites: Essential Knowledge for Front-End Engineers - Steve Souders Maintainable JavaScript - Nicholas C. Zakas JavaScript Web Applications - Alex MacCaw Pro JavaScript Techniques - John Resig Smashing Node.js: JavaScript Everywhere - Guillermo Rauch Secrets of the JavaScript Ninja - John Resig and Bear Bibeault Human JavaScript - Henrik Joreteg Superhero.js - Kim Joar Bekkelund, Mads Mobæk, \u0026amp; Olav Bjorkoy JSBooks - Julien Bouquillon Third Party JavaScript - Ben Vinegar and Anton Kovalyov Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript - David Herman Eloquent JavaScript - Marijn Haverbeke You Don’t Know JS: ES6 \u0026amp; Beyond - Kyle Simpson  Blogs\n JavaScript Weekly JavaScript, JavaScript\u0026hellip; Bocoup Weblog Adequately Good NCZOnline Perfection Kills Ben Alman Dmitry Baranovskiy nettuts  Podcasts\n JavaScript Air JavaScript Jabber  ⬆ back to top\nIn the Wild #  아래 목록은 이 스타일 가이드를 사용하고 있는 단체들입니다. 우리에게 풀 리퀘스트를 보내면 리스트에 추가해드리겠습니다.\n 123erfasst: 123erfasst/javascript 3blades: 3Blades 4Catalyzer: 4Catalyzer/javascript Aan Zee: AanZee/javascript Adult Swim: adult-swim/javascript Airbnb: airbnb/javascript AltSchool: AltSchool/javascript Apartmint: apartmint/javascript Ascribe: ascribe/javascript Avalara: avalara/javascript Avant: avantcredit/javascript Axept: axept/javascript BashPros: BashPros/javascript Billabong: billabong/javascript Bisk: bisk Bonhomme: bonhommeparis/javascript Brainshark: brainshark/javascript CaseNine: CaseNine/javascript Cerner: Cerner Chartboost: ChartBoost/javascript-style-guide ComparaOnline: comparaonline/javascript Compass Learning: compasslearning/javascript-style-guide DailyMotion: dailymotion/javascript DoSomething: DoSomething/eslint-config Digitpaint digitpaint/javascript Drupal: www.drupal.org Ecosia: ecosia/javascript Evernote: evernote/javascript-style-guide Evolution Gaming: evolution-gaming/javascript EvozonJs: evozonjs/javascript ExactTarget: ExactTarget/javascript Expensify Expensify/Style-Guide Flexberry: Flexberry/javascript-style-guide Gawker Media: gawkermedia General Electric: GeneralElectric/javascript Generation Tux: GenerationTux/javascript GoodData: gooddata/gdc-js-style Grooveshark: grooveshark/javascript Grupo-Abraxas: Grupo-Abraxas/javascript Honey: honeyscience/javascript How About We: howaboutwe/javascript Huballin: huballin HubSpot: HubSpot/javascript Hyper: hyperoslo/javascript-playbook InterCity Group: intercitygroup/javascript-style-guide Jam3: Jam3/Javascript-Code-Conventions JeopardyBot: kesne/jeopardy-bot JSSolutions: JSSolutions/javascript Kaplan Komputing: kaplankomputing/javascript KickorStick: kickorstick Kinetica Solutions: kinetica/javascript LEINWAND: LEINWAND/javascript Lonely Planet: lonelyplanet/javascript M2GEN: M2GEN/javascript Mighty Spring: mightyspring/javascript MinnPost: MinnPost/javascript MitocGroup: MitocGroup/javascript ModCloth: modcloth/javascript Money Advice Service: moneyadviceservice/javascript Muber: muber National Geographic: natgeo Nimbl3: nimbl3/javascript Nulogy: nulogy/javascript Orange Hill Development: orangehill/javascript Orion Health: orionhealth/javascript OutBoxSoft: OutBoxSoft/javascript Peerby: Peerby/javascript Pier 1: Pier1/javascript Qotto: Qotto/javascript-style-guide Razorfish: razorfish/javascript-style-guide reddit: reddit/styleguide/javascript React: facebook.github.io/react/contributing/how-to-contribute.html#style-guide REI: reidev/js-style-guide Ripple: ripple/javascript-style-guide Sainsbury\u0026rsquo;s Supermarkets: jsainsburyplc SeekingAlpha: seekingalpha/javascript-style-guide Shutterfly: shutterfly/javascript Sourcetoad: sourcetoad/javascript Springload: springload StratoDem Analytics: stratodem/javascript SteelKiwi Development: steelkiwi/javascript StudentSphere: studentsphere/javascript SwoopApp: swoopapp/javascript SysGarage: sysgarage/javascript-style-guide Syzygy Warsaw: syzygypl/javascript Target: target/javascript TheLadders: TheLadders/javascript The Nerdery: thenerdery/javascript-standards T4R Technology: T4R-Technology/javascript UrbanSim: urbansim VoxFeed: VoxFeed/javascript-style-guide WeBox Studio: weboxstudio/javascript Weggo: Weggo/javascript Zillow: zillow/javascript ZocDoc: ZocDoc/javascript  ⬆ back to top\nTranslation #  이 스타일 가이드는 다른 언어로도 제공됩니다:\n Brazilian Portuguese: armoucar/javascript-style-guide Bulgarian: borislavvv/javascript Catalan: fpmweb/javascript-style-guide Chinese (Simplified): yuche/javascript Chinese (Traditional): jigsawye/javascript French: nmussy/javascript-style-guide German: timofurrer/javascript-style-guide Italian: sinkswim/javascript-style-guide Japanese: mitsuruog/javascript-style-guide Korean: ParkSB/javascript-style-guide Russian: leonidlebedev/javascript-airbnb Spanish: paolocarrasco/javascript-style-guide Thai: lvarayut/javascript-style-guide Turkish: eraycetinay/javascript Ukrainian: ivanzusko/javascript Vietnam: hngiang/javascript-style-guide  The JavaScript Style Guide Guide #   Reference  Chat With Us About JavaScript #   Find us on gitter.  Contributors #   View Contributors  License #  (The MIT License)\nCopyright (c) 2012 Airbnb\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u0026lsquo;Software\u0026rsquo;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \u0026lsquo;AS IS\u0026rsquo;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n⬆ back to top\nAmendments #  우리는 당신이 이 가이드를 포크해서 당신의 팀에 알맞도록 고쳐 쓰기를 바랍니다. 아래에 스타일 가이드의 수정 사항을 나열하세요. 이렇게 하면 병합 충돌(marge conflicts)을 신경쓰지 않고 스타일 가이드를 정기적으로 업데이트 할 수 있습니다.\n}; #  "});index.add({'id':3,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/01-psr-1/','title':"01 P S R 1",'section':"Php",'content':"PSR-1 기본 코딩 표준 #  이 섹션은 공유되는 PHP 코드 간의 높은 수준의 기술적 상호 호환성을 보장하는 데 필요한 표준 코딩 사항으로 간주되어야 하는 것을 포함합니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n1. 개요 #    반드시(MUST) \u0026lt;?php 와 \u0026lt;?= 태그만을 사용해야 합니다.\n  반드시(MUST) BOM이 없는 UTF-8로만 PHP코드를 작성해야 합니다.\n  각 파일은 무언가를 선언하거나 (클래스, 함수, 상수 등) 또는 사이드이펙트의 원인이 되는(예 : 출력 생성, .ini 설정 변경 등) 형태로 작성해야하지만(SHOULD) 둘 모두를 수행하면 안됩니다(SHOULD NOT).\n  네임스페이스와 클래스는 반드시(MUST) \u0026ldquo;autoloading\u0026quot;에 관한 PSR: [PSR-0, PSR-4]을 따라 작성해야 합니다.\n  Class 는 반드시(MUST) StudlyCaps에 따라 작성해야합니다. 역자주: StudlyCaps 라는것은 단어의 첫글자가 대문자인 규칙을 말합니다. ex: DefaultClass\n  Class의 상수(constants)는 반드시(MUST) 전부 대문자와 밑줄_만으로 작성해야합니다.\n  Method는 반드시(MUST) camelCase로 작성해야합니다.\n  2. 파일 #  2.1. PHP Tags #  PHP 코드는 반드시(MUST) 긴 \u0026lt;?php ?\u0026gt; 태그나 짧은 \u0026lt;?= ?\u0026gt; 태그를 사용해야합니다 그외의 태그를 사용해서는 안됩니다 (MUST NOT).\n2.2. Character Encoding #  PHP 코드는 반드시(MUST) BOM이 없는 UTF-8 문자열만 사용해야합니다\n2.3. 사이드이펙트 #  각 파일은 새로운 무언가 (클래스, 함수, 상수 등)를 선언하고 다른 사이드이펙트를 일으키지 않거나, 사이드이펙트가 있는 로직를 실행하지만(SHOULD) 둘 다 수행하면 안됩니다(SHOULD NOT).\n\u0026ldquo;사이드이펙트\u0026quot;는 클래스, 함수, 상수 등을 선언하는 것과 직접적으로 관련이없는 논리를 파일에 단순히 포함하는 것부터 실행하는 것 전부를 의미합니다. 역자주: 일반적으로 프로그래밍에서 사용되는 사이드이펙트의 의미와 이 문장에서 사용되는 사이드이펙트의 의미는 약간의 차이가 있습니다\n\u0026ldquo;사이드이펙트\u0026quot;에는 Output 생성, 명시적인 \u0026ldquo;require\u0026quot;또는 \u0026ldquo;include\u0026quot;의 사용, 외부 서비스 연결, ini 설정 변경, 오류 또는 예외 발생, 전역 변수 또는 정적 변수 변경, 파일의 읽기 또는 쓰기 등이 있습니다.\n다음은 선언과 사이드이펙트가 모두 포함 된 파일의 예입니다.\n예제:\n\u0026lt;?php // side effect: change ini settings ini_set(\u0026#39;error_reporting\u0026#39;, E_ALL); // side effect: loads a file include \u0026#34;file.php\u0026#34;; // side effect: generates output echo \u0026#34;\u0026lt;html\u0026gt;\\n\u0026#34;; // declaration function foo() { // function body } 다음 예제는 사이드이펙트가 없이 작성된 파일입니다.\n예제:\n\u0026lt;?php // declaration function foo() { // function body } // conditional declaration is *not* a side effect if (! function_exists(\u0026#39;bar\u0026#39;)) { function bar() { // function body  } } 3. Namespace 와 Class #  네임 스페이스와 Class는 반드시(MUST) [자동 로딩 (autoloading)] PSR [PSR-0, PSR-4]을 따라야합니다.\n이것은 클래스가 각각의 개별 파일에 작성되어있으며, 공급자(vendor)의 이름으로 시작하는 네임스페이스를 사용했다는 것을 의미합니다.\n클래스 이름은 반드시(MUST) StudlyCaps 규칙으로 작성되어야 합니다.\nPHP 5.3 및 이후 버전 용으로 작성된 코드는 정식 네임 스페이스를 사용해야합니다.\n예제:\n\u0026lt;?php // PHP 5.3 and later: namespace Vendor\\Model; class Foo { } 5.2.x 용으로 작성된 코드에서 네임 스페이스와 유사한 규칙을 사용하기 위해 클래스 이름에 Vendor_ 접두어를 붙입니다(SHOULD).\n\u0026lt;?php // PHP 5.2.x and earlier: class Vendor_Model_Foo { } 4. Class의 상수(Constants), Properties, Methods #  \u0026ldquo;Class\u0026quot;라는 용어는 모든 Class, Interface 및 Trait을 의미합니다.\n4.1. 상수(Constants) #  클래스 상수는 모두 대문자 또는 밑줄_로 선언해야합니다 (MUST).\n예제:\n\u0026lt;?php namespace Vendor\\Model; class Foo { const VERSION = \u0026#39;1.0\u0026#39;; const DATE_APPROVED = \u0026#39;2012-06-01\u0026#39;; } 4.2. Properties #  이 가이드는 의도적으로 $StudlyCaps , $camelCase 또는 $under_score 같은 형태로 property 이름을 권장하는 것을 피하고 있습니다.\nProperties는 어떤 규칙이 사용 되든 상관없지만 합리적인 범위 내에서 일관되게 적용되어야 합니다(SHOULD). 이 범위는 공급자 수준(vendor-level), 패키지 수준(package-level), Class 수준(class-level) 또는 Method(method-level) 수준 일 수 있습니다.\n4.3. Methods #  Method의 이름은 반드시(MUST) camelCase로 작성해야 합니다.\n"});index.add({'id':4,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/02-psr-3/','title':"02 P S R 3",'section':"Php",'content':"로거 인터페이스 #  이 문서는 로깅 라이브러리에 대한 공통 인터페이스를 설명합니다.\n가장 중요한 목표는 라이브러리가 Psr\\Log\\LoggerInterface 객체를 받아서 간단하고 보편적인 방법으로 로그를 쓸 수있게하는 것입니다. 커스텀 할 필요가 있는 프레임워크와 CMS는 자체적인 목적을 위해 인터페이스를 확장 할 수 있지만 이 문서와 호환 가능해야합니다 (SHOULD). 이렇게하면 프로그램에서 사용하는 타사 라이브러리가 프로그램의 중앙 집중식 로그에 쓸 수 있습니다. 역자주: 타 벤더의 로그를 중앙집중형으로 모아서 남길 수 있다는 의미\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n이 문서에서 구현자(implementor) 라는 단어는 로그 관련 라이브러리 또는 프레임워크에서 LoggerInterface 를 구현하는 누군가로 해석되어야합니다. 로거 사용자는 사용자(user)라고합니다.\n1. 명세서 #  1.1 기본 #    LoggerInterface는 로그를 8 개의 RFC 5424 레벨 (debug, info, notice, warning, error, critical, alert, emergency)에 맞게 쓸 수 있는 8 가지 method를 제공해야 합니다.\n  9 번째 method 인log는 첫 번째 인자로 로그 수준(level)을 입력받습니다. 로그 수준 상수 중 하나를 사용하여 이 메서드를 호출하면 수준별 메서드를 호출 할 때와 동일한 결과를 가져야합니다. 알지 못하는 수준(level)이거나 이 스펙에 정의되지 않은 수준(level)로 이 메소드를 호출하면 반드시 Psr\\Log\\InvalidArgumentException 을 던져야합니다 (MUST). 사용자는 현재 구현이 이를 지원하는지 모른 채 사용자 지정 수준(level)을 사용해서는 안됩니다(SHOULD NOT).\n  1.2 메세지 #    모든 method는 문자열을 메시지로 받거나 __toString () method를 가진 객체를 받아들입니다. 구현자는 전달 된 객체를 특별한 형태로 처리 할 수도있다 (MAY). 그렇지 않은 경우, 구현자는 그것을 문자열로 변환해야한다 (MUST).\n  메시지는 구현자가 문맥 배열의 값으로 대체 할 수 있는(MAY) Placeholder를 포함 할 수있습니다(MAY). Placeholder 이름은 컨텍스트 배열의 키와 일치해야합니다. Placeholder 이름은 하나의 여는 중괄호 { 와 하나의 닫는 중괄호 }로 구분해야합니다. 구분 기호와 Placeholder 이름 사이에 공백이 없어야합니다 (MUST NOT). Placeholder 이름은 A-Z, a-z, 0-9, 밑줄 _ 및 마침표 . 만으로 구성되어야합니다 (SHOULD). 다른 문자의 사용은 Placeholder 사양(specification)의 향후 수정을 위해 예약됩니다. 구현자는 Placeholder를 사용하여 다양한 이스케이프 전략을 구현하고 표시를 위해 로그를 변환 할 수 있습니다 (MAY). 사용자는 데이터가 표시 될 컨텍스트를 알 수 없으므로 Placeholder 값을 미리 이스케이프해서는 안됩니다.\n   다음은 참조용으로만 제공되는 Placeholder 보간법의 구현 예입니다.\n\u0026lt;?php /** * Interpolates context values into the message placeholders. */ function interpolate($message, array $context = array()) { // build a replacement array with braces around the context keys  $replace = array(); foreach ($context as $key =\u0026gt; $val) { // check that the value can be casted to string  if (!is_array($val) \u0026amp;\u0026amp; (!is_object($val) || method_exists($val, \u0026#39;__toString\u0026#39;))) { $replace[\u0026#39;{\u0026#39; . $key . \u0026#39;}\u0026#39;] = $val; } } // interpolate replacement values into the message and return  return strtr($message, $replace); } // a message with brace-delimited placeholder names $message = \u0026#34;User {username} created\u0026#34;; // a context array of placeholder names =\u0026gt; replacement values $context = array(\u0026#39;username\u0026#39; =\u0026gt; \u0026#39;bolivar\u0026#39;); // echoes \u0026#34;User bolivar created\u0026#34; echo interpolate($message, $context); 1.3 문맥(Context) #    모든 메소드는 배열을 컨텍스트 데이터로 허용합니다. 이것은 문자열에 잘 맞지 않는 불필요한 정보를 보유하기위한 것입니다. 배열은 무엇이든 포함 할 수 있습니다. 구현자는 가능한 한 많은 관용으로 컨텍스트 데이터를 처리해야합니다 (MUST). 문맥에서 주어진 값은 예외를 던지거나 PHP error, warning 또는 notice를 발생시켜서는 안됩니다(MUST NOT).\n  Exception 객체가 컨텍스트 데이터에 전달되면, 그것은 'exception' 키에 있어야합니다 (MUST). 로깅 예외(exceptios)는 일반적인 패턴이며, 이로 인해 구현자가 로그 백엔드가 지원할 때 예외에서 스택 추적을 추출 할 수 있습니다. 구현자들은 무엇이든 포함 할 수 있기 때문에'exception' 키가 실제로 그것을 사용하기 전에 실제로 Exception 인지를 반드시 확인해야합니다 (MUST).\n  1.4 헬퍼 클래스와 인터페이스 #    Psr\\Log\\AbstractLogger Class를 확장하고 일반적인 log 메소드를 구현함으로써 LoggerInterface를 매우 쉽게 구현할 수있게합니다. 다른 8 가지 method는 메시지와 컨텍스트를 전달하는 것입니다.\n  마찬가지로 Psr\\Log\\LoggerTrait 만 사용하면 일반적으로 log 메소드를 구현해야합니다. 이 trait은 인터페이스를 구현하지 않으므로 이 경우에는 여전히 LoggerInterface를 구현해야합니다.\n  Psr\\Log\\NullLogger는 인터페이스와 함께 제공됩니다. 로거가 제공되지 않으면 폴백 (back-back) \u0026ldquo;블랙홀\u0026quot;구현을 제공하기 위해 인터페이스 사용자가 이를 사용할 수 있습니다 (MAY). 그러나 컨텍스트 데이터 작성 비용면에서 조건부 로깅이 더 나은 접근 방법 일 수 있습니다. 역자주: 아무것도 저장하지 않는 로거를 사용하는 것 보다 경우에 따라 로거를 호출 하도록 하는 편이 더 효율적\n  Psr\\Log\\LoggerAwareInterface 는 setLogger(LoggerInterface $logger) method만을 포함하고 있으며, 임의의 인스턴스를 로거로 자동으로 연결하기 위해 프레임워크에서 사용할 수 있습니다.\n  Psr\\Log\\LoggerAwareTrait trait은 모든 클래스에서 쉽게 동일한 인터페이스를 구현하는 데 사용할 수 있습니다. $this-\u0026gt;logger에 접근 할 수 있습니다.\n  Psr\\Log\\LogLevel 클래스는 8 개의 로그 레벨에 대한 상수를 가지고 있습니다.\n  2. Package #  설명한 인터페이스와 클래스는 물론 관련 예외 클래스 및 구현을 확인하는 테스트가 psr/log 패키지의 일부로 제공됩니다.\n3. Psr\\Log\\LoggerInterface #  \u0026lt;?php namespace Psr\\Log; /** * Describes a logger instance. * * The message MUST be a string or object implementing __toString(). * * The message MAY contain placeholders in the form: {foo} where foo * will be replaced by the context data in key \u0026#34;foo\u0026#34;. * * The context array can contain arbitrary data, the only assumption that * can be made by implementors is that if an Exception instance is given * to produce a stack trace, it MUST be in a key named \u0026#34;exception\u0026#34;. * * See https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md * for the full interface specification. */ interface LoggerInterface { /** * System is unusable. * * @param string $message * @param array $context * @return void */ public function emergency($message, array $context = array()); /** * Action must be taken immediately. * * Example: Entire website down, database unavailable, etc. This should * trigger the SMS alerts and wake you up. * * @param string $message * @param array $context * @return void */ public function alert($message, array $context = array()); /** * Critical conditions. * * Example: Application component unavailable, unexpected exception. * * @param string $message * @param array $context * @return void */ public function critical($message, array $context = array()); /** * Runtime errors that do not require immediate action but should typically * be logged and monitored. * * @param string $message * @param array $context * @return void */ public function error($message, array $context = array()); /** * Exceptional occurrences that are not errors. * * Example: Use of deprecated APIs, poor use of an API, undesirable things * that are not necessarily wrong. * * @param string $message * @param array $context * @return void */ public function warning($message, array $context = array()); /** * Normal but significant events. * * @param string $message * @param array $context * @return void */ public function notice($message, array $context = array()); /** * Interesting events. * * Example: User logs in, SQL logs. * * @param string $message * @param array $context * @return void */ public function info($message, array $context = array()); /** * Detailed debug information. * * @param string $message * @param array $context * @return void */ public function debug($message, array $context = array()); /** * Logs with an arbitrary level. * * @param mixed $level * @param string $message * @param array $context * @return void */ public function log($level, $message, array $context = array()); } 4. Psr\\Log\\LoggerAwareInterface #  \u0026lt;?php namespace Psr\\Log; /** * Describes a logger-aware instance. */ interface LoggerAwareInterface { /** * Sets a logger instance on the object. * * @param LoggerInterface $logger * @return void */ public function setLogger(LoggerInterface $logger); } 5. Psr\\Log\\LogLevel #  \u0026lt;?php namespace Psr\\Log; /** * Describes log levels. */ class LogLevel { const EMERGENCY = \u0026#39;emergency\u0026#39;; const ALERT = \u0026#39;alert\u0026#39;; const CRITICAL = \u0026#39;critical\u0026#39;; const ERROR = \u0026#39;error\u0026#39;; const WARNING = \u0026#39;warning\u0026#39;; const NOTICE = \u0026#39;notice\u0026#39;; const INFO = \u0026#39;info\u0026#39;; const DEBUG = \u0026#39;debug\u0026#39;; } "});index.add({'id':5,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/03-psr-4/','title':"03 P S R 4",'section':"Php",'content':"PSR-4의 구현 예 #  다음 예는 PSR-4에 호환하는 코드입니다.\n역자주: 사실상 오토로더는 컴포저로 대동단결 되었기 때문에 직접 구현하시기 보다는 컴포저를 사용하시는 것을 추천합니다\nClosure 예제 #  \u0026lt;?php /** * An example of a project-specific implementation. * * After registering this autoload function with SPL, the following line * would cause the function to attempt to load the \\Foo\\Bar\\Baz\\Qux class * from /path/to/project/src/Baz/Qux.php: * * new \\Foo\\Bar\\Baz\\Qux; * * @param string $class The fully-qualified class name. * @return void */ spl_autoload_register(function ($class) { // project-specific namespace prefix  $prefix = \u0026#39;Foo\\\\Bar\\\\\u0026#39;; // base directory for the namespace prefix  $base_dir = __DIR__ . \u0026#39;/src/\u0026#39;; // does the class use the namespace prefix?  $len = strlen($prefix); if (strncmp($prefix, $class, $len) !== 0) { // no, move to the next registered autoloader  return; } // get the relative class name  $relative_class = substr($class, $len); // replace the namespace prefix with the base directory, replace namespace  // separators with directory separators in the relative class name, append  // with .php  $file = $base_dir . str_replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;, $relative_class) . \u0026#39;.php\u0026#39;; // if the file exists, require it  if (file_exists($file)) { require $file; } }); Class 예제 #  다음은 네임스페이스를 활용하여 여러 클래스를 처리하기위한 클래스 구현의 예제입니다.\n\u0026lt;?php namespace Example; /** * An example of a general-purpose implementation that includes the optional * functionality of allowing multiple base directories for a single namespace * prefix. * * Given a foo-bar package of classes in the file system at the following * paths ... * * /path/to/packages/foo-bar/ * src/ * Baz.php # Foo\\Bar\\Baz * Qux/ * Quux.php # Foo\\Bar\\Qux\\Quux * tests/ * BazTest.php # Foo\\Bar\\BazTest * Qux/ * QuuxTest.php # Foo\\Bar\\Qux\\QuuxTest * * ... add the path to the class files for the \\Foo\\Bar\\ namespace prefix * as follows: * * \u0026lt;?php * // instantiate the loader * $loader = new \\Example\\Psr4AutoloaderClass; * * // register the autoloader * $loader-\u0026gt;register(); * * // register the base directories for the namespace prefix * $loader-\u0026gt;addNamespace(\u0026#39;Foo\\Bar\u0026#39;, \u0026#39;/path/to/packages/foo-bar/src\u0026#39;); * $loader-\u0026gt;addNamespace(\u0026#39;Foo\\Bar\u0026#39;, \u0026#39;/path/to/packages/foo-bar/tests\u0026#39;); * * The following line would cause the autoloader to attempt to load the * \\Foo\\Bar\\Qux\\Quux class from /path/to/packages/foo-bar/src/Qux/Quux.php: * * \u0026lt;?php * new \\Foo\\Bar\\Qux\\Quux; * * The following line would cause the autoloader to attempt to load the * \\Foo\\Bar\\Qux\\QuuxTest class from /path/to/packages/foo-bar/tests/Qux/QuuxTest.php: * * \u0026lt;?php * new \\Foo\\Bar\\Qux\\QuuxTest; */ class Psr4AutoloaderClass { /** * An associative array where the key is a namespace prefix and the value * is an array of base directories for classes in that namespace. * * @var array */ protected $prefixes = array(); /** * Register loader with SPL autoloader stack. * * @return void */ public function register() { spl_autoload_register(array($this, \u0026#39;loadClass\u0026#39;)); } /** * Adds a base directory for a namespace prefix. * * @param string $prefix The namespace prefix. * @param string $base_dir A base directory for class files in the * namespace. * @param bool $prepend If true, prepend the base directory to the stack * instead of appending it; this causes it to be searched first rather * than last. * @return void */ public function addNamespace($prefix, $base_dir, $prepend = false) { // normalize namespace prefix  $prefix = trim($prefix, \u0026#39;\\\\\u0026#39;) . \u0026#39;\\\\\u0026#39;; // normalize the base directory with a trailing separator  $base_dir = rtrim($base_dir, DIRECTORY_SEPARATOR) . \u0026#39;/\u0026#39;; // initialize the namespace prefix array  if (isset($this-\u0026gt;prefixes[$prefix]) === false) { $this-\u0026gt;prefixes[$prefix] = array(); } // retain the base directory for the namespace prefix  if ($prepend) { array_unshift($this-\u0026gt;prefixes[$prefix], $base_dir); } else { array_push($this-\u0026gt;prefixes[$prefix], $base_dir); } } /** * Loads the class file for a given class name. * * @param string $class The fully-qualified class name. * @return mixed The mapped file name on success, or boolean false on * failure. */ public function loadClass($class) { // the current namespace prefix  $prefix = $class; // work backwards through the namespace names of the fully-qualified  // class name to find a mapped file name  while (false !== $pos = strrpos($prefix, \u0026#39;\\\\\u0026#39;)) { // retain the trailing namespace separator in the prefix  $prefix = substr($class, 0, $pos + 1); // the rest is the relative class name  $relative_class = substr($class, $pos + 1); // try to load a mapped file for the prefix and relative class  $mapped_file = $this-\u0026gt;loadMappedFile($prefix, $relative_class); if ($mapped_file) { return $mapped_file; } // remove the trailing namespace separator for the next iteration  // of strrpos()  $prefix = rtrim($prefix, \u0026#39;\\\\\u0026#39;); } // never found a mapped file  return false; } /** * Load the mapped file for a namespace prefix and relative class. * * @param string $prefix The namespace prefix. * @param string $relative_class The relative class name. * @return mixed Boolean false if no mapped file can be loaded, or the * name of the mapped file that was loaded. */ protected function loadMappedFile($prefix, $relative_class) { // are there any base directories for this namespace prefix?  if (isset($this-\u0026gt;prefixes[$prefix]) === false) { return false; } // look through base directories for this namespace prefix  foreach ($this-\u0026gt;prefixes[$prefix] as $base_dir) { // replace the namespace prefix with the base directory,  // replace namespace separators with directory separators  // in the relative class name, append with .php  $file = $base_dir . str_replace(\u0026#39;\\\\\u0026#39;, \u0026#39;/\u0026#39;, $relative_class) . \u0026#39;.php\u0026#39;; // if the mapped file exists, require it  if ($this-\u0026gt;requireFile($file)) { // yes, we\u0026#39;re done  return $file; } } // never found it  return false; } /** * If a file exists, require it from the file system. * * @param string $file The file to require. * @return bool True if the file exists, false if not. */ protected function requireFile($file) { if (file_exists($file)) { require $file; return true; } return false; } } Unit Tests #  다음 예제는 위의 클래스 로더를 단위 테스트하는 방법의 한 가지입니다.\n\u0026lt;?php namespace Example\\Tests; class MockPsr4AutoloaderClass extends Psr4AutoloaderClass { protected $files = array(); public function setFiles(array $files) { $this-\u0026gt;files = $files; } protected function requireFile($file) { return in_array($file, $this-\u0026gt;files); } } class Psr4AutoloaderClassTest extends \\PHPUnit_Framework_TestCase { protected $loader; protected function setUp() { $this-\u0026gt;loader = new MockPsr4AutoloaderClass; $this-\u0026gt;loader-\u0026gt;setFiles(array( \u0026#39;/vendor/foo.bar/src/ClassName.php\u0026#39;, \u0026#39;/vendor/foo.bar/src/DoomClassName.php\u0026#39;, \u0026#39;/vendor/foo.bar/tests/ClassNameTest.php\u0026#39;, \u0026#39;/vendor/foo.bardoom/src/ClassName.php\u0026#39;, \u0026#39;/vendor/foo.bar.baz.dib/src/ClassName.php\u0026#39;, \u0026#39;/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php\u0026#39;, )); $this-\u0026gt;loader-\u0026gt;addNamespace( \u0026#39;Foo\\Bar\u0026#39;, \u0026#39;/vendor/foo.bar/src\u0026#39; ); $this-\u0026gt;loader-\u0026gt;addNamespace( \u0026#39;Foo\\Bar\u0026#39;, \u0026#39;/vendor/foo.bar/tests\u0026#39; ); $this-\u0026gt;loader-\u0026gt;addNamespace( \u0026#39;Foo\\BarDoom\u0026#39;, \u0026#39;/vendor/foo.bardoom/src\u0026#39; ); $this-\u0026gt;loader-\u0026gt;addNamespace( \u0026#39;Foo\\Bar\\Baz\\Dib\u0026#39;, \u0026#39;/vendor/foo.bar.baz.dib/src\u0026#39; ); $this-\u0026gt;loader-\u0026gt;addNamespace( \u0026#39;Foo\\Bar\\Baz\\Dib\\Zim\\Gir\u0026#39;, \u0026#39;/vendor/foo.bar.baz.dib.zim.gir/src\u0026#39; ); } public function testExistingFile() { $actual = $this-\u0026gt;loader-\u0026gt;loadClass(\u0026#39;Foo\\Bar\\ClassName\u0026#39;); $expect = \u0026#39;/vendor/foo.bar/src/ClassName.php\u0026#39;; $this-\u0026gt;assertSame($expect, $actual); $actual = $this-\u0026gt;loader-\u0026gt;loadClass(\u0026#39;Foo\\Bar\\ClassNameTest\u0026#39;); $expect = \u0026#39;/vendor/foo.bar/tests/ClassNameTest.php\u0026#39;; $this-\u0026gt;assertSame($expect, $actual); } public function testMissingFile() { $actual = $this-\u0026gt;loader-\u0026gt;loadClass(\u0026#39;No_Vendor\\No_Package\\NoClass\u0026#39;); $this-\u0026gt;assertFalse($actual); } public function testDeepFile() { $actual = $this-\u0026gt;loader-\u0026gt;loadClass(\u0026#39;Foo\\Bar\\Baz\\Dib\\Zim\\Gir\\ClassName\u0026#39;); $expect = \u0026#39;/vendor/foo.bar.baz.dib.zim.gir/src/ClassName.php\u0026#39;; $this-\u0026gt;assertSame($expect, $actual); } public function testConfusion() { $actual = $this-\u0026gt;loader-\u0026gt;loadClass(\u0026#39;Foo\\Bar\\DoomClassName\u0026#39;); $expect = \u0026#39;/vendor/foo.bar/src/DoomClassName.php\u0026#39;; $this-\u0026gt;assertSame($expect, $actual); $actual = $this-\u0026gt;loader-\u0026gt;loadClass(\u0026#39;Foo\\BarDoom\\ClassName\u0026#39;); $expect = \u0026#39;/vendor/foo.bardoom/src/ClassName.php\u0026#39;; $this-\u0026gt;assertSame($expect, $actual); } } "});index.add({'id':6,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/04-psr-4/','title':"04 P S R 4",'section':"Php",'content':"PSR-4 Autoloader #  이 단어들 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n1. 개요 #  이 PSR은 Class autoloading 에서 파일 경로에 대한 사양(specification)을 설명합니다. 이 PSR은 완벽하게 상호 운용이 가능하며 PSR-0을 포함한 다른 오토로딩 사양과 함께 사용할 수 있습니다. 또한 이 PSR은 사양에 따라 오토로드되는 파일을 저장할 위치를 설명합니다.\n2. 명세서 #    \u0026ldquo;Class\u0026quot;라는 용어는 Class, Interface, Trait 등의 기타 유사한 구조를 말합니다.\n  정규화 된 클래스 이름의 형식은 다음과 같습니다.\n \\\u0026lt;NamespaceName\u0026gt;(\\\u0026lt;SubNamespaceNames\u0026gt;)*\\\u0026lt;ClassName\u0026gt;    정규화 된 Class 이름은 \u0026ldquo;공급자 네임스페이스\u0026quot;라고도하는 최상위 네임스페이스를 가져야만 합니다(MUST).\n  정규화 된 Class 이름은 하나 이상의 하위 네임스페이스를 가질 수 있습니다 (MAY).\n  정규화된 Class 이름은 마지막 클래스 이름(terminating class name)을 가져야합니다 (MUST). 역자주: 좀 더 좋은 의미의 표현을 찾지 못하였습니다\n  밑줄은 정규화 된 클래스 이름의 어느 부분에도 특별한 의미가 없습니다.\n  정규화 된 클래스 이름의 알파벳 문자는 대소문자의 조합 일 수 있습니다 (MAY).\n  모든 클래스 이름은 대소문자를 구분하여 참조해야합니다 (MUST).\n    정규화 된 클래스 이름에 해당하는 파일을 로드 할 때 \u0026hellip;\n  정규화 된 클래스 이름에서 최초의 네임스페이스 구분 기호를 제외하고 연속된 하나 이상의 상위 네임스페이스와 하위 네임스페이스로 구성된 ( \u0026ldquo;네임스페이스 접두사\u0026rdquo;)는 적어도 하나의 \u0026ldquo;기본 디렉토리\u0026quot;에 대응합니다. 역자주: 표현을 더 다듬어야 할 듯 하지만 네임스페이스의 조합은 하나의 디렉토리와 매치가 된다는 의미로 이해하시면 될 것 같습니다\n  \u0026ldquo;네임스페이스 접두사\u0026rdquo; 다음의 이어지는 하위 네임스페이스 이름은 \u0026ldquo;기본 디렉토리\u0026rdquo; 내의 하위 디렉토리에 해당하며 네임스페이스 구분 기호는 디렉토리 구분 기호를 나타냅니다. 하위 디렉토리 이름은 하위 네임스페이스 이름의 대소문자와 일치해야합니다.\n  마지막에 존재하는 Class 이름은 .php 로 끝나는 파일 이름과 같아야 합니다. 역자주: \\Vendor\\Packages\\Class =\u0026gt; Class.php 파일 이름은 Class 이름의 대소문자와 일치해야합니다(MUST).\n    오토로더 구현체는 예외(exception)를 throw해서는 안되며(MUST NOT), 모든 레벨의 오류를 발생해서는 안되며(MUST NOT), 값을 반환해서는 안됩니다 (SHOULD NOT).\n  3. 예제 #  아래의 표는 주어진 정규화 된 Class 이름, 네임스페이스 접두사 및 기본 디렉토리에 해당하는 파일 경로를 보여줍니다.\n   정규화된 Class 이름 Namespace 접두사 기본 디렉토리 결과 파일 경로     \\Acme\\Log\\Writer\\File_Writer Acme\\Log\\Writer ./acme-log-writer/lib/ ./acme-log-writer/lib/File_Writer.php   \\Aura\\Web\\Response\\Status Aura\\Web /path/to/aura-web/src/ /path/to/aura-web/src/Response/Status.php   \\Symfony\\Core\\Request Symfony\\Core ./vendor/Symfony/Core/ ./vendor/Symfony/Core/Request.php   \\Zend\\Acl Zend /usr/includes/Zend/ /usr/includes/Zend/Acl.php    명세를 따르는 Autoloader의 구현 예제는 examples file을 참조하십시오. 예제 구현체는 명세(specification)의 일부로 간주되어서는 안되며(MUST NOT) 언제든지 변경 될 수 있습니다.\n"});index.add({'id':7,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/05-psr-6/','title':"05 P S R 6",'section':"Php",'content':"Caching Interface #  캐싱은 모든 프로젝트의 성능을 향상시키는 일반적인 방법이며, 많은 프레임워크 및 라이브러리는 캐싱 라이브러리를 기본 기능 중 하나로 만들게 됩니다. 이로 인해 많은 라이브러리가 다양한 수준의 기능을 갖춘 자체 캐싱 라이브러리를 사용하게 되었습니다. 이러한 상황으로 인해 개발자는 필요한 기능을 제공 할 수도 있고 제공하지 못할 수도 있는 여러 시스템을 배워야합니다. 또한 라이브러리를 캐싱하는 개발자는 제한된 수의 프레임워크 만 지원하거나 많은 수의 어댑터 클래스를 만드는 것 중에서 선택해야합니다.\n캐싱 시스템을 위한 공통 인터페이스는 이러한 문제를 해결할 것 입니다. 라이브러리 및 프레임워크 개발자는 의도한대로 동작하는 캐싱 시스템에 의존 할 수 있습니다. 캐싱 시스템의 개발자는 전체 어댑터 모음보다는 단일 인터페이스 세트 만 구현하면됩니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n목표 #  이 PSR의 목표는 개발자가 빈틈없는 캐시 라이브러리를 만들 수 있도록 하여 맞춤 개발이 필요없이 기존 프레임 워크와 시스템에 통합 될 수 있도록 하는 것입니다.\n정의 #    호출 라이브러리(Calling Library) - 실제로 캐시 서비스가 필요한 라이브러리 또는 코드. 이 라이브러리는이 표준의 인터페이스를 구현하는 캐싱 서비스를 활용할 것이며, 그렇지 않으면 이러한 캐싱 서비스의 구현에 대한 알지 못합니다. 역자주: 인터페이스를 구현한 캐싱 서비스를 사용만하고 구현을 하지 않는다.\n  구현 라이브러리(Implementing Library) - 이 라이브러리는 모든 호출 라이브러리에 캐싱 서비스를 제공하기 위해이 표준을 구현합니다. 구현 라이브러리는 Cache\\CacheItemPoolInterface 및 Cache\\CacheItemInterface 인터페이스를 구현하는 클래스를 제공해야합니다. 라이브러리 구현은 전체 초 단위로 아래에 설명 된 최소 TTL 기능을 지원해야만 합니다 (MUST).\n  TTL - TTL (Time To Live)은 해당 항목이 저장하고 보관하는 것으로 간주되는 시간입니다. TTL은 일반적으로 초 단위의 시간을 나타내는 정수 또는 DateInterval 개체로 정의됩니다.\n  만료(Expiration) - 항목이 만료로 설정되는 실제 시간입니다. 이것은 일반적으로 개체가 저장된 시간에 TTL을 추가하여 계산됩니다. 이것은 일반적으로 개체가 저장된 시간에 TTL을 추가하여 계산되지만 DateTime 개체로 명시 적으로 설정할 수도 있습니다. 1:30:00에 저장된 300 초 TTL을 가진 항목의 만료 시간은 1:35:00입니다. 구현 라이브러리는 요청한 만료 시간 전에 항목을 만료시킬 수도 있지만(MAY) 만료 시간에 도달하면 만료 된 것으로 간주해야합니다(MUST). 호출 라이브러리가 항목을 저장요청을 하지만 만료 시간을 지정하지 않거나 만료 시간 또는 TTL을 null로 지정되어 있다면 구현 라이브러리는 설정한 기본 기간을 사용할 수 있습니다 (MAY). 기본 기간이 설정되지 않은 경우 구현 라이브러리는 해당 항목을 영원히 캐시하는 요청으로 해석하거나 기본 구현이 지원하는 동안 저장하는 것으로 해석해야합니다(MUST).\n  Key - 캐시 된 항목을 고유하게 식별하는 적어도 하나의 문자로 구성된 문자열입니다. 구현 라이브러리는A-Z,a-z,0-9,_ 및. 문자로 구성된 키를 UTF-8 인코딩과 길이가 64 문자 이하의 순서로 지원해야합니다 (MUST). 구현 라이브러리은 추가 문자와 인코딩 또는 더 긴 길이를 지원할 수 있지만 최소한 그 최소값을 지원해야합니다(MAY). 라이브러리는 적절하게 키 문자열을 이스케이프 처리해야하지만 원래의 수정되지 않은 키 문자열을 반환 할 수 있어야합니다(MUST). 다음 문자는 미래의 확장을 위해 예약되어 있으며, 구현 라이브러리에서 지원해서는 안됩니다(MUST NOT) :{} () / \\ @ :\n  Hit - 호출 라이브러리가 키로 Item을 요청하고 해당 키에 대해 일치하는 값이 발견되고 그 값이 만료되지 않았으며 값이 다른 이유로 무효하지 않은 경우 캐시 히트(Hit)가 발생합니다. 호출 라이브러리는 모든 get() 호출에 대해 isHit()를 확인해야합니다 (SHOULD).\n  Miss - 캐시 미스는 캐시 히트와 반대입니다. 호출 라이브러리가 키로 항목을 요청하고 해당 키에 해당 값이 없거나 값이 발견되었지만 만료되었거나 값이 다른 이유로 유효하지 않은 경우 캐시 미스가 발생합니다. 만료 된 값은 항상 캐시 미스로 간주되어야합니다 (MUST).\n  지연됨(Deferred) - 지연된 캐시 저장은 캐시 항목이 풀에 의해 즉시 유지되지 않을 수 있음을 나타냅니다. 풀 객체는 일부 저장소 엔진에서 지원하는 대량 세트 연산을 이용하기 위해 지연된 캐시 항목을 유지하는 것을 지연시킬 수 있습니다. 풀은 지연 캐시 항목이 결국 유지되고 데이터가 손실되지 않도록 보장해야하며 호출 라이브러리가 지속되도록 요청하기 전에이를 유지해야합니다. 호출 라이브러리가 commit() 메소드를 호출 할 때 모든 미해결 지연 항목을 유지해야합니다 (MUST). 구현 라이브러리는 객체 소멸자, save(), timeout 또는 max-items check 또는 다른 적절한 논리에서 모두 지속되는 것과 같이 지연된 항목을 언제 유지할 것인지를 결정하는 데 적합한 논리를 사용할 수 있습니다 (MAY). 지연된 캐시 항목에 대한 요청은 지연되었지만 아직 지속되지 않은 항목을 반환해야합니다 (MUST).\n  Data #  구현 라이브러리는 다음을 포함하여 모든 직렬화 가능한 PHP 데이터 유형을 지원해야합니다.\n Strings - PHP 호환 인코딩의 임의의 크기를 갖는 문자열. Integers - PHP가 지원하는 모든 크기의 정수 (최대 64 비트). Floats - 부호가 있는(signed) 모든 부동소수점 값. Boolean - True 와 False. Null - 진짜 Null 값. 역자주: 진짜라는 표현을 하는 이유는 PSR-16의 Null과는 다른 의미라서 입니다 Arrays - 인덱스된 임의의 깊이를 가진 연관 및 다차원 배열 Object - $o == unserialize(serialize($o)) 와 같이 무손실 직렬화 및 직렬화 해제를 지원하는 객체. 객체는 PHP의 Serializable 인터페이스, 적절한 경우 __sleep() 또는 __wakeup() 매직 메서드 또는 유사한 언어 기능을 활용할 수 있습니다(MAY).  구현 라이브러리에 전달 된 모든 데이터는 전달 된 그대로 정확하게 반환되어야합니다(MUST). 여기에는 가변 유형이 포함됩니다. 즉, 만약 (int) 5가 저장된 값이었던 경우 (string) 5를 반환하는 것은 오류입니다. 구현 라이브러리는 PHP의 serialize()/unserialize() 함수를 내부적으로 사용할 수 있지만 꼭 그렇게 할 필요는 없습니다(MAY). 이들과의 호환성은 수용 가능한 객체 값의 기준선으로 사용됩니다.\n어떠한 이유로든 저장된 정확한 값을 반환 할 수없는 경우 구현 라이브러리는 데이터가 손상되지 않게 캐시 미스로 응답해야합니다(MUST).\nKey Concepts #  Pool #  풀은 캐싱 시스템의 항목 모음을 나타냅니다. 풀은 포함 된 모든 항목의 논리적 저장소입니다. 캐시 가능한 모든 항목은 풀에서 항목 객체로 검색되고 캐시 된 객체의 전체 유니버스와의 모든 상호 작용은 풀을 통해 발생합니다.\nItems #  Item은 풀 내의 단일 키 / 값 쌍을 나타냅니다. 키는 Item에 대한 주요 고유 식별자이며 변경할 수 없어야합니다 (MUST). 언제든지 값을 변경할 수 있습니다 (MAY).\nError handling #  캐싱은 종종 애플리케이션 성능의 중요한 부분이지만 애플리케이션 기능의 중요한 부분이되어서는 안됩니다. 따라서 캐시 시스템의 오류로 인해 프로그램이 실패(failure)하지 않아야합니다 (SHOULD NOT). 이런 이유로, 구현 라이브러리는 인터페이스에 의해 정의 된 것과 다른 예외를 던져서는 안되며, 기본 데이터 저장소에 의해 발생된 된 오류나 예외를 버리고 문제를 일으키지 않아야합니다 (SHOULD).\n구현 라이브러리는 그러한 오류를 기록하거나 적절한 경우 이를 관리자에게 보고해야합니다 (SHOULD).\n호출 라이브러리가 하나 이상의 항목을 삭제하도록 요청하거나 풀을 지우도록 요청한 경우 지정된 키가 존재하지 않으면 오류 상태로 간주해서는 안됩니다(MUST NOT). 다음의 조건(키가 존재하지 않거나 풀이 비어 있음)도 동일하며 오류 조건은 없습니다.\nInterfaces #  CacheItemInterface #  CacheItemInterface는 캐시 시스템 내부의 항목을 정의합니다. 각 Item 객체는 구현 시스템에 따라 설정 될 수 있는 특정 키와 연결되어야하며(MUST) 일반적으로 Cache\\CacheItemPoolInterface 객체에 의해 전달됩니다.\nCache\\CacheItemInterface 객체는 캐시 항목의 저장 및 검색을 캡슐화합니다. 각 Cache\\CacheItemInterface는 Cache\\CacheItemPoolInterface 오브젝트에 의해 생성되며, 필요한 모든 설정을 담당 할 뿐만 아니라 오브젝트를 고유 키와 연관시킵니다. Cache\\CacheItemInterface 객체는 이 문서의 데이터 섹션에 정의 된 모든 유형의 PHP 값을 저장하고 검색 할 수 있어야 합니다.\n호출 라이브러리는 Item 객체 자체를 인스턴스화해서는 안됩니다. getItem() 메소드를 통해 Pool 객체에서만 요청할 수 있습니다. 라이브러리 호출은 하나의 구현 라이브러리에 의해 생성 된 항목이 다른 구현 라이브러리의 풀과 호환 가능하다고 가정해서는 안됩니다 (SHOULD NOT).\n\u0026lt;?php namespace Psr\\Cache; /** * CacheItemInterface defines an interface for interacting with objects inside a cache. */ interface CacheItemInterface { /** * Returns the key for the current cache item. * * The key is loaded by the Implementing Library, but should be available to * the higher level callers when needed. * * @return string * The key string for this cache item. */ public function getKey(); /** * Retrieves the value of the item from the cache associated with this object\u0026#39;s key. * * The value returned must be identical to the value originally stored by set(). * * If isHit() returns false, this method MUST return null. Note that null * is a legitimate cached value, so the isHit() method SHOULD be used to * differentiate between \u0026#34;null value was found\u0026#34; and \u0026#34;no value was found.\u0026#34; * * @return mixed * The value corresponding to this cache item\u0026#39;s key, or null if not found. */ public function get(); /** * Confirms if the cache item lookup resulted in a cache hit. * * Note: This method MUST NOT have a race condition between calling isHit() * and calling get(). * * @return bool * True if the request resulted in a cache hit. False otherwise. */ public function isHit(); /** * Sets the value represented by this cache item. * * The $value argument may be any item that can be serialized by PHP, * although the method of serialization is left up to the Implementing * Library. * * @param mixed $value * The serializable value to be stored. * * @return static * The invoked object. */ public function set($value); /** * Sets the expiration time for this cache item. * * @param \\DateTimeInterface|null $expiration * The point in time after which the item MUST be considered expired. * If null is passed explicitly, a default value MAY be used. If none is set, * the value should be stored permanently or for as long as the * implementation allows. * * @return static * The called object. */ public function expiresAt($expiration); /** * Sets the expiration time for this cache item. * * @param int|\\DateInterval|null $time * The period of time from the present after which the item MUST be considered * expired. An integer parameter is understood to be the time in seconds until * expiration. If null is passed explicitly, a default value MAY be used. * If none is set, the value should be stored permanently or for as long as the * implementation allows. * * @return static * The called object. */ public function expiresAfter($time); } CacheItemPoolInterface #  Cache\\CacheItemPoolInterface의 기본 목적은 호출 라이브러리에서 키를 승인하고 연관된 Cache\\CacheItemInterface 오브젝트를 리턴하는 것입니다. 또한 전체 캐시 컬렉션과의 상호 작용의 주요 지점이기도합니다. 풀(Pool)의 모든 구성 및 초기화는 구현 라이브러리에 맡깁니다.\n\u0026lt;?php namespace Psr\\Cache; /** * CacheItemPoolInterface generates CacheItemInterface objects. */ interface CacheItemPoolInterface { /** * Returns a Cache Item representing the specified key. * * This method must always return a CacheItemInterface object, even in case of * a cache miss. It MUST NOT return null. * * @param string $key * The key for which to return the corresponding Cache Item. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return CacheItemInterface * The corresponding Cache Item. */ public function getItem($key); /** * Returns a traversable set of cache items. * * @param string[] $keys * An indexed array of keys of items to retrieve. * * @throws InvalidArgumentException * If any of the keys in $keys are not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return array|\\Traversable * A traversable collection of Cache Items keyed by the cache keys of * each item. A Cache item will be returned for each key, even if that * key is not found. However, if no keys are specified then an empty * traversable MUST be returned instead. */ public function getItems(array $keys = array()); /** * Confirms if the cache contains specified cache item. * * Note: This method MAY avoid retrieving the cached value for performance reasons. * This could result in a race condition with CacheItemInterface::get(). To avoid * such situation use CacheItemInterface::isHit() instead. * * @param string $key * The key for which to check existence. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if item exists in the cache, false otherwise. */ public function hasItem($key); /** * Deletes all items in the pool. * * @return bool * True if the pool was successfully cleared. False if there was an error. */ public function clear(); /** * Removes the item from the pool. * * @param string $key * The key to delete. * * @throws InvalidArgumentException * If the $key string is not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if the item was successfully removed. False if there was an error. */ public function deleteItem($key); /** * Removes multiple items from the pool. * * @param string[] $keys * An array of keys that should be removed from the pool. * * @throws InvalidArgumentException * If any of the keys in $keys are not a legal value a \\Psr\\Cache\\InvalidArgumentException * MUST be thrown. * * @return bool * True if the items were successfully removed. False if there was an error. */ public function deleteItems(array $keys); /** * Persists a cache item immediately. * * @param CacheItemInterface $item * The cache item to save. * * @return bool * True if the item was successfully persisted. False if there was an error. */ public function save(CacheItemInterface $item); /** * Sets a cache item to be persisted later. * * @param CacheItemInterface $item * The cache item to save. * * @return bool * False if the item could not be queued or if a commit was attempted and failed. True otherwise. */ public function saveDeferred(CacheItemInterface $item); /** * Persists any deferred cache items. * * @return bool * True if all not-yet-saved items were successfully saved or there were none. False otherwise. */ public function commit(); } CacheException #  이 예외 인터페이스는 캐시 서버에 연결하거나 제공된 잘못된 자격 증명과 같은 캐시 설정을 포함하여 치명적인 오류가 발생할 때 사용하기위한 것입니다. 구현 라이브러리에 의해 던져진 예외는 이 인터페이스를 구현해야합니다 (MUST).\n\u0026lt;?php namespace Psr\\Cache; /** * Exception interface for all exceptions thrown by an Implementing Library. */ interface CacheException { } InvalidArgumentException #  \u0026lt;?php namespace Psr\\Cache; /** * Exception interface for invalid cache arguments. * * Any time an invalid argument is passed into a method it must throw an * exception class which implements Psr\\Cache\\InvalidArgumentException. */ interface InvalidArgumentException extends CacheException { } "});index.add({'id':8,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/06-psr-7/','title':"06 P S R 7",'section':"Php",'content':"HTTP message interfaces #  이 문서는 RFC 7230 및 RFC 7231에 설명한 대로 HTTP 메시지를 처리하는 일반적인 인터페이스 및 RFC 3986에 설명한 대로 HTTP 메시지와 함께 사용할 URI에 관한 내용을 설명합니다\nHTTP 메시지는 웹 개발의 기반(foundation)입니다. 웹 브라우저와 cURL과 같은 HTTP 클라이언트는 HTTP 요청 메시지를 작성하여 HTTP 응답 메시지를 제공하는 웹 서버로 전송합니다. 서버 측 코드는 HTTP 요청 메시지를 수신하고 HTTP 응답 메시지를 반환합니다.\nHTTP 메시지는 일반적으로 최종 사용자로부터 요청(abstracted)되지만 개발자들은 일반적으로 HTTP API에 요청을 하거나 들어오는 요청을 처리하는 등의 작업을 수행하기 위해 구조화 방법과 이를 액세스하거나 조작하는 방법을 알아야합니다.\n모든 HTTP 요청 메시지에는 다음과 같은 특정 형식이 있습니다.\nPOST /path HTTP/1.1 Host: example.com foo=bar\u0026amp;baz=bat 첫 번째 요청 줄은 \u0026ldquo;요청 줄(request line)\u0026ldquo;이며 HTTP 요청 방법(request method), 요청 대상 (일반적으로 URI의 절대값 또는 웹 서버의 경로) 및 HTTP 프로토콜 버전을 순서대로 포함합니다. 그 뒤에는 하나 이상의 HTTP 헤더, 빈 행 및 메시지 본문이옵니다.\nHTTP 응답 메시지는 다음과 유사한 구조를 가집니다.\nHTTP/1.1 200 OK Content-Type: text/plain This is the response body 첫 번째 줄은 \u0026ldquo;상태 줄\u0026quot;이며 HTTP 프로토콜 버전, HTTP 상태 코드 및 사람이 읽을 수 있는 상태 코드 설명 인 \u0026ldquo;이유 구문\u0026quot;을 순서대로 포함합니다. HTTP 요청 메시지와 마찬가지로 하나 이상의 HTTP 헤더, 빈 행 및 메시지 본문이옵니다.\n이 문서에서 설명하는 인터페이스는 HTTP 메시지 및 HTTP 메시지를 구성하는 요소를 추상화 한 것입니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\nReferences #   RFC 2119 RFC 3986 RFC 7230 RFC 7231  1. 명세서 #  1.1 Messages #  HTTP 메시지는 클라이언트에서 서버로의 요청 또는 서버에서 클라이언트로의 응답을 의미합니다. 이 사양은 HTTP 메시지 Psr\\Http\\Message\\RequestInterface 와 Psr\\Http\\Message\\ResponseInterface 에 대한 인터페이스를 각각 정의합니다.\nPsr\\Http\\Message\\RequestInterface 와 Psr\\Http\\Message\\ResponseInterface 는 모두 Psr\\Http\\Message\\MessageInterface를 상속받습니다(extend). Psr\\Http\\Message\\MessageInterface 는 직접 구현 해도 되지만(MAY), 구현자는 Psr\\Http\\Message\\RequestInterface 와 Psr\\Http\\Message\\ResponseInterface 를 구현해야합니다 (SHOULD).\n앞으로 이 인터페이스들을 말 할 때 Psr\\Http\\Message 네임 스페이스는 생략 할 것입니다.\n1.2 HTTP Headers #  대소문자를 구분하지 않는 헤더 필드 이름 #  HTTP 메시지에는 대소문자를 구분하지 않는 헤더 필드 이름을 포함합니다. MessageInterface 를 구현하는 클래스에서 헤더를 대문자와 소문자를 구분하지 않는 이름으로 검색합니다. 예를 들어 foo 헤더를 검색하는 것은 FoO 헤더를 검색하는 것과 같은 결과를 반환합니다. 비슷하게 Foo 헤더를 설정하면 이전에 설정된 foo 헤더 값을 덮어 씁니다.\n$message = $message-\u0026gt;withHeader(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;); echo $message-\u0026gt;getHeaderLine(\u0026#39;foo\u0026#39;); // Outputs: bar echo $message-\u0026gt;getHeaderLine(\u0026#39;FOO\u0026#39;); // Outputs: bar $message = $message-\u0026gt;withHeader(\u0026#39;fOO\u0026#39;, \u0026#39;baz\u0026#39;); echo $message-\u0026gt;getHeaderLine(\u0026#39;foo\u0026#39;); // Outputs: baz 헤더는 대소문자의 구분 없이 검색할 수 있지만, getHeaders() 로 가져올 경우는 원래의 대소문자가 유지되어야만 합니다 (MUST).\n부적합한 HTTP 프로그램은 특정 경우에 따라 달라질 수 있으므로 사용자가 요청이나 응답을 만들 때 HTTP 헤더의 대소문자를 지정할 수 있는 것이 좋습니다.\n여러개의 값을 가진 헤더 #  여러개의 값을 가진 헤더를 수용하면서도 헤더로 문자열 작업을 할 수 있는 편리함을 제공하기 위해, 배열이나 문자열로 MessageInterface 의 인스턴스에서 헤더를 검색 할 수 있습니다. getHeaderLine() 메서드를 사용하여, 대소문자를 구분하지 않는 헤더의 이름으로 검색한 결과 값을 모두 쉼표로 연결한 문자열을 가져옵니다. 대문자와 소문자를 구분하지 않는 헤더의 모든 헤더 값의 배열을 이름으로 검색하려면 getHeader()를 사용하십시오.\n$message = $message -\u0026gt;withHeader(\u0026#39;foo\u0026#39;, \u0026#39;bar\u0026#39;) -\u0026gt;withAddedHeader(\u0026#39;foo\u0026#39;, \u0026#39;baz\u0026#39;); $header = $message-\u0026gt;getHeaderLine(\u0026#39;foo\u0026#39;); // $header contains: \u0026#39;bar, baz\u0026#39; $header = $message-\u0026gt;getHeader(\u0026#39;foo\u0026#39;); // [\u0026#39;bar\u0026#39;, \u0026#39;baz\u0026#39;] 참고 : 모든 헤더 값을 쉼표 (예 :Set-Cookie)를 사용하여 연결할 수 있는 것은 아닙니다. 이러한 헤더로 작업 할 때 MessageInterface 기반의 클래스는 이러한 다중 값 헤더를 검색하기 위해 getHeader() 메소드에 의존해야합니다 (SHOULD).\nHost 헤더 #  요청에서 Host 헤더는 일반적으로 URI의 호스트 구성 부분만 아니라 TCP 연결 할 때 사용하는 호스트를 포함합니다. 그러나 HTTP 사양(specification)에서는 Host 헤더가 각각 다른 것을 허용하고 있습니다. 역자주: TCP 연결에 사용된 URI와 Http Requeser의 Host Header의 값이 다른 것을 허용합니다\n그래서 구현시 Host 헤더가 제공되지 않으면 제공된 URI에서 Host 헤더를 가져와야 합니다 (MUST).\n기본적으로 RequestInterface::withUri()은 요청의 Host 헤더의 값을 전달 된 UriInterface 의 호스트 구성 요소와 일치하는 Host 헤더로 대체합니다.\n두 번째 인수($preserveHost)에 true 를 전달하여 Host 헤더의 원래 상태를 보존하도록 선택할 수 있습니다. 이 인수를 true 로 설정하면 반환 하는 메시지의 Host 헤더를 업데이트하지 않습니다. 단, 메시지에 Host 헤더가 포함되어 있지 않으면 예외입니다.\n이 테이블은 다양한 초기 요청과 URI에 대해 $preserveHost 인자가 true 로 설정된 withUri() 에 의해 반환 된 요청에 대해 getHeaderLine('Host') 가 반환하는 것을 보여줍니다.\n   Request Host header1 Request host component2 URI host component3 Result     '\u0026rsquo; '\u0026rsquo; '\u0026rsquo; '\u0026rsquo;   '\u0026rsquo; foo.com '\u0026rsquo; foo.com   '\u0026rsquo; foo.com bar.com foo.com   foo.com '\u0026rsquo; bar.com foo.com   foo.com bar.com baz.com foo.com     1변경이 일어나기 전의 Host 헤더 값 2변경 전에 요청으로 작성된 URI의 Host 구성 요소. 3withUri() 를 통해 주입되는 URI의 Host 구성 요소.  1.3 Streams #  HTTP 메시지는 시작 줄, 헤더 및 본문으로 구성됩니다. HTTP 메시지 본문은 매우 작거나 매우 클 수 있습니다. 본문의 메시지를 문자열로 변환하려고하면 본문이 완전히 메모리에 저장되어야하기 때문에 의도 한 것보다 많은 메모리를 쉽게 써버릴 수 있습니다. 요청이나 응답의 본문을 메모리에 저장하려고 하면 배제되어 해당 구현을 사용하여 큰 메시지 본문을 처리 할 수 있게됩니다. 역자주: 자연스럽게 번역하려면 배제된다는 표현을 다른 것으로 바꾸는게 좋아보이지만 답을 못찾았습니다 StreamInterface는 데이터 스트림을 읽거나 쓸 때 구현 세부 사항을 감추기 위해 사용합니다. 문자열이 적절한 메시지 구현이된다면, php://memory 와 php://temp와 같은 내장 스트림을 사용할 수 있습니다.\nStreamInterface는 스트림을 효율적으로 읽고, 쓰고, 지나갈 수 있게 해주는 몇가지 메소드를 제공줍니다.\n스트림은 isReadable(), isWritable() 및 isSeekable()의 세 가지 메소드를 사용합니다 이 메소드는 스트림 작업자가 스트림이 자신의 요구 사항을 충족하는지 확인하는 데 사용할 수 있습니다.\n각 스트림 인스턴스에는 읽기 전용, 쓰기 전용 또는 읽기 / 쓰기가 가능한 다양한 기능이 있습니다. 또한 임의의 임의 액세스 (모든 위치를 앞뒤로 검색) 또는 순차 액세스 (예 : 소켓, 파이프 또는 콜백 기반 스트림의 경우) 만 허용 할 수 있습니다.\n마지막으로, StreamInterface 는 전체 본문 내용을 즉시 검색하거나 내보내는 것을 단순화하는 __toString () 메소드를 제공합니다.\n요청과 응답 인터페이스와 달리,StreamInterface는 불변성을 모델링하지 않습니다. 실제 PHP 스트림이 래핑 된 상황에서는 자원과 상호 작용하는 모든 코드가 커서 상태, 내용 등을 포함하여 상태를 변경시킬 수 있으므로 변경이 불가능합니다. 구현시 서버 측 요청 및 클라이언트 측 응답에 읽기 전용 스트림을 사용하는 것이 좋습니다. 사용자는 스트림 인스턴스가 변경 될 수 있으며 메시지 상태를 변경할 수 있다는 사실을 알고 있어야합니다. 의심스럽다면 새 스트림 인스턴스를 만들어 메시지에 첨부하여 상태를 적용합니다.\n1.4 Request Targets and URIs #  RFC 7230에 따라 요청 메시지에는 요청 줄의 두 번째 세그먼트로 \u0026ldquo;요청 대상\u0026quot;이 포함됩니다. 요청 대상은 다음 형식 중 하나 일 수 있습니다.\n origin-form : 경로와 쿼리스트링 (있을 경우)으로 구성됩니다. 이를 보통 상대 URL이라고 합니다. TCP를 통해 전송되는 메시지는 일반적으로 origin-form입니다. 스키마(scheme) 및 권한 데이터는 일반적으로 CGI 변수를 통해서만 표현합니다. absolute-form : (\u0026quot;[user-info@]호스트[:port]\u0026rdquo;, 대괄호 안의 항목은 선택 사항), 경로 (있는 경우), 쿼리스트링 (있는 경우) 및 fragment (있는 경우)으로 구성됩니다. 역자주: fragment는 URI의 #(hash) 문자열로 생각하시면 됩니다 이것은 절대 URI라고도하며 RFC 3986에서 지정하는 유일한 URI 형식입니다. 이 양식은 HTTP 프록시에 요청할 때 일반적으로 사용됩니다. authority-form : 권한으로만 구성되어있습니다. 이것은 일반적으로 HTTP 클라이언트와 프록시 서버 사이의 연결을 설정하기 위한 CONNECT 요청에만 사용됩니다. asterisk-form : 이것은 문자열 * 로만 구성되며 웹 서버의 일반적인 기능을 결정하기 위해 OPTIONS 메서드와 함께 사용됩니다.  이러한 요청 대상 외에도 요청 대상과는 별도로 \u0026lsquo;유효한(effective) URL\u0026rsquo;이 있는 경우가 종종 있습니다. 유효한(effective) URL은 HTTP 메시지 내에서 전송되지 않지만 요청을 하기위한 프로토콜 (http/https), 포트 및 호스트 이름을 결정하는 데 사용됩니다.\n유효한(effective) URL은 UriInterface 에 의해 표현됩니다. UriInterface 는 RFC 3986 (첫번째 사용 사례)에 명시된대로 HTTP와 HTTPS URI를 모델링합니다. 이 인터페이스는 다양한 URI 부분과 상호 작용하기위한 메소드를 제공하여 URI의 반복 구문 분석의 필요성을 없애줍니다. 또한 모델링 된 URI를 문자열 표현으로 변환하기위한 __toString() 메소드를 제공합니다.\ngetRequestTarget()으로 request-target을 검색 할 때, 이 메소드는 기본적으로 URI 객체를 사용하고 origin-form을 구성하는 데 필요한 모든 구성 요소를 추출합니다. origin-form은 가장 일반적인 요청 대상입니다.\n최종 사용자가 다른 세 가지 형식 중 하나를 사용하기를 원하거나 사용자가 명시적으로 요청 대상을 덮어쓰고 싶다면 withRequestTarget()을 사용하여 이를 처리 할 수 있습니다. 역자주: 세가지 형식이란 위에 나오는 네가지 형식 중 **origin-form**을 제외한 세가지를 말합니다\n이 메소드를 호출하면 getUri()로부터 반환받는 URI에 영향을 주지 않습니다.\n예를 들어, 사용자는 아래와 같이 서버에 asterisk-form 요청을 할 수 있습니다.\n$request = $request -\u0026gt;withMethod(\u0026#39;OPTIONS\u0026#39;) -\u0026gt;withRequestTarget(\u0026#39;*\u0026#39;) -\u0026gt;withUri(new Uri(\u0026#39;https://example.org/\u0026#39;)); 이 예제는 최종적으로 다음과 같은 결과를 얻을 수 있습니다.\nOPTIONS * HTTP/1.1 하지만 HTTP 클라이언트는 유효한(effective) URL (getUri()로부터)을 사용하여 프로토콜, 호스트 이름 및 TCP 포트를 결정할 수 있습니다.\nHTTP 클라이언트는 반드시 Uri::getPath() 와 Uri::getQuery() 의 값을 무시해야하며(MUST), 대신 getRequestTarget() 에 의해 반환 된 값을 사용해야합니다. 기본값은 이 두 값을 연결한 것입니다.\n네 개의 요청 대상 폼 중 하나 이상을 구현하지 않기로 결정한 클라이언트는 여전히 getRequestTarget() 을 사용해야한다(MUST). 이들 클라이언트는 지원하지 않는 요청 대상을 거부해야하며(MUST) 반드시 getUri() 의 값으로 폴백해서는 안된다(MUST NOT).\nRequestInterface는 요청 대상을 검색하거나 제공된 요청 대상으로 새로운 인스턴스를 생성하기위한 메소드를 제공합니다. 기본적으로 요청 대상이 인스턴스에서 특별히 구성되지 않으면, getRequestTarget()은 구성된 URI의 origin-form을 반환할 것입니다. (URI가 구성되지 않으면 \u0026ldquo;/\u0026quot;). withRequestTarget($requestTarget) 은 지정된 요청 대상으로 새로운 인스턴스를 생성하고, 개발자가 다른 3 개의 요청 대상 형식 (absolute-form, authority-form 및 asterisk-form)을 나타내는 요청 메시지를 생성 할 수 있도록합니다. 사용되는 경우 구성된 URI 인스턴스는 여전히 클라이언트에서 사용할 수 있습니다.이 인스턴스는 서버에 대한 연결을 만드는 데 사용될 수 있습니다.\n1.5 Server-side Requests #  RequestInterface 는 HTTP 요청 메시지의 일반적인 표현을 제공합니다. 그러나 서버 측 요청의 경우 서버 측 환경의 특성상 추가 처리가 필요합니다. 서버 측 프로세싱은 CGI (Common Gateway Interface)를 고려해야하며 PHP의 SAPI(Server APIs)를 통한 CGI의 추상화 및 확장이 필요합니다. PHP는 다음과 같은 슈퍼 전역 변수를 통해 입력을 정렬하고 단순화했습니다.\n $ _COOKIE : 역직렬화된 HTTP 쿠키에 대한 단순화 된 접근을 제공합니다. $ _GET : 역직렬화된 쿼리스트링 인수에 대한 단순화 된 접근을 제공합니다. $ _POST : 역직렬화된 HTTP POST를 통해 제출 된 urlencoded 매개 변수에 대해 단순화 된 액세스를 제공합니다. 일반적으로 메시지 본문을 파싱 한 결과로 간주 될 수 있습니다. $ _FILES : 파일 업로드와 관련된 일련의 메타 데이터를 제공합니다. $ _SERVER : CGI / SAPI 환경 변수에 대한 액세스를 제공합니다. 일반적으로 요청 메소드, 요청 스킴, 요청 URI 및 헤더가 포함됩니다.  ServerRequestInterface 는 RequestInterface 를 확장하여 이러한 다양한 슈퍼 전역 변수를 추상화합니다. 이 방법은 사용자가 슈퍼 전역변수에 연결(coupling)하는 것을 줄이고 요청 사용자가 테스트하는 것을 권장하고 도와줍니다. 서버 요청은 \u0026ldquo;속성(attributes)\u0026ldquo;이라는 추가 속성 하나를 제공하여 소비자가 응용 프로그램 관련 규칙 (예 : 경로(path) 일치, scheme 일치, 호스트 일치 등)에 대한 인트로스펙트(introspect), 분해(decompose) 및 일치(match) 기능을 제공합니다. 따라서 서버 요청은 여러 요청자간에 메시징을 제공 할 수도 있습니다.\n1.6 Uploaded files #  ServerRequestInterface 는 각 가지(leaf)가 UploadedFileInterface 인스턴스로 정규화 된 구조로 업로드 파일 트리를 검색하는 메소드를 제공합니다.\nAs an example, if you have a form that submits an array of files — e.g., the input name \u0026ldquo;files\u0026rdquo;, submitting files[0] and files[1] — PHP will represent this as: $_FILES 슈퍼 전역변수는 파일 입력 배열을 다룰 때 잘 알려진 문제점을 가지고 있습니다. 예를 들어, 파일의 배열 (예 : 입력 이름이 \u0026ldquo;files\u0026quot;인 경우, files[0] 및 files[1])을 제출하는 폼이 있는 경우 PHP는 다음과 같이 표현합니다.\narray( \u0026#39;files\u0026#39; =\u0026gt; array( \u0026#39;name\u0026#39; =\u0026gt; array( 0 =\u0026gt; \u0026#39;file0.txt\u0026#39;, 1 =\u0026gt; \u0026#39;file1.html\u0026#39;, ), \u0026#39;type\u0026#39; =\u0026gt; array( 0 =\u0026gt; \u0026#39;text/plain\u0026#39;, 1 =\u0026gt; \u0026#39;text/html\u0026#39;, ), /* etc. */ ), ) 아래와 같이 예상되는 것 대신 말이죠\narray( \u0026#39;files\u0026#39; =\u0026gt; array( 0 =\u0026gt; array( \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;file0.txt\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;text/plain\u0026#39;, /* etc. */ ), 1 =\u0026gt; array( \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;file1.html\u0026#39;, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;text/html\u0026#39;, /* etc. */ ), ), ) 결과적으로 사용자는 이 언어 구현 세부 사항을 알아야하고 주어진 업로드에 대한 데이터를 수집하기위한 코드를 작성해야합니다.\n또한 아래와 같은 파일 업로드를 했을 때 $ _FILES 가 비어있는 경우가 있습니다\n HTTP method가 POST 아닐 때. 유닛 테스팅 중일 때. ReactPHP와 같은 SAPI가 아닌 환경에서 작동 할 때.  이 경우 데이터를 다르게 시드해야합니다. 예를 들면 다음과 같습니다.\n 프로세스가 메시지 본문을 구문 분석하여 파일 업로드를 발견 할 수 있습니다. 이 경우 구현은 파일 업로드를 파일 시스템에 쓰지 않고 대신 메모리, I/O 및 저장소 오버 헤드를 줄이기 위해 스트림으로 래핑하도록 선택할 수 있습니다. 단위 테스트 시나리오에서 개발자는 다른 시나리오의 유효성을 검사하고 검증하기 위해 파일 업로드 메타 데이터를 스텁(stub) 또는 모의(mock) 할 수 있어야합니다.  getUploadedFiles ()는 사용자를 위해 정규화 된 구조를 제공합니다. 구현은 다음을 기대 합니다.\n 주어진 파일 업로드에 대한 모든 정보를 모아서 Psr\\Http\\Message\\UploadedFileInterface 인스턴스를 채웁니다. 전송된 트리 구조를 재작성합니다. 각 리프는 트리의 주어진 위치에 대한 적절한 Psr\\Http\\Message\\UploadedFileInterface 인스턴스입니다.  참조 된 트리 구조는 파일이 제출 된 명명 구조를 모방해야합니다.\n가장 단순한 예를 들어서, 이것은 다음과 같이 제출 된 단일 명명 된 양식 요소(form element) 일 수 있습니다.\n\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;avatar\u0026#34; /\u0026gt; 이 경우, $_FILES의 구조는 다음과 같습니다\narray( \u0026#39;avatar\u0026#39; =\u0026gt; array( \u0026#39;tmp_name\u0026#39; =\u0026gt; \u0026#39;phpUxcOty\u0026#39;, \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;my-avatar.png\u0026#39;, \u0026#39;size\u0026#39; =\u0026gt; 90996, \u0026#39;type\u0026#39; =\u0026gt; \u0026#39;image/png\u0026#39;, \u0026#39;error\u0026#39; =\u0026gt; 0, ), ) getUploadedFiles() 에 의해 반환된 정규화된 양식은 다음과 같습니다\narray( \u0026#39;avatar\u0026#39; =\u0026gt; /* UploadedFileInterface instance */ ) 이름에 배열 표기법을 사용하는 입력의 경우\n\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;my-form[details][avatar]\u0026#34; /\u0026gt; $_FILES은 다음과 같이 보입니다\narray ( \u0026#39;my-form\u0026#39; =\u0026gt; array ( \u0026#39;name\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; \u0026#39;my-avatar.png\u0026#39;, ), ), \u0026#39;type\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; \u0026#39;image/png\u0026#39;, ), ), \u0026#39;tmp_name\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; \u0026#39;phpmFLrzD\u0026#39;, ), ), \u0026#39;error\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; 0, ), ), \u0026#39;size\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; 90996, ), ), ), ) 그리고 getUploadedFiles() 에 의해 반환 된 트리는 다음과 같아야합니다\narray( \u0026#39;my-form\u0026#39; =\u0026gt; array( \u0026#39;details\u0026#39; =\u0026gt; array( \u0026#39;avatar\u0026#39; =\u0026gt; /* UploadedFileInterface instance */ ), ), ) 경우에 따라 다음과 같이 파일 배열을 지정할 수 있습니다.\nUpload an avatar: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;my-form[details][avatars][]\u0026#34; /\u0026gt; Upload an avatar: \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;my-form[details][avatars][]\u0026#34; /\u0026gt; (예를 들어 자바스크립트를 사용해 추가 파일 업로드 인풋을 생성하여 한 번에 여러 파일을 업로드 할 수 있습니다.)\n이 경우, 스펙 구현은 주어진 인덱스에있는 파일과 관련된 모든 정보를 집계해야합니다. 왜냐하면 $_FILES 는 다음과 같은 경우 정상적인 구조에서 벗어났기 때문입니다\narray ( \u0026#39;my-form\u0026#39; =\u0026gt; array ( \u0026#39;name\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; array ( 0 =\u0026gt; \u0026#39;my-avatar.png\u0026#39;, 1 =\u0026gt; \u0026#39;my-avatar2.png\u0026#39;, 2 =\u0026gt; \u0026#39;my-avatar3.png\u0026#39;, ), ), ), \u0026#39;type\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; array ( 0 =\u0026gt; \u0026#39;image/png\u0026#39;, 1 =\u0026gt; \u0026#39;image/png\u0026#39;, 2 =\u0026gt; \u0026#39;image/png\u0026#39;, ), ), ), \u0026#39;tmp_name\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; array ( 0 =\u0026gt; \u0026#39;phpmFLrzD\u0026#39;, 1 =\u0026gt; \u0026#39;phpV2pBil\u0026#39;, 2 =\u0026gt; \u0026#39;php8RUG8v\u0026#39;, ), ), ), \u0026#39;error\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; array ( 0 =\u0026gt; 0, 1 =\u0026gt; 0, 2 =\u0026gt; 0, ), ), ), \u0026#39;size\u0026#39; =\u0026gt; array ( \u0026#39;details\u0026#39; =\u0026gt; array ( \u0026#39;avatar\u0026#39; =\u0026gt; array ( 0 =\u0026gt; 90996, 1 =\u0026gt; 90996, 3 =\u0026gt; 90996, ), ), ), ), ) 위의 $_FILES 배열은 getUploadedFiles() 에 의해 반환 될 경우 다음 구조체에 해당합니다\narray( \u0026#39;my-form\u0026#39; =\u0026gt; array( \u0026#39;details\u0026#39; =\u0026gt; array( \u0026#39;avatars\u0026#39; =\u0026gt; array( 0 =\u0026gt; /* UploadedFileInterface instance */, 1 =\u0026gt; /* UploadedFileInterface instance */, 2 =\u0026gt; /* UploadedFileInterface instance */, ), ), ), ) 사용자는 다음을 사용하여 중첩 배열의 인덱스 1에 접근합니다.\n$request-\u0026gt;getUploadedFiles()[\u0026#39;my-form\u0026#39;][\u0026#39;details\u0026#39;][\u0026#39;avatars\u0026#39;][1]; 업로드 된 파일 데이터는 파생물이므로 ( $_FILES 또는 요청 본문에서 파생 된), mutator 메소드 인 withUploadedFiles() 또한 인터페이스에 존재하므로 다른 프로세스에 대한 정규화를 위임 할 수 있습니다.\n원래 예제의 경우 사용은 다음과 유사합니다.\n$file0 = $request-\u0026gt;getUploadedFiles()[\u0026#39;files\u0026#39;][0]; $file1 = $request-\u0026gt;getUploadedFiles()[\u0026#39;files\u0026#39;][1]; printf( \u0026#34;Received the files %s and %s\u0026#34;, $file0-\u0026gt;getClientFilename(), $file1-\u0026gt;getClientFilename() ); // \u0026#34;Received the files file0.txt and file1.html\u0026#34; 이 제안은 또한 구현이 비 SAPI 환경에서 작동 할 수 있음을 보장(recognizes)합니다. 따라서 UploadedFileInterface 는 환경에 관계없이 작동이 작동 할 수 있도록 보장하는 메소드를 제공합니다. 특히\n moveTo($targetPath) 는 임시 업로드 파일에 직접 move_uploaded_file()을 호출하는 안전하고 권장되는 대안으로 제공됩니다. 구현체는 환경에 따라 사용할 올바른 작업을 감지합니다. getStream() 은 StreamInterface 인스턴스를 리턴합니다. 비 SAPI 환경에서 개별 업로드 파일을 직접 파일 대신에 php://temp 스트림으로 파싱하는 것이 제안되었습니다. 이 경우 업로드 파일이 없습니다. getStream()은 환경에 관계없이 작동하도록 보장됩니다.  예를 들면 다음과 같습니다.\n// Move a file to an upload directory $filename = sprintf( '%s.%s', create_uuid(), pathinfo($file0-\u0026gt;getClientFilename(), PATHINFO_EXTENSION) ); $file0-\u0026gt;moveTo(DATA_DIR . '/' . $filename); // Stream a file to Amazon S3. // Assume $s3wrapper is a PHP stream that will write to S3, and that // Psr7StreamWrapper is a class that will decorate a StreamInterface as a PHP // StreamWrapper. $stream = new Psr7StreamWrapper($file1-\u0026gt;getStream()); stream_copy_to_stream($stream, $s3wrapper); 2. Package #  설명 된 인터페이스와 클래스는 psr/http-message 패키지의 일부로 제공됩니다.\n3. Interfaces #  3.1 Psr\\Http\\Message\\MessageInterface #  \u0026lt;?php namespace Psr\\Http\\Message; /** * HTTP messages consist of requests from a client to a server and responses * from a server to a client. This interface defines the methods common to * each. * * Messages are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. * * @see http://www.ietf.org/rfc/rfc7230.txt * @see http://www.ietf.org/rfc/rfc7231.txt */ interface MessageInterface { /** * Retrieves the HTTP protocol version as a string. * * The string MUST contain only the HTTP version number (e.g., \u0026#34;1.1\u0026#34;, \u0026#34;1.0\u0026#34;). * * @return string HTTP protocol version. */ public function getProtocolVersion(); /** * Return an instance with the specified HTTP protocol version. * * The version string MUST contain only the HTTP version number (e.g., * \u0026#34;1.1\u0026#34;, \u0026#34;1.0\u0026#34;). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new protocol version. * * @param string $version HTTP protocol version * @return static */ public function withProtocolVersion($version); /** * Retrieves all message header values. * * The keys represent the header name as it will be sent over the wire, and * each value is an array of strings associated with the header. * * // Represent the headers as a string * foreach ($message-\u0026gt;getHeaders() as $name =\u0026gt; $values) { * echo $name . \u0026#39;: \u0026#39; . implode(\u0026#39;, \u0026#39;, $values); * } * * // Emit headers iteratively: * foreach ($message-\u0026gt;getHeaders() as $name =\u0026gt; $values) { * foreach ($values as $value) { * header(sprintf(\u0026#39;%s: %s\u0026#39;, $name, $value), false); * } * } * * While header names are not case-sensitive, getHeaders() will preserve the * exact case in which headers were originally specified. * * @return string[][] Returns an associative array of the message\u0026#39;s headers. * Each key MUST be a header name, and each value MUST be an array of * strings for that header. */ public function getHeaders(); /** * Checks if a header exists by the given case-insensitive name. * * @param string $name Case-insensitive header field name. * @return bool Returns true if any header names match the given header * name using a case-insensitive string comparison. Returns false if * no matching header name is found in the message. */ public function hasHeader($name); /** * Retrieves a message header value by the given case-insensitive name. * * This method returns an array of all the header values of the given * case-insensitive header name. * * If the header does not appear in the message, this method MUST return an * empty array. * * @param string $name Case-insensitive header field name. * @return string[] An array of string values as provided for the given * header. If the header does not appear in the message, this method MUST * return an empty array. */ public function getHeader($name); /** * Retrieves a comma-separated string of the values for a single header. * * This method returns all of the header values of the given * case-insensitive header name as a string concatenated together using * a comma. * * NOTE: Not all header values may be appropriately represented using * comma concatenation. For such headers, use getHeader() instead * and supply your own delimiter when concatenating. * * If the header does not appear in the message, this method MUST return * an empty string. * * @param string $name Case-insensitive header field name. * @return string A string of values as provided for the given header * concatenated together using a comma. If the header does not appear in * the message, this method MUST return an empty string. */ public function getHeaderLine($name); /** * Return an instance with the provided value replacing the specified header. * * While header names are case-insensitive, the casing of the header will * be preserved by this function, and returned from getHeaders(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new and/or updated header and value. * * @param string $name Case-insensitive header field name. * @param string|string[] $value Header value(s). * @return static * @throws \\InvalidArgumentException for invalid header names or values. */ public function withHeader($name, $value); /** * Return an instance with the specified header appended with the given value. * * Existing values for the specified header will be maintained. The new * value(s) will be appended to the existing list. If the header did not * exist previously, it will be added. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new header and/or value. * * @param string $name Case-insensitive header field name to add. * @param string|string[] $value Header value(s). * @return static * @throws \\InvalidArgumentException for invalid header names. * @throws \\InvalidArgumentException for invalid header values. */ public function withAddedHeader($name, $value); /** * Return an instance without the specified header. * * Header resolution MUST be done without case-sensitivity. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that removes * the named header. * * @param string $name Case-insensitive header field name to remove. * @return static */ public function withoutHeader($name); /** * Gets the body of the message. * * @return StreamInterface Returns the body as a stream. */ public function getBody(); /** * Return an instance with the specified message body. * * The body MUST be a StreamInterface object. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return a new instance that has the * new body stream. * * @param StreamInterface $body Body. * @return static * @throws \\InvalidArgumentException When the body is not valid. */ public function withBody(StreamInterface $body); } 3.2 Psr\\Http\\Message\\RequestInterface #  \u0026lt;?php namespace Psr\\Http\\Message; /** * Representation of an outgoing, client-side request. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - HTTP method * - URI * - Headers * - Message body * * During construction, implementations MUST attempt to set the Host header from * a provided URI if no Host header is provided. * * Requests are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface RequestInterface extends MessageInterface { /** * Retrieves the message\u0026#39;s request target. * * Retrieves the message\u0026#39;s request-target either as it will appear (for * clients), as it appeared at request (for servers), or as it was * specified for the instance (see withRequestTarget()). * * In most cases, this will be the origin-form of the composed URI, * unless a value was provided to the concrete implementation (see * withRequestTarget() below). * * If no URI is available, and no request-target has been specifically * provided, this method MUST return the string \u0026#34;/\u0026#34;. * * @return string */ public function getRequestTarget(); /** * Return an instance with the specific request-target. * * If the request needs a non-origin-form request-target — e.g., for * specifying an absolute-form, authority-form, or asterisk-form — * this method may be used to create an instance with the specified * request-target, verbatim. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * changed request target. * * @see http://tools.ietf.org/html/rfc7230#section-5.3 (for the various * request-target forms allowed in request messages) * @param mixed $requestTarget * @return static */ public function withRequestTarget($requestTarget); /** * Retrieves the HTTP method of the request. * * @return string Returns the request method. */ public function getMethod(); /** * Return an instance with the provided HTTP method. * * While HTTP method names are typically all uppercase characters, HTTP * method names are case-sensitive and thus implementations SHOULD NOT * modify the given string. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * changed request method. * * @param string $method Case-sensitive method. * @return static * @throws \\InvalidArgumentException for invalid HTTP methods. */ public function withMethod($method); /** * Retrieves the URI instance. * * This method MUST return a UriInterface instance. * * @see http://tools.ietf.org/html/rfc3986#section-4.3 * @return UriInterface Returns a UriInterface instance * representing the URI of the request. */ public function getUri(); /** * Returns an instance with the provided URI. * * This method MUST update the Host header of the returned request by * default if the URI contains a host component. If the URI does not * contain a host component, any pre-existing Host header MUST be carried * over to the returned request. * * You can opt-in to preserving the original state of the Host header by * setting `$preserveHost` to `true`. When `$preserveHost` is set to * `true`, this method interacts with the Host header in the following ways: * * - If the Host header is missing or empty, and the new URI contains * a host component, this method MUST update the Host header in the returned * request. * - If the Host header is missing or empty, and the new URI does not contain a * host component, this method MUST NOT update the Host header in the returned * request. * - If a Host header is present and non-empty, this method MUST NOT update * the Host header in the returned request. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * new UriInterface instance. * * @see http://tools.ietf.org/html/rfc3986#section-4.3 * @param UriInterface $uri New request URI to use. * @param bool $preserveHost Preserve the original state of the Host header. * @return static */ public function withUri(UriInterface $uri, $preserveHost = false); } 3.2.1 Psr\\Http\\Message\\ServerRequestInterface #  \u0026lt;?php namespace Psr\\Http\\Message; /** * Representation of an incoming, server-side HTTP request. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - HTTP method * - URI * - Headers * - Message body * * Additionally, it encapsulates all data as it has arrived at the * application from the CGI and/or PHP environment, including: * * - The values represented in $_SERVER. * - Any cookies provided (generally via $_COOKIE) * - Query string arguments (generally via $_GET, or as parsed via parse_str()) * - Upload files, if any (as represented by $_FILES) * - Deserialized body parameters (generally from $_POST) * * $_SERVER values MUST be treated as immutable, as they represent application * state at the time of request; as such, no methods are provided to allow * modification of those values. The other values provide such methods, as they * can be restored from $_SERVER or the request body, and may need treatment * during the application (e.g., body parameters may be deserialized based on * content type). * * Additionally, this interface recognizes the utility of introspecting a * request to derive and match additional parameters (e.g., via URI path * matching, decrypting cookie values, deserializing non-form-encoded body * content, matching authorization headers to users, etc). These parameters * are stored in an \u0026#34;attributes\u0026#34; property. * * Requests are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface ServerRequestInterface extends RequestInterface { /** * Retrieve server parameters. * * Retrieves data related to the incoming request environment, * typically derived from PHP\u0026#39;s $_SERVER superglobal. The data IS NOT * REQUIRED to originate from $_SERVER. * * @return array */ public function getServerParams(); /** * Retrieve cookies. * * Retrieves cookies sent by the client to the server. * * The data MUST be compatible with the structure of the $_COOKIE * superglobal. * * @return array */ public function getCookieParams(); /** * Return an instance with the specified cookies. * * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST * be compatible with the structure of $_COOKIE. Typically, this data will * be injected at instantiation. * * This method MUST NOT update the related Cookie header of the request * instance, nor related values in the server params. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated cookie values. * * @param array $cookies Array of key/value pairs representing cookies. * @return static */ public function withCookieParams(array $cookies); /** * Retrieve query string arguments. * * Retrieves the deserialized query string arguments, if any. * * Note: the query params might not be in sync with the URI or server * params. If you need to ensure you are only getting the original * values, you may need to parse the query string from `getUri()-\u0026gt;getQuery()` * or from the `QUERY_STRING` server param. * * @return array */ public function getQueryParams(); /** * Return an instance with the specified query string arguments. * * These values SHOULD remain immutable over the course of the incoming * request. They MAY be injected during instantiation, such as from PHP\u0026#39;s * $_GET superglobal, or MAY be derived from some other value such as the * URI. In cases where the arguments are parsed from the URI, the data * MUST be compatible with what PHP\u0026#39;s parse_str() would return for * purposes of how duplicate query parameters are handled, and how nested * sets are handled. * * Setting query string arguments MUST NOT change the URI stored by the * request, nor the values in the server params. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated query string arguments. * * @param array $query Array of query string arguments, typically from * $_GET. * @return static */ public function withQueryParams(array $query); /** * Retrieve normalized file upload data. * * This method returns upload metadata in a normalized tree, with each leaf * an instance of Psr\\Http\\Message\\UploadedFileInterface. * * These values MAY be prepared from $_FILES or the message body during * instantiation, or MAY be injected via withUploadedFiles(). * * @return array An array tree of UploadedFileInterface instances; an empty * array MUST be returned if no data is present. */ public function getUploadedFiles(); /** * Create a new instance with the specified uploaded files. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated body parameters. * * @param array $uploadedFiles An array tree of UploadedFileInterface instances. * @return static * @throws \\InvalidArgumentException if an invalid structure is provided. */ public function withUploadedFiles(array $uploadedFiles); /** * Retrieve any parameters provided in the request body. * * If the request Content-Type is either application/x-www-form-urlencoded * or multipart/form-data, and the request method is POST, this method MUST * return the contents of $_POST. * * Otherwise, this method may return any results of deserializing * the request body content; as parsing returns structured content, the * potential types MUST be arrays or objects only. A null value indicates * the absence of body content. * * @return null|array|object The deserialized body parameters, if any. * These will typically be an array or object. */ public function getParsedBody(); /** * Return an instance with the specified body parameters. * * These MAY be injected during instantiation. * * If the request Content-Type is either application/x-www-form-urlencoded * or multipart/form-data, and the request method is POST, use this method * ONLY to inject the contents of $_POST. * * The data IS NOT REQUIRED to come from $_POST, but MUST be the results of * deserializing the request body content. Deserialization/parsing returns * structured data, and, as such, this method ONLY accepts arrays or objects, * or a null value if nothing was available to parse. * * As an example, if content negotiation determines that the request data * is a JSON payload, this method could be used to create a request * instance with the deserialized parameters. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated body parameters. * * @param null|array|object $data The deserialized body data. This will * typically be in an array or object. * @return static * @throws \\InvalidArgumentException if an unsupported argument type is * provided. */ public function withParsedBody($data); /** * Retrieve attributes derived from the request. * * The request \u0026#34;attributes\u0026#34; may be used to allow injection of any * parameters derived from the request: e.g., the results of path * match operations; the results of decrypting cookies; the results of * deserializing non-form-encoded message bodies; etc. Attributes * will be application and request specific, and CAN be mutable. * * @return mixed[] Attributes derived from the request. */ public function getAttributes(); /** * Retrieve a single derived request attribute. * * Retrieves a single derived request attribute as described in * getAttributes(). If the attribute has not been previously set, returns * the default value as provided. * * This method obviates the need for a hasAttribute() method, as it allows * specifying a default value to return if the attribute is not found. * * @see getAttributes() * @param string $name The attribute name. * @param mixed $default Default value to return if the attribute does not exist. * @return mixed */ public function getAttribute($name, $default = null); /** * Return an instance with the specified derived request attribute. * * This method allows setting a single derived request attribute as * described in getAttributes(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated attribute. * * @see getAttributes() * @param string $name The attribute name. * @param mixed $value The value of the attribute. * @return static */ public function withAttribute($name, $value); /** * Return an instance that removes the specified derived request attribute. * * This method allows removing a single derived request attribute as * described in getAttributes(). * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that removes * the attribute. * * @see getAttributes() * @param string $name The attribute name. * @return static */ public function withoutAttribute($name); } 3.3 Psr\\Http\\Message\\ResponseInterface #  \u0026lt;?php namespace Psr\\Http\\Message; /** * Representation of an outgoing, server-side response. * * Per the HTTP specification, this interface includes properties for * each of the following: * * - Protocol version * - Status code and reason phrase * - Headers * - Message body * * Responses are considered immutable; all methods that might change state MUST * be implemented such that they retain the internal state of the current * message and return an instance that contains the changed state. */ interface ResponseInterface extends MessageInterface { /** * Gets the response status code. * * The status code is a 3-digit integer result code of the server\u0026#39;s attempt * to understand and satisfy the request. * * @return int Status code. */ public function getStatusCode(); /** * Return an instance with the specified status code and, optionally, reason phrase. * * If no reason phrase is specified, implementations MAY choose to default * to the RFC 7231 or IANA recommended reason phrase for the response\u0026#39;s * status code. * * This method MUST be implemented in such a way as to retain the * immutability of the message, and MUST return an instance that has the * updated status and reason phrase. * * @see http://tools.ietf.org/html/rfc7231#section-6 * @see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml * @param int $code The 3-digit integer result code to set. * @param string $reasonPhrase The reason phrase to use with the * provided status code; if none is provided, implementations MAY * use the defaults as suggested in the HTTP specification. * @return static * @throws \\InvalidArgumentException For invalid status code arguments. */ public function withStatus($code, $reasonPhrase = \u0026#39;\u0026#39;); /** * Gets the response reason phrase associated with the status code. * * Because a reason phrase is not a required element in a response * status line, the reason phrase value MAY be empty. Implementations MAY * choose to return the default RFC 7231 recommended reason phrase (or those * listed in the IANA HTTP Status Code Registry) for the response\u0026#39;s * status code. * * @see http://tools.ietf.org/html/rfc7231#section-6 * @see http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml * @return string Reason phrase; must return an empty string if none present. */ public function getReasonPhrase(); } 3.4 Psr\\Http\\Message\\StreamInterface #  \u0026lt;?php namespace Psr\\Http\\Message; /** * Describes a data stream. * * Typically, an instance will wrap a PHP stream; this interface provides * a wrapper around the most common operations, including serialization of * the entire stream to a string. */ interface StreamInterface { /** * Reads all data from the stream into a string, from the beginning to end. * * This method MUST attempt to seek to the beginning of the stream before * reading data and read the stream until the end is reached. * * Warning: This could attempt to load a large amount of data into memory. * * This method MUST NOT raise an exception in order to conform with PHP\u0026#39;s * string casting operations. * * @see http://php.net/manual/en/language.oop5.magic.php#object.tostring * @return string */ public function __toString(); /** * Closes the stream and any underlying resources. * * @return void */ public function close(); /** * Separates any underlying resources from the stream. * * After the stream has been detached, the stream is in an unusable state. * * @return resource|null Underlying PHP stream, if any */ public function detach(); /** * Get the size of the stream if known. * * @return int|null Returns the size in bytes if known, or null if unknown. */ public function getSize(); /** * Returns the current position of the file read/write pointer * * @return int Position of the file pointer * @throws \\RuntimeException on error. */ public function tell(); /** * Returns true if the stream is at the end of the stream. * * @return bool */ public function eof(); /** * Returns whether or not the stream is seekable. * * @return bool */ public function isSeekable(); /** * Seek to a position in the stream. * * @see http://www.php.net/manual/en/function.fseek.php * @param int $offset Stream offset * @param int $whence Specifies how the cursor position will be calculated * based on the seek offset. Valid values are identical to the built-in * PHP $whence values for `fseek()`. SEEK_SET: Set position equal to * offset bytes SEEK_CUR: Set position to current location plus offset * SEEK_END: Set position to end-of-stream plus offset. * @throws \\RuntimeException on failure. */ public function seek($offset, $whence = SEEK_SET); /** * Seek to the beginning of the stream. * * If the stream is not seekable, this method will raise an exception; * otherwise, it will perform a seek(0). * * @see seek() * @see http://www.php.net/manual/en/function.fseek.php * @throws \\RuntimeException on failure. */ public function rewind(); /** * Returns whether or not the stream is writable. * * @return bool */ public function isWritable(); /** * Write data to the stream. * * @param string $string The string that is to be written. * @return int Returns the number of bytes written to the stream. * @throws \\RuntimeException on failure. */ public function write($string); /** * Returns whether or not the stream is readable. * * @return bool */ public function isReadable(); /** * Read data from the stream. * * @param int $length Read up to $length bytes from the object and return * them. Fewer than $length bytes may be returned if underlying stream * call returns fewer bytes. * @return string Returns the data read from the stream, or an empty string * if no bytes are available. * @throws \\RuntimeException if an error occurs. */ public function read($length); /** * Returns the remaining contents in a string * * @return string * @throws \\RuntimeException if unable to read. * @throws \\RuntimeException if error occurs while reading. */ public function getContents(); /** * Get stream metadata as an associative array or retrieve a specific key. * * The keys returned are identical to the keys returned from PHP\u0026#39;s * stream_get_meta_data() function. * * @see http://php.net/manual/en/function.stream-get-meta-data.php * @param string $key Specific metadata to retrieve. * @return array|mixed|null Returns an associative array if no key is * provided. Returns a specific key value if a key is provided and the * value is found, or null if the key is not found. */ public function getMetadata($key = null); } 3.5 Psr\\Http\\Message\\UriInterface #  \u0026lt;?php namespace Psr\\Http\\Message; /** * Value object representing a URI. * * This interface is meant to represent URIs according to RFC 3986 and to * provide methods for most common operations. Additional functionality for * working with URIs can be provided on top of the interface or externally. * Its primary use is for HTTP requests, but may also be used in other * contexts. * * Instances of this interface are considered immutable; all methods that * might change state MUST be implemented such that they retain the internal * state of the current instance and return an instance that contains the * changed state. * * Typically the Host header will also be present in the request message. * For server-side requests, the scheme will typically be discoverable in the * server parameters. * * @see http://tools.ietf.org/html/rfc3986 (the URI specification) */ interface UriInterface { /** * Retrieve the scheme component of the URI. * * If no scheme is present, this method MUST return an empty string. * * The value returned MUST be normalized to lowercase, per RFC 3986 * Section 3.1. * * The trailing \u0026#34;:\u0026#34; character is not part of the scheme and MUST NOT be * added. * * @see https://tools.ietf.org/html/rfc3986#section-3.1 * @return string The URI scheme. */ public function getScheme(); /** * Retrieve the authority component of the URI. * * If no authority information is present, this method MUST return an empty * string. * * The authority syntax of the URI is: * * \u0026lt;pre\u0026gt; * [user-info@]host[:port] * \u0026lt;/pre\u0026gt; * * If the port component is not set or is the standard port for the current * scheme, it SHOULD NOT be included. * * @see https://tools.ietf.org/html/rfc3986#section-3.2 * @return string The URI authority, in \u0026#34;[user-info@]host[:port]\u0026#34; format. */ public function getAuthority(); /** * Retrieve the user information component of the URI. * * If no user information is present, this method MUST return an empty * string. * * If a user is present in the URI, this will return that value; * additionally, if the password is also present, it will be appended to the * user value, with a colon (\u0026#34;:\u0026#34;) separating the values. * * The trailing \u0026#34;@\u0026#34; character is not part of the user information and MUST * NOT be added. * * @return string The URI user information, in \u0026#34;username[:password]\u0026#34; format. */ public function getUserInfo(); /** * Retrieve the host component of the URI. * * If no host is present, this method MUST return an empty string. * * The value returned MUST be normalized to lowercase, per RFC 3986 * Section 3.2.2. * * @see http://tools.ietf.org/html/rfc3986#section-3.2.2 * @return string The URI host. */ public function getHost(); /** * Retrieve the port component of the URI. * * If a port is present, and it is non-standard for the current scheme, * this method MUST return it as an integer. If the port is the standard port * used with the current scheme, this method SHOULD return null. * * If no port is present, and no scheme is present, this method MUST return * a null value. * * If no port is present, but a scheme is present, this method MAY return * the standard port for that scheme, but SHOULD return null. * * @return null|int The URI port. */ public function getPort(); /** * Retrieve the path component of the URI. * * The path can either be empty or absolute (starting with a slash) or * rootless (not starting with a slash). Implementations MUST support all * three syntaxes. * * Normally, the empty path \u0026#34;\u0026#34; and absolute path \u0026#34;/\u0026#34; are considered equal as * defined in RFC 7230 Section 2.7.3. But this method MUST NOT automatically * do this normalization because in contexts with a trimmed base path, e.g. * the front controller, this difference becomes significant. It\u0026#39;s the task * of the user to handle both \u0026#34;\u0026#34; and \u0026#34;/\u0026#34;. * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.3. * * As an example, if the value should include a slash (\u0026#34;/\u0026#34;) not intended as * delimiter between path segments, that value MUST be passed in encoded * form (e.g., \u0026#34;%2F\u0026#34;) to the instance. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.3 * @return string The URI path. */ public function getPath(); /** * Retrieve the query string of the URI. * * If no query string is present, this method MUST return an empty string. * * The leading \u0026#34;?\u0026#34; character is not part of the query and MUST NOT be * added. * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.4. * * As an example, if a value in a key/value pair of the query string should * include an ampersand (\u0026#34;\u0026amp;\u0026#34;) not intended as a delimiter between values, * that value MUST be passed in encoded form (e.g., \u0026#34;%26\u0026#34;) to the instance. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.4 * @return string The URI query string. */ public function getQuery(); /** * Retrieve the fragment component of the URI. * * If no fragment is present, this method MUST return an empty string. * * The leading \u0026#34;#\u0026#34; character is not part of the fragment and MUST NOT be * added. * * The value returned MUST be percent-encoded, but MUST NOT double-encode * any characters. To determine what characters to encode, please refer to * RFC 3986, Sections 2 and 3.5. * * @see https://tools.ietf.org/html/rfc3986#section-2 * @see https://tools.ietf.org/html/rfc3986#section-3.5 * @return string The URI fragment. */ public function getFragment(); /** * Return an instance with the specified scheme. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified scheme. * * Implementations MUST support the schemes \u0026#34;http\u0026#34; and \u0026#34;https\u0026#34; case * insensitively, and MAY accommodate other schemes if required. * * An empty scheme is equivalent to removing the scheme. * * @param string $scheme The scheme to use with the new instance. * @return static A new instance with the specified scheme. * @throws \\InvalidArgumentException for invalid schemes. * @throws \\InvalidArgumentException for unsupported schemes. */ public function withScheme($scheme); /** * Return an instance with the specified user information. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified user information. * * Password is optional, but the user information MUST include the * user; an empty string for the user is equivalent to removing user * information. * * @param string $user The user name to use for authority. * @param null|string $password The password associated with $user. * @return static A new instance with the specified user information. */ public function withUserInfo($user, $password = null); /** * Return an instance with the specified host. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified host. * * An empty host value is equivalent to removing the host. * * @param string $host The hostname to use with the new instance. * @return static A new instance with the specified host. * @throws \\InvalidArgumentException for invalid hostnames. */ public function withHost($host); /** * Return an instance with the specified port. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified port. * * Implementations MUST raise an exception for ports outside the * established TCP and UDP port ranges. * * A null value provided for the port is equivalent to removing the port * information. * * @param null|int $port The port to use with the new instance; a null value * removes the port information. * @return static A new instance with the specified port. * @throws \\InvalidArgumentException for invalid ports. */ public function withPort($port); /** * Return an instance with the specified path. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified path. * * The path can either be empty or absolute (starting with a slash) or * rootless (not starting with a slash). Implementations MUST support all * three syntaxes. * * If an HTTP path is intended to be host-relative rather than path-relative * then it must begin with a slash (\u0026#34;/\u0026#34;). HTTP paths not starting with a slash * are assumed to be relative to some base path known to the application or * consumer. * * Users can provide both encoded and decoded path characters. * Implementations ensure the correct encoding as outlined in getPath(). * * @param string $path The path to use with the new instance. * @return static A new instance with the specified path. * @throws \\InvalidArgumentException for invalid paths. */ public function withPath($path); /** * Return an instance with the specified query string. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified query string. * * Users can provide both encoded and decoded query characters. * Implementations ensure the correct encoding as outlined in getQuery(). * * An empty query string value is equivalent to removing the query string. * * @param string $query The query string to use with the new instance. * @return static A new instance with the specified query string. * @throws \\InvalidArgumentException for invalid query strings. */ public function withQuery($query); /** * Return an instance with the specified URI fragment. * * This method MUST retain the state of the current instance, and return * an instance that contains the specified URI fragment. * * Users can provide both encoded and decoded fragment characters. * Implementations ensure the correct encoding as outlined in getFragment(). * * An empty fragment value is equivalent to removing the fragment. * * @param string $fragment The fragment to use with the new instance. * @return static A new instance with the specified fragment. */ public function withFragment($fragment); /** * Return the string representation as a URI reference. * * Depending on which components of the URI are present, the resulting * string is either a full URI or relative reference according to RFC 3986, * Section 4.1. The method concatenates the various components of the URI, * using the appropriate delimiters: * * - If a scheme is present, it MUST be suffixed by \u0026#34;:\u0026#34;. * - If an authority is present, it MUST be prefixed by \u0026#34;//\u0026#34;. * - The path can be concatenated without delimiters. But there are two * cases where the path has to be adjusted to make the URI reference * valid as PHP does not allow to throw an exception in __toString(): * - If the path is rootless and an authority is present, the path MUST * be prefixed by \u0026#34;/\u0026#34;. * - If the path is starting with more than one \u0026#34;/\u0026#34; and no authority is * present, the starting slashes MUST be reduced to one. * - If a query is present, it MUST be prefixed by \u0026#34;?\u0026#34;. * - If a fragment is present, it MUST be prefixed by \u0026#34;#\u0026#34;. * * @see http://tools.ietf.org/html/rfc3986#section-4.1 * @return string */ public function __toString(); } 3.6 Psr\\Http\\Message\\UploadedFileInterface #  \u0026lt;?php namespace Psr\\Http\\Message; /** * Value object representing a file uploaded through an HTTP request. * * Instances of this interface are considered immutable; all methods that * might change state MUST be implemented such that they retain the internal * state of the current instance and return an instance that contains the * changed state. */ interface UploadedFileInterface { /** * Retrieve a stream representing the uploaded file. * * This method MUST return a StreamInterface instance, representing the * uploaded file. The purpose of this method is to allow utilizing native PHP * stream functionality to manipulate the file upload, such as * stream_copy_to_stream() (though the result will need to be decorated in a * native PHP stream wrapper to work with such functions). * * If the moveTo() method has been called previously, this method MUST raise * an exception. * * @return StreamInterface Stream representation of the uploaded file. * @throws \\RuntimeException in cases when no stream is available. * @throws \\RuntimeException in cases when no stream can be created. */ public function getStream(); /** * Move the uploaded file to a new location. * * Use this method as an alternative to move_uploaded_file(). This method is * guaranteed to work in both SAPI and non-SAPI environments. * Implementations must determine which environment they are in, and use the * appropriate method (move_uploaded_file(), rename(), or a stream * operation) to perform the operation. * * $targetPath may be an absolute path, or a relative path. If it is a * relative path, resolution should be the same as used by PHP\u0026#39;s rename() * function. * * The original file or stream MUST be removed on completion. * * If this method is called more than once, any subsequent calls MUST raise * an exception. * * When used in an SAPI environment where $_FILES is populated, when writing * files via moveTo(), is_uploaded_file() and move_uploaded_file() SHOULD be * used to ensure permissions and upload status are verified correctly. * * If you wish to move to a stream, use getStream(), as SAPI operations * cannot guarantee writing to stream destinations. * * @see http://php.net/is_uploaded_file * @see http://php.net/move_uploaded_file * @param string $targetPath Path to which to move the uploaded file. * @throws \\InvalidArgumentException if the $targetPath specified is invalid. * @throws \\RuntimeException on any error during the move operation. * @throws \\RuntimeException on the second or subsequent call to the method. */ public function moveTo($targetPath); /** * Retrieve the file size. * * Implementations SHOULD return the value stored in the \u0026#34;size\u0026#34; key of * the file in the $_FILES array if available, as PHP calculates this based * on the actual size transmitted. * * @return int|null The file size in bytes or null if unknown. */ public function getSize(); /** * Retrieve the error associated with the uploaded file. * * The return value MUST be one of PHP\u0026#39;s UPLOAD_ERR_XXX constants. * * If the file was uploaded successfully, this method MUST return * UPLOAD_ERR_OK. * * Implementations SHOULD return the value stored in the \u0026#34;error\u0026#34; key of * the file in the $_FILES array. * * @see http://php.net/manual/en/features.file-upload.errors.php * @return int One of PHP\u0026#39;s UPLOAD_ERR_XXX constants. */ public function getError(); /** * Retrieve the filename sent by the client. * * Do not trust the value returned by this method. A client could send * a malicious filename with the intention to corrupt or hack your * application. * * Implementations SHOULD return the value stored in the \u0026#34;name\u0026#34; key of * the file in the $_FILES array. * * @return string|null The filename sent by the client or null if none * was provided. */ public function getClientFilename(); /** * Retrieve the media type sent by the client. * * Do not trust the value returned by this method. A client could send * a malicious media type with the intention to corrupt or hack your * application. * * Implementations SHOULD return the value stored in the \u0026#34;type\u0026#34; key of * the file in the $_FILES array. * * @return string|null The media type sent by the client or null if none * was provided. */ public function getClientMediaType(); } "});index.add({'id':9,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/07-psr-11/','title':"07 P S R 11",'section':"Php",'content':"Container interface #  이 문서는 의존성 주입 컨테이너에 대한 공통 인터페이스를 설명합니다.\nContainerInterface에 의해 설정된 목표는 프레임 워크와 라이브러리가 컨테이너를 사용하여 객체와 매개 변수 (이 문서의 나머지 부분에서 항목이라고 함)를 얻는 방법을 표준화하는 것입니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n이 문서에서 implementor 라는 단어는 의존성 삽입 관련 라이브러리나 프레임워크에서 ContainerInterface를 구현하는 누군가로 해석되어야합니다. 의존성 주입 컨테이너 (DIC)의 사용자는 사용자라고합니다.\n1. 명세서 #  1.1 기본 #  1.1.1 엔트리 식별자 #  엔트리 식별자는 컨테이너 내의 항목을 고유하게 식별하는 적어도 하나의 문자로 구성된 PHP에서 유효한 문자열입니다. 엔트리 식별자는 불투명 한 문자열이므로 호출자는 문자열의 구조가 의미를 전달한다고 가정해서는 안됩니다(SHOULD NOT).\n1.1.2 컨테이너에서 읽어오기 #    Psr\\Container\\ContainerInterface는 get과 has 두가지 메서드를 제공합니다.\n  get 은 하나의 필수 매개 변수를 가집니다. 엔트리 식별자는 반드시 문자열이어야 합니다 (MUST). get 은 어떤 값이든 (하나의 mixed 값) 반환 할 수 있고 식별자가 컨테이너에 알려지지 않은 경우에는 NotFoundExceptionInterface 예외를 던집니다. 동일한 식별자를 가진 get 에 대한 두 번의 연속적인 호출은 동일한 값을 반환해야합니다 (SHOULD). 그러나 implementor 디자인 또는 user 설정에 따라 다른 값들이 반환 될 수 있습니다. 그래서 user는 2번의 연속적인 호출에서 같은 값을 얻는 것에 의존하지 않아야합니다 (SHOULD NOT).\n  has 는 하나의 고유 한 매개 변수를 가집니다. 엔트리 식별자는 반드시 문자열이어야 합니다(MUST). has 는 엔트리 식별자가 컨테이너에 알려지면 true 를 리턴하고 그렇지 않으면 false 를 리턴해야합니다 (MUST). has($id) 가 false 를 반환하면 get($id) 는 NotFoundExceptionInterface 예외를 던져야합니다.\n  1.2 Exceptions #  컨테이너에 의해 직접 던져진 예외는 Psr\\Container\\ContainerExceptionInterface을 상속해야한다(SHOULD).\n존재하지 않는 id를 가진 get 메서드에 대한 호출은 Psr\\Container\\NotFoundExceptionInterface 예외를 던져야 한다(MUST).\n1.3 권장 사용법 #  사용자는 객체가 자신의 의존성을 검색 할 수 있도록 컨테이너에 객체를 넘겨서는 안됩니다(SHOULD NOT). 즉, 컨테이너는 Service Locator로 사용됩니다. 이런 행동은 일반적으로 방해가 됩니다\n자세한 내용은 META 문서의 섹션 4를 참조하십시오.\n2. Package #  설명한 인터페이스와 클래스 및 예외 사항은 psr/container 패키지의 일부로 제공됩니다.\nPSR 컨테이너 구현체를 제공하는 패키지는 psr/container-implementation 을 제공한다고 선언해야합니다.\n구현이 필요한 프로젝트에는 psr/container-implementation의 1.0.0 을 요구합니다.\n3. Interfaces #  3.1. Psr\\Container\\ContainerInterface #  \u0026lt;?php namespace Psr\\Container; /** * Describes the interface of a container that exposes methods to read its entries. */ interface ContainerInterface { /** * Finds an entry of the container by its identifier and returns it. * * @param string $id Identifier of the entry to look for. * * @throws NotFoundExceptionInterface No entry was found for **this** identifier. * @throws ContainerExceptionInterface Error while retrieving the entry. * * @return mixed Entry. */ public function get($id); /** * Returns true if the container can return an entry for the given identifier. * Returns false otherwise. * * `has($id)` returning true does not mean that `get($id)` will not throw an exception. * It does however mean that `get($id)` will not throw a `NotFoundExceptionInterface`. * * @param string $id Identifier of the entry to look for. * * @return bool */ public function has($id); } 3.2. Psr\\Container\\ContainerExceptionInterface #  \u0026lt;?php namespace Psr\\Container; /** * Base interface representing a generic exception in a container. */ interface ContainerExceptionInterface { } 3.3. Psr\\Container\\NotFoundExceptionInterface #  \u0026lt;?php namespace Psr\\Container; /** * No entry was found in the container. */ interface NotFoundExceptionInterface extends ContainerExceptionInterface { } "});index.add({'id':10,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/08-psr-12/','title':"08 P S R 12",'section':"Php",'content':"Extended Coding Style Guide #  이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n개요 #  이 규칙은 코딩 스타일 가이드인 PSR-2를 확장 및 대체하며, 기본 코딩 표준 인 PSR-1을 준수해야합니다.\nPSR-2와 마찬가지로 이 사양의 목적은 다른 작성자의 코드를 읽을 때 이해하기 어려운 것을 줄이는 것입니다. 이것은 PHP 코드의 형식을 지정하는 방법에 대한 규칙과 기대 사항을 공유하여 열거합니다. 이 PSR은 코딩 스타일 도구가 구현할 수 있는 설정 방법을 제공하기 위해 노력하고, 프로젝트에서 이 PSR의 준수를 선언함을 통해 개발자는 서로 다른 프로젝트와 쉽게 연동 할 수 있습니다. 다양한 저자가 여러 프로젝트에서 협업을 할 때, 모든 프로젝트에서 한가지의 가이드라인을 사용하는 것이 도움이 됩니다. 따라서 이 가이드로 얻는 혜택은 규칙 자체가 아니라 이러한 규칙을 공유하는 것을 통해 얻을 수 있습니다.\nPSR-2는 2012 년에 승인되었으며 그 이후로 PHP에 많은 발전이 있었으므로 코딩 스타일 지침에 영향을 미쳤습니다. PSR-2는 문서 작성 당시 존재했던 PHP 기능은 대부분 포함하고 있지만, 새로운 기능들은 매우 다양하게 해석 될 수 있습니다. 따라서 이 PSR은 새로운 기능을 사용하여 보다 현대적인 관점에서 PSR-2의 내용을 명확하게 하고 PSR-2에 관한 오류의 개정본을 만듭니다.\n이전 버전 #  이 문서 전체의 내용 중, 프로젝트에서 사용하는 PHP 버전에 없는 지침은 무시할 수 있습니다 (MAY).\n예제 #  이 예제는 아래의 규칙 중 일부를 간략하게 설명합니다.\n\u0026lt;?php declare(strict_types=1); namespace Vendor\\Package; use Vendor\\Package\\{ClassA as A, ClassB, ClassC as C}; use Vendor\\Package\\SomeNamespace\\ClassD as D; use function Vendor\\Package\\{functionA, functionB, functionC}; use const Vendor\\Package\\{ConstantA, ConstantB, ConstantC}; class Foo extends Bar implements FooInterface { public function sampleFunction(int $a, int $b = null): array { if ($a === $b) { bar(); } elseif ($a \u0026gt; $b) { $foo-\u0026gt;bar($arg1); } else { BazClass::bar($arg2, $arg3); } } final public static function bar() { // method body  } } 2. 일반 #  2.1 기본 코딩 표준 #  코드는 PSR-1에 요약 된 모든 규칙을 따라야합니다.\nPSR-1의 \u0026lsquo;StudlyCaps\u0026lsquo;라는 용어는 PascalCase로 해석해야하며(MUST) 첫 단어가 첫 문자를 포함하여 대문자로 표시해야합니다.\n2.2 Files #  모든 PHP 파일은 Unix LF (linefeed) 줄만 사용해야합니다 (MUST).\n모든 PHP 파일은 단일 LF로 끝나는 비어 있지 않은 라인으로 끝나야합니다 (MUST).\nPHP code만 존재하는 파일에서는 닫는 ?\u0026gt;태그를 생략해야합니다 (MUST).\n2.3 Lines #  라인 길이에 엄격한 제한이 있어서는 안됩니다(MUST NOT).\n한줄에 들어가는 글자수에 대한 가벼운 제한은 120자여야 합니다. (MUST).\n한줄은 80자를 넘지 않아야합니다 (SHOULD NOT). 그보다 긴 줄은 각각 80자 이하의 여러 줄으로 나눠야합니다 (SHOULD).\nHEREDOC/NOWDOC 구문을 제외하고 줄의 끝에 공백이 있으면 안됩니다(MUST NOT).\n명시적으로 금지 된 경우를 제외하고 가독성을 높이고 관련 코드 블록을 표시하기 위해 빈 줄을 추가 할 수 있습니다 (MAY).\n한 줄에 하나 이상의 문장이 있어서는 안됩니다 (MUST NOT).\n2.4 들여쓰기 #  코드는 4개의 스페이스로 들여쓰기를 사용해야만하며(MUST), 탭을 사용하지 않아야만 합니다 (MUST NOT).\n2.5 Keyword와 Type #  모든 PHP 예약 키워드와 타입 [1][2]은 소문자 여야만합니다 (MUST).\n향후 PHP 버전에 추가되는 모든 새로운 유형과 키워드는 반드시 소문자 여야만합니다 (MUST).\n반드시 boolean 대신 bool, integer 대신 int 등 짧은 형태의 타입 키워드를 사용해야합니다 (MUST).\n3. Declare 선언문, 네임 스페이스 및 Import 선언문 #  PHP 파일의 머릿글은 여러 블록으로 구성 될 수 있습니다. 이미 존재한다면, 아래의 각 블록은 하나의 빈 행으로 분리해야하며 빈 행을 포함해서는 안됩니다 (MUST NOT). 관련이 없는 블록은 생략 할 수 있지만(MUST) 각 블록은 아래에 나열된 순서여야 합니다.\n \u0026lt;?php로 태그 열기. 파일 수준의 docblock. 하나 이상의 declare 선언문. 파일의 네임 스페이스 선언. 하나 이상의 클래스 기반 use import 문. 하나 이상의 함수 기반 use import 문. 하나 이상의 상수 기반 use import 문. 파일의 나머지 코드.  파일에 HTML과 PHP가 섞여 있다면 위 섹션 중 하나라도 여전히 사용할 수 있습니다. 그럴땐 파일의 최상단에는 declare 문이 있어야 하며 (MUST), 나머지 부분은 닫는 PHP 태그와 HTML과 PHP가 섞인 코드가 있어야합니다.\n열기 태그 \u0026lt;?php가 파일의 첫 번째 줄에 있을 때, PHP 열기 및 닫기 태그 외부에 마크업을 포함하는 파일이 아니라면 다른 문장이 없는 자체 라인 상에 있어야 합니다(MUST). 역자주: 설명이 어려우니 그냥 아래에 나오는 예제를 참고하세요\nImport 문은 항상 정규화된 형식이어야 하므로 백 슬래시로 시작해서는 안됩니다 (MUST).\n다음은 모든 블록의 전체 목록의 예제를 보여줍니다.\n\u0026lt;?php /** * This file contains an example of coding styles. */ declare(strict_types=1); namespace Vendor\\Package; use Vendor\\Package\\{ClassA as A, ClassB, ClassC as C}; use Vendor\\Package\\SomeNamespace\\ClassD as D; use Vendor\\Package\\AnotherNamespace\\ClassE as E; use function Vendor\\Package\\{functionA, functionB, functionC}; use function Another\\Vendor\\functionD; use const Vendor\\Package\\{CONSTANT_A, CONSTANT_B, CONSTANT_C}; use const Another\\Vendor\\CONSTANT_D; /** * FooBar is an example class. */ class FooBar { // ... additional PHP code ... } 두 단계 이상의 복합 네임 스페이스는 사용해서는 안됩니다 (MUST NOT). 그러므로 허용하는 최대 복합 단계는 다음과 같습니다.\n\u0026lt;?php use Vendor\\Package\\SomeNamespace\\{ SubnamespaceOne\\ClassA, SubnamespaceOne\\ClassB, SubnamespaceTwo\\ClassY, ClassZ, }; 그리고 다음은 허용되지 않습니다(MUST NOT).\n\u0026lt;?php use Vendor\\Package\\SomeNamespace\\{ SubnamespaceOne\\AnotherNamespace\\ClassA, SubnamespaceOne\\ClassB, ClassZ, }; PHP를 열고 닫는 태그 외부에서 마크 업을 포함하는 파일에 엄격한 유형을 선언하고자 할 때, 선언문은 파일의 첫 번째 줄에 있어야하며 (MUST), 여는 PHP 태그와 strict types 선언과 닫는 태그를 포함해야합니다.\n예 :\n\u0026lt;?php declare(strict_types=1) ?\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;?php // ... additional PHP code ...  ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Declare 문은 공백을 포함하지 않아야하며(MUST) declare(strict_types=1) (선택 항목 인 세미콜론 종결자 포함)이어야합니다(MUST).\n블록 선언문은 허용되며 반드시 아래와 같은 형식이여야합니다(MUST). 중괄호와 간격의 위치 참고 :\ndeclare(ticks=1) { // some code } 4. 클래스, 프로퍼티, 메소드 #  \u0026ldquo;클래스\u0026quot;라는 용어는 모든 클래스, 인터페이스 및 특성-trait을 나타냅니다.\n닫는 중괄호는 같은 줄의 주석이나 명령문 다음에 와서는 안됩니다(MUST NOT).\n새 클래스를 인스턴스화 할 때 생성자에 전달 된 인수가 없는 경우에도 항상 괄호가 있어야합니다(MUST). 역자주 : new Foo; 같은걸 하지 말라는 의미\nnew Foo(); 4.1 확장과 구현 #  extends와 implements 키워드는 클래스 이름과 같은 줄에 선언해야합니다 (MUST).\n해당 클래스의 여는 중괄호는 같은 줄에 있어야합니다(MUST). 클래스의 닫는 중괄호는 본문 뒤의 다음 줄로 가야합니다(MUST).\n여는 중괄호는 반드시(MUST) 같은 줄에 있어야하며 앞에 빈 줄을 붙여서는 안됩니다.\n닫는 중괄호는 반드시(MUST) 같은 줄에 있어야하며 빈 줄을 앞에 두어서는 안됩니다(MUST NOT).\n\u0026lt;?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable { // constants, properties, methods } implements의 목록과 인터페이스의 경우, extends는 여러 줄에 걸쳐 나뉘어 질 수 있으며(MAY), 각 줄은 한 번의 들여쓰기를 합니다. 그렇게 할 때 목록의 첫 번째 항목은 다음 줄에 있어야하며 한 줄에 하나의 인터페이스만 있어야합니다.\n\u0026lt;?php namespace Vendor\\Package; use FooClass; use BarClass as Bar; use OtherVendor\\OtherPackage\\BazClass; class ClassName extends ParentClass implements \\ArrayAccess, \\Countable, \\Serializable { // constants, properties, methods } 4.2 특성-trait 사용 #  특성-trait을 구현하기 위해 클래스 내에서 사용되는 use 키워드는 클래스를 여는 중괄호 다음 줄에 선언해야합니다 (MUST).\n\u0026lt;?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; } 클래스로 가져온 각각의 특성-trait은 반드시 한 줄에 하나씩 포함해야하며(MUST), 각 포함내역은 반드시 고유한 use import 문을 가져야합니다 (MUST).\n\u0026lt;?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; use Vendor\\Package\\SecondTrait; use Vendor\\Package\\ThirdTrait; class ClassName { use FirstTrait; use SecondTrait; use ThirdTrait; } 클래스에 use import 문 다음에 아무것도 없는 경우, 클래스를 닫는 중괄호는 마지막 use import 문 다음에 있어야합니다 (MUST).\n\u0026lt;?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; } 그렇지 않으면 마지막 use import 문 다음에 빈 줄이 있어야합니다(MUST).\n\u0026lt;?php namespace Vendor\\Package; use Vendor\\Package\\FirstTrait; class ClassName { use FirstTrait; private $property; } insteadof 와 as연산자를 사용할 때는 들여쓰기, 간격 및 새 줄을 반드시(MUST) 다음과 같이 사용해야합니다.\n\u0026lt;?php class Talker { use A, B, C { B::smallTalk insteadof A; A::bigTalk insteadof C; C::mediumTalk as FooBar; } } 4.3 속성-property 과 상수-constant #  모든 속성-property에서 가시성을 반드시(MUST) 선언해야합니다.\n역자주: 가시성은 다른 언어에서 접근제어자 등으로 부르는 public, protected, private 를 의미합니다\n프로젝트의 PHP 최소 버전이 상수의 가시성 (PHP 7.1.0 이상)을 지원하는 경우 모든 상수에 대한 가시성을 반드시(MUST) 선언해야합니다.\nvar 키워드는 속성-property를 선언하는데 사용해서는 안됩니다 (MUST NOT).\n선언문마다 하나 이상의 속성-property이 선언해서는 안됩니다(MUST NOT).\nprotected나 private 가시성을 나타내기 위해 속성 이름 앞에 하나의 밑줄을 사용해서는 안됩니다 (MUST NOT). 즉, 밑줄 접두사는 명시적인 의미가 없습니다.\n형식 선언과 속성-property 이름 사이에 공백이 있어야합니다(MUST).\n속성-property 선언은 다음과 같아야 합니다.\n\u0026lt;?php namespace Vendor\\Package; class ClassName { public $foo = null; public static int $bar = 0; } 4.4 메소드와 함수 #  모든 메소드에서 가시성을 선언해야합니다 (MUST).\n메소드 이름은 protected나 private 가시성을 나타내기 위해 하나의 밑줄로 접두어를 붙여서는 안됩니다 (MUST NOT). 즉, 밑줄 접두사는 명시적인 의미가 없습니다.\n메서드와 함수 이름은 메서드 이름 다음에 공백으로 선언해서는 안됩니다 (MUST NOT). 여는 중괄호는 반드시(MUST) 같은 줄에 있어야하며 닫는 중괄호는 반드시(MUST) 그 다음 줄에 있어야합니다. 여는 괄호 뒤에 공백이 있으면 안되며(MUST NOT) 닫는 괄호 앞에 공백이 있어서는 안됩니다(MUST NOT).\n메소드 선언은 다음과 같습니다. 괄호, 쉼표, 공백 및 중괄호의 배치에 유의하십시오.\n\u0026lt;?php namespace Vendor\\Package; class ClassName { public function fooBarBaz($arg1, \u0026amp;$arg2, $arg3 = [], \u0026amp;...$arg4) { // method body  } } 함수 선언은 다음과 같습니다. 괄호, 쉼표, 공백 및 중괄호의 배치에 유의하십시오.\n\u0026lt;?php function fooBarBaz($arg1, \u0026amp;$arg2, $arg3 = [], \u0026amp;...$arg4) { // function body } 4.5 메서드 및 함수 인수 #  인수 목록에는 각 쉼표 앞에 공백이 있으면 안되며(MUST NOT) 각 쉼표 뒤에 하나의 공백이 있어야합니다(MUST).\n기본값을 가진 메소드 및 함수 인수는 가변 길이 인수 목록의 앞이면서 인수 목록의 끝에 있어야합니다(MUST).\n\u0026lt;?php namespace Vendor\\Package; class ClassName { public function foo(int $arg1, \u0026amp;$arg2, $arg3 = [], \u0026amp;...$arg4) { // method body  } } 인수 목록은 여러 줄에 걸쳐 나뉘어 질 수 있으며(MAY), 각 줄은 한 번 들여 쓰일 수 있습니다. 그렇게 할 때 목록의 첫 번째 항목은 다음 줄에 있어야하며(MUST) 한 줄에 하나의 인수 만 있어야합니다(MUST).\n인수 목록이 여러 줄에 걸쳐 분할되어 있으면 닫는 괄호와 여는 중괄호는 공백을 한개 사용하여 같은 줄에 함께 있어야합니다 (MUST).\n\u0026lt;?php namespace Vendor\\Package; class ClassName { public function aVeryLongMethodName( ClassTypeHint $arg1, \u0026amp;$arg2, array $arg3 = [] ) { // method body  } } 반환형식(return type) 선언이 있으면 콜론 뒤에 공백이 하나 있어야하며(MUST) 그 다음에 형식 선언이옵니다. 콜론과 반환형식 선언은 두 문자 사이에 공백이 없는 인수 목록을 닫는 괄호와 같은 줄에 있어야합니다(MUST).\n\u0026lt;?php declare(strict_types=1); namespace Vendor\\Package; class ReturnTypeVariations { public function functionName(int $arg1, $arg2): string { return \u0026#39;foo\u0026#39;; } public function anotherFunction( string $foo, string $bar, int $baz ): string { return \u0026#39;foo\u0026#39;; } } nullable type 선언에서는 물음표와 type 사이에 공백이 없어야합니다(MUST NOT).\n\u0026lt;?php declare(strict_types=1); namespace Vendor\\Package; class ReturnTypeVariations { public function functionName(?string $arg1, ?int \u0026amp;$arg2): ?string { return \u0026#39;foo\u0026#39;; } } 인수 앞에 참조 연산자 \u0026amp;를 사용하면 앞의 예시와 같이 뒤에 공백이 있어서는 안됩니다(MUST NOT).\n가변 3 도트 연산자와 인자 이름 사이에는 공백이 없어야합니다(MUST NOT).\npublic function process(string $algorithm, ...$parts) { // processing } 참조 연산자와 가변 3 도트 연산자를 결합 할 때 두 연산자 사이에 공백이 없어야합니다(MUST NOT).\npublic function process(string $algorithm, \u0026amp;...$parts) { // processing } 4.6 abstract, final, 과 static #  abstract와 final 선언이 있을 경우, 가시성 선언 앞에 와야합니다 (MUST).\nstatic 선언이 있을 경우, 가시성 선언 뒤에 와야합니다(MUST).\n\u0026lt;?php namespace Vendor\\Package; abstract class ClassName { protected static $foo; abstract protected function zim(); final public static function bar() { // method body  } } 4.7 메서드와 함수 호출 #  메서드나 함수를 호출 할 때 메서드나 함수 이름과 여는 괄호 사이에 공백이 없어야합니다(MUST NOT). 여는 괄호 뒤에 공백이 있으면 안되며(MUST NOT) 닫는 괄호 앞에 공백이 있어서는 안됩니다(MUST NOT). 인수 목록에는 각 쉼표 앞에 공백이 있으면 안되며(MUST NOT) 각 쉼표 뒤에 하나의 공백이 있어야합니다(MUST).\n\u0026lt;?php bar(); bar(...[\u0026#39;foo\u0026#39;,\u0026#39;bar\u0026#39;]); $foo-\u0026gt;bar($arg1); Foo::bar($arg2, $arg3); 인수 목록은 여러 줄에 걸쳐 나뉘어 질 수 있으며(MAY), 각 줄은 한 번 들여쓰기를 합니다. 그렇게 할 때 목록의 첫 번째 항목은 다음 줄에 있어야하며(MUST) 한 줄에 하나의 인수 만 있어야합니다(MUST). (익명함수나 배열의 경우처럼) 여러 줄로 분할되는 단일 인수는 인수 목록 자체를 분할하는 이것에는 해당하지 않습니다.\n\u0026lt;?php $foo-\u0026gt;bar( $longArgument, $longerArgument, $muchLongerArgument ); \u0026lt;?php somefunction($foo, $bar, [ // ... ], $baz); $app-\u0026gt;get(\u0026#39;/hello/{name}\u0026#39;, function ($name) use ($app) { return \u0026#39;Hello \u0026#39; . $app-\u0026gt;escape($name); }); 5. 제어구조 #  제어 구조의 일반적인 스타일 규칙은 다음과 같습니다.\n 제어 구조 키워드 다음에 하나의 공백이 있어야합니다(MUST). 여는 괄호 뒤에 공백이 있으면 안됩니다(MUST NOT). 닫는 괄호 앞에 공백이 없어야 합니다(MUST NOT). 닫는 괄호와 여는 중괄호 사이에 하나의 공백이 있어야 합니다(MUST). 본문은 한 번 들여쓰기해야합니다(MUST). 닫는 중괄호는 몸체 뒤의 다음 줄에 있어야합니다(MUST).  각 구조의 본문은 중괄호로 묶어야합니다(MUST). 이것은 구조가 어떻게 보이는지 표준화하고 새로운 라인을 본문에 추가 할 때 오류가 발생할 가능성을 줄입니다.\n5.1 if, elseif, else #  if 구조는 다음과 같습니다. 괄호, 공백 및 중괄호의 배치에 유의하십시오. else와 elseif는 이전 본문의 닫는 중괄호와 같은 줄에 있습니다.\n\u0026lt;?php if ($expr1) { // if body } elseif ($expr2) { // elseif body } else { // else body; } else if 키워드 대신 elseif 키워드를 사용하여 모든 제어 키워드가 하나의 단어처럼 보이도록 해야 합니다 (SHOULD). 역자주: phpstorm과 같은 ide에서 else if로 사용하고 코드 자동정렬을 할 경우 else { if(){} } 같은 형태로 분할 해버리기도 합니다. 이때는 설정을 수정할 수도 있지만 저는 elseif 로 사용하시는 것을 권장합니다\n괄호 안의 표현은 여러 줄에 걸쳐 나뉘어 질 수 있으며(MAY), 그 다음 줄은 적어도 한 번 들여 쓰일 수 있습니다. 그렇게 할 때 첫 번째 조건은 반드시(MUST) 다음 줄에 있어야합니다. 닫는 괄호와 여는 중괄호는 한개 공백과 함께 한 줄에 함께 있어야합니다 (MUST). 조건 사이의 부울-boolean 연산자는 항상 줄의 시작 또는 끝에 있어야하며 둘 다를 혼합해서는 안됩니다(MUST).\n\u0026lt;?php if ( $expr1 \u0026amp;\u0026amp; $expr2 ) { // if body } elseif ( $expr3 \u0026amp;\u0026amp; $expr4 ) { // elseif body } 5.2 switch, case #  switch 구조체는 다음과 같습니다. 괄호, 공백 및 중괄호의 배치에 유의하십시오. case 문은 switch에서 한 번 들여쓰기해야하며(MUST) break 키워드 (또는 다른 종료 키워드)는 case 본문과 같은 수준에서 들여쓰기해야합니다 (MUST). 비어 있지 않은 case 본문에서 다음 case를 의도적으로 실행시킬 경우(fall-through) // no break와 같은 주석이 있어야합니다(MUST).\n\u0026lt;?php switch ($expr) { case 0: echo \u0026#39;First case, with a break\u0026#39;; break; case 1: echo \u0026#39;Second case, which falls through\u0026#39;; // no break `역자주: 다음case를 실행시키기 위해 의도적으로 break를 넣지 않은 경우 반드시 추가해야하는 주석`  case 2: case 3: case 4: echo \u0026#39;Third case, return instead of break\u0026#39;; return; default: echo \u0026#39;Default case\u0026#39;; break; } 괄호 안의 표현은 여러 행에 걸쳐 나뉘어 질 수 있으며(MAY), 그 다음 행은 적어도 한 번 들여쓰기를 합니다. 그럴 경우 첫 번째 조건은 반드시 다음 줄에 있어야 합니다(MUST). 닫는 괄호와 여는 중괄호는 하나의 공백과 함께 한 줄에 함께 있어야 합니다 (MUST). 조건 사이의 부울-boolean 연산자는 항상 줄의 시작 또는 끝에 있어야하며 둘 다를 혼합해서는 안됩니다(MUST).\n\u0026lt;?php switch ( $expr1 \u0026amp;\u0026amp; $expr2 ) { // structure body } 5.3 while, do while #  while 문은 다음과 같습니다. 괄호, 공백 및 중괄호의 배치에 유의하십시오.\n\u0026lt;?php while ($expr) { // structure body } 괄호 안의 표현은 여러 행에 걸쳐 나뉘어 질 수 있으며(MAY), 그 다음 행은 적어도 한 번 들여쓰기를 합니다. 그럴 경우 첫 번째 조건은 반드시 다음 줄에 있어야 합니다(MUST). 닫는 괄호와 여는 중괄호는 하나의 공백과 함께 한 줄에 함께 있어야합니다 (MUST). 조건 사이의 부울-boolean 연산자는 항상 줄의 시작 또는 끝에 있어야하며 둘 다를 혼합해서는 안됩니다(MUST).\n\u0026lt;?php while ( $expr1 \u0026amp;\u0026amp; $expr2 ) { // structure body } 비슷하게, do while 문은 다음과 같이 보입니다. 괄호, 공백 및 중괄호의 배치에 유의하십시오.\n\u0026lt;?php do { // structure body; } while ($expr); 괄호 안의 표현은 여러 행에 걸쳐 나뉘어 질 수 있으며(MAY), 그 다음 행은 적어도 한 번 들여쓰기를 합니다. 그럴 경우 첫 번째 조건은 반드시 다음 줄에 있어야 합니다(MUST). 조건들 사이의 부울 연산자는 언제나 둘의 혼합이 아닌 라인의 시작 또는 끝 부분에 있어야합니다 (MUST).\n\u0026lt;?php do { // structure body; } while ( $expr1 \u0026amp;\u0026amp; $expr2 ); 5.4 for #  for 문은 다음과 같이 보입니다. 괄호, 공백 및 중괄호의 배치에 유의하십시오.\n\u0026lt;?php for ($i = 0; $i \u0026lt; 10; $i++) { // for body } 괄호 안의 표현은 여러 행에 걸쳐 나뉘어 질 수 있으며(MAY), 그 다음 행은 적어도 한 번 들여쓰기를 합니다. 그럴 경우 첫 번째 조건은 반드시 다음 줄에 있어야 합니다(MUST). 닫는 괄호와 여는 중괄호는 하나의 공백과 함께 한 줄에 함께 있어야합니다 (MUST).\n\u0026lt;?php for ( $i = 0; $i \u0026lt; 10; $i++ ) { // for body } 5.5 foreach #  foreach 문은 다음과 같이 보입니다. 괄호, 공백 및 중괄호의 배치에 유의하십시오.\n\u0026lt;?php foreach ($iterable as $key =\u0026gt; $value) { // foreach body } 5.6 try, catch, finally #  try-catch-finally 블록은 다음과 같이 보입니다. 괄호, 공백 및 중괄호의 배치에 유의하십시오.\n\u0026lt;?php try { // try body } catch (FirstThrowableType $e) { // catch body } catch (OtherThrowableType | AnotherThrowableType $e) { // catch body } finally { // finally body } 6. 연산자 #  연산자의 스타일 규칙은 arity (피연산자 수)별로 그룹화됩니다.\n연산자 주변에 공백이 허용되며, 가독성을 위해 여러 공백이 있을 수 있습니다(MAY).\n여기에 설명되지 않은 모든 연산자는 정의되지 않은 상태로 남아 있습니다.\n6.1. 단항 연산자 #  증가/감소 연산자, 논리 not 연산자, 변환 및 부정 연산자는 연산자와 피연산자 사이에 공백이 없어야합니다(MUST NOT).\n$value++; --$value; $a = !$b; $c = +$d; $e = -$f; 타입 캐스팅 연산자는 괄호 안에 공백이 없어야합니다(MUST NOT).\n$intValue = (int) $input; 6.2. 이진 연산자 #  모든 이진 arithmetic, comparison, assignment, bitwise, logical, [문자열-string][] 및 type 연산자의 앞뒤에는 최소한 하나 이상의 공백이 있어야 합니다(MUST).\nif ($a === $b) { $foo = $bar ?? $a ?? $b; } elseif ($a \u0026gt; $b) { $foo = $a + $b * $c; } elseif ($a \u0026lt;=\u0026gt; $c) { $foo += $bar % $a \u0026amp; $b ** $c; } 6.3. 삼항-Ternary 연산자 #  삼항 연산자라고도하는 조건부 연산자 ? 및 :문자 앞뒤에는 하나 이상의 공백이 와야합니다(MUST).\n$variable = $foo ? \u0026#39;foo\u0026#39; : \u0026#39;bar\u0026#39;; 조건부 연산자의 중간 피연산자가 생략되면 연산자는 다른 이진 [비교-comparison][] 연산자와 동일한 스타일 규칙을 따라야합니다(MUST).\n$variable = $foo ?: \u0026#39;bar\u0026#39;; 7. 클로저-Closures #  클로저는 function 키워드 뒤의 공백과 use 키워드 앞뒤에 공백으로 선언해야합니다 (MUST).\n여는 중괄호는 반드시(MUST) 같은 줄에 있어야하며 닫는 중괄호는 반드시(MUST) 그 다음 줄에 있어야합니다.\n인수 목록이나 변수 목록의 여는 괄호 다음에 공백이 있으면 안되며(MUST NOT), 인수 목록이나 변수 목록의 닫는 괄호 앞에 공백이 있으면 안됩니다(MUST NOT).\n인수 목록과 변수 목록에는 각 쉼표 앞에 공백이 있어서는 안되며(MUST NOT) 각 쉼표 뒤에 하나의 공백이 있어야합니다(MUST).\n기본값을 가진 클로저 인수는 인수 목록의 끝에 와야합니다 (MUST).\n반환유형(return type)이 있는 경우 일반 함수 및 메소드와 동일한 규칙을 따라야 하며 use 키워드가 존재한다면, 콜론은 두 문자 사이에 공백없이 use 리스트의 닫는 괄호에 따라와야합니다 (MUST).\n클로저 선언은 다음과 같습니다. 괄호, 쉼표, 공백 및 중괄호의 배치에 유의하십시오.\n\u0026lt;?php $closureWithArgs = function ($arg1, $arg2) { // body }; $closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) { // body }; $closureWithArgsVarsAndReturn = function ($arg1, $arg2) use ($var1, $var2): bool { // body }; 인수 목록과 변수 목록은 여러 행에 걸쳐 나뉘어 질 수 있으며(MAY), 각 행은 한 번 들여쓰기됩니다.\n그럴경우 목록의 첫 번째 항목은 다음 줄에 있어야하며(MUST), 한 줄에 하나의 인수 또는 변수 만 있어야합니다(MUST).\n마지막 리스트 (인수 또는 변수의 여부)가 여러 줄로 나뉘어 질 때 닫는 괄호와 여는 중괄호는 하나의 공백을 사용하여 같은 줄에 함께 있어야합니다 (MUST).\n다음은 인수 목록이 있거나 없는 클로저의 예와 여러 줄에 걸쳐있는 변수 목록입니다.\n\u0026lt;?php $longArgs_noVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) { // body }; $noArgs_longVars = function () use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_longVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; $longArgs_shortVars = function ( $longArgument, $longerArgument, $muchLongerArgument ) use ($var1) { // body }; $shortArgs_longVars = function ($arg) use ( $longVar1, $longerVar2, $muchLongerVar3 ) { // body }; 형식 지정 규칙은 함수 또는 메소드 호출에서 클로저가 직접 인수로 사용될 때도 적용됩니다.\n\u0026lt;?php $foo-\u0026gt;bar( $arg1, function ($arg2) use ($var1) { // body  }, $arg3 ); 8. 익명 클래스 #  익명 클래스는 위 섹션의 클로저와 동일한 지침과 원칙을 따라야합니다(MUST).\n\u0026lt;?php $instance = new class {}; implements 인터페이스 목록이 감싸지 않는 한 여는 중괄호는 class 키워드와 같은 줄에 있을 수 있습니다(MAY). 인터페이스 목록이 감쌀 경우 중괄호는 마지막 인터페이스 바로 다음 행에 있어야합니다 (MUST).\n\u0026lt;?php // Brace on the same line $instance = new class extends \\Foo implements \\HandleableInterface { // Class content }; // Brace on the next line $instance = new class extends \\Foo implements \\ArrayAccess, \\Countable, \\Serializable { // Class content }; $intValue = (int) $input; "});index.add({'id':11,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/09-psr-13/','title':"09 P S R 13",'section':"Php",'content':"Link definition interfaces #  하이퍼 미디어 링크는 HTML 컨텍스트와 다양한 API 형식 컨텍스트에서 점점 더 중요한 웹의 일부가 되고 있습니다. 그러나 일반적인 하이퍼 미디어 형식은 하나도 없으며 형식 간 링크를 나타내는 일반적인 방법도 없습니다. 역자주: 완전히 표준화되지 못했다는 의미\n이 스펙은 PHP 개발자에게 사용되는 직렬화 형식과는 별도로 하이퍼 미디어 링크를 표현하는 간단하고 일반적인 방법을 제공하는 것을 목표로 합니다. 그래서 시스템은 하이퍼 미디어 링크를 사용하여 하나 이상의 연결된 포맷으로 응답을 직렬화 할 수 있습니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 [RFC 2119]에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\nReferences #   RFC 2119 RFC 4287 RFC 5988 RFC 6570 IANA Link Relations Registry Microformats Relations List  1. 명세서 #  1.1 Basic links #  하이퍼 미디어 링크는 최소한 다음으로 구성됩니다.\n 참조되는 대상 자원을 나타내는 URI입니다. 대상 자원과 관련된 소스의 관계를 정의합니다.  사용 된 형식에 따라 링크의 다양한 다른 속성이 존재할 수 있습니다. 추가 속성(additional attributes)은 표준화되거나 보편화되지 않았기 때문에 이 표준은 표준화하려고하지 않습니다.\n이 명세서는 목정상 다음의 정의가 적용됩니다.\n Implementing Object - 이 명세에 정의 된 인터페이스 중 하나를 구현하는 객체. Serializer - 하나 이상의 Link 객체를 사용하고 정의 된 형식으로 직렬화 된 표현을 생성하는 라이브러리 또는 기타 시스템입니다.  1.2 Attributes #  모든 링크는 URI와 관계를 넘어 0개 이상의 추가 속성을 포함 할 수있습니다(MAY). 여기에 허용되는 값의 정식 등록된 것이 없으며 값의 유효성은 컨텍스트 및 종종 특정 직렬화 형식에 따라 다릅니다. 일반적으로 지원되는 값에는 \u0026lsquo;hreflang\u0026rsquo;, \u0026lsquo;title\u0026rsquo;및 \u0026lsquo;type\u0026rsquo;이 포함됩니다.\n직렬화 포맷에 의해 필요한 경우 링크 객체의 속성을 생략 할 수 있습니다(MAY). 그러나 serializers는 serialization 형식의 정의에 의해 방지되지 않는 한 사용자 확장을 허용하기 위해 가능한 모든 제공된 속성을 인코딩해야합니다 (SHOULD).\n일부 속성 (일반적으로 hreflang)은 그들의 문맥에 두 번 이상 나타날 수 있습니다. 따라서 속성 값은 단순한 값이 아닌 값의 배열 일 수 있습니다(MAY). Serializers는 직렬화 된 형식 (공백으로 구분 된 목록, 쉼표로 구분 된 목록 등)에 적합한 형식으로 배열을 인코딩 할 수 있습니다 (MAY). 특정 속성이 특정 컨텍스트에서 다중 값을 가질 수 없는 경우, 직렬자는 제공된 첫 번째 값을 사용하고 모든 후속 값을 무시해야합니다 (MUST).\n속성 값이 부울 true이면, serializers는 적절한 경우 축약형을 사용할 수 있고 직렬화 형식으로 지원할 수 있습니다 (MAY). 예를 들어, HTML은 속성의 존재가 부울 의미를 가질 때 속성이 값을 갖지 못하게합니다. 이 규칙은 속성이 부울 true인 경우에만 적용되며 정수 1과 같은 PHP의 \u0026ldquo;truthy\u0026quot;값은 적용되지 않습니다.\n속성 값이 부울 false 인 경우, serializer는 속성의 의미를 변경하지 않는 한 속성을 완전히 생략해서는 안됩니다 (SHOULD). 이 규칙은 속성이 부울 false 인 경우에만 적용되며, 정수 0과 같은 PHP의 다른 \u0026ldquo;falsey\u0026quot;값에는 적용되지 않습니다.\n1.3 Relationships #  링크 관계는 문자열로 정의되며 공개적으로 정의 된 관계의 경우 간단한 키워드이고 비공개인 관계의 경우 절대 URI를 사용합니다.\n간단한 키워드가 사용되는 경우 IANA 레지스트리의 키워드와 일치해야합니다(SHOULD).\n선택적으로 microformats.org 레지스트리를 사용할 수도 있지만(MAY) 모든 컨텍스트에서 유효하지 않을 수 있습니다.\n위의 레지스트리 중 하나 또는 이와 유사한 공개 레지스트리에 정의되지 않은 관계는 \u0026ldquo;비공개\u0026quot;으로 간주됩니다. 즉 특정 응용 프로그램 또는 유스 케이스에 한정됩니다. 그러한 관계는 반드시 절대 URI를 사용해야 합니다(MUST).\n1.4 Link Templates #  RFC 6570은 URI 템플릿의 형식, 즉 클라이언트에서 제공 한 값으로 채워질 것으로 예상되는 URI의 패턴을 정의합니다. 일부 하이퍼 미디어 형식은 템플릿 링크를 지원하지만 다른 링크는 템플릿이 아니라는 것을 나타내는 특별한 방법이 있을 수 있습니다. URI 템플릿을 지원하지 않는 형식의 Serializer는 템플릿 기반 링크가 발견되면 이를 무시해야 합니다 (MUST).\n1.5 Evolvable providers #  어떤 경우에는 링크 공급자가 추가 링크를 추가해야 할 수도 있습니다. 어떤 경우에는 링크 공급자가 반드시 읽기 전용이며 링크는 런타임시 다른 데이터 소스에서 파생됩니다. 이러한 이유로 수정 가능한 공급자는 선택적으로 구현 될 수 있는 보조 인터페이스입니다.\n또한 PSR-7 응답 객체 같은 일부 링크 공급자 객체는 의도적으로 변경할 수 없습니다. 이것은 메소드를 해당 링크에 추가하는 방법은 맞지 않는 다는 것을 의미합니다 따라서 EvolvableLinkProviderInterface 의 단일 메소드는 원본과 동일하지만 추가 링크 객체가 포함 된 새로운 객체가 반환되어야 합니다.\n1.6 Evolvable link objects #  링크 오브젝트는 대부분의 경우 값 오브젝트입니다. 따라서 PSR-7 값 객체와 동일한 방식으로 처리하도록 하는 것이 좋은 방식입니다. 역자주: 원문은 evolve이지만 의역하였습니다 이러한 이유 때문에, 단일 변경으로 새 객체 인스턴스를 생성하는 메소드인 EvolvableLinkInterface가 추가적으로 제공됩니다. 같은 방식이 PSR-7에서 사용되었고, PHP의 copy-on-write 동작 덕분에 여전히 CPU와 메모리가 효율적입니다.\n그러나 링크의 templated 된 값은 href 값에 기반하므로 templated 된 값에 대한 확장 가능한 방법은 없습니다. 역자주: evolvable지만 좀 더 좋은 단어를 찾지 못하였습니다 이것은 독립적으로 설정하면 안되지만(MUST NOT), href 값이 RFC 6570 링크 템플릿인지에 따라서 결정됩니다.\n2. Package #  설명 한 인터페이스와 클래스는 psr/link 패키지의 일부로 제공됩니다.\n3. Interfaces #  3.1 Psr\\Link\\LinkInterface #  \u0026lt;?php namespace Psr\\Link; /** * A readable link object. */ interface LinkInterface { /** * Returns the target of the link. * * The target link must be one of: * - An absolute URI, as defined by RFC 5988. * - A relative URI, as defined by RFC 5988. The base of the relative link * is assumed to be known based on context by the client. * - A URI template as defined by RFC 6570. * * If a URI template is returned, isTemplated() MUST return True. * * @return string */ public function getHref(); /** * Returns whether or not this is a templated link. * * @return bool * True if this link object is templated, False otherwise. */ public function isTemplated(); /** * Returns the relationship type(s) of the link. * * This method returns 0 or more relationship types for a link, expressed * as an array of strings. * * @return string[] */ public function getRels(); /** * Returns a list of attributes that describe the target URI. * * @return array * A key-value list of attributes, where the key is a string and the value * is either a PHP primitive or an array of PHP strings. If no values are * found an empty array MUST be returned. */ public function getAttributes(); } 3.2 Psr\\Link\\EvolvableLinkInterface #  \u0026lt;?php namespace Psr\\Link; /** * An evolvable link value object. */ interface EvolvableLinkInterface extends LinkInterface { /** * Returns an instance with the specified href. * * @param string $href * The href value to include. It must be one of: * - An absolute URI, as defined by RFC 5988. * - A relative URI, as defined by RFC 5988. The base of the relative link * is assumed to be known based on context by the client. * - A URI template as defined by RFC 6570. * - An object implementing __toString() that produces one of the above * values. * * An implementing library SHOULD evaluate a passed object to a string * immediately rather than waiting for it to be returned later. * * @return static */ public function withHref($href); /** * Returns an instance with the specified relationship included. * * If the specified rel is already present, this method MUST return * normally without errors, but without adding the rel a second time. * * @param string $rel * The relationship value to add. * @return static */ public function withRel($rel); /** * Returns an instance with the specified relationship excluded. * * If the specified rel is already not present, this method MUST return * normally without errors. * * @param string $rel * The relationship value to exclude. * @return static */ public function withoutRel($rel); /** * Returns an instance with the specified attribute added. * * If the specified attribute is already present, it will be overwritten * with the new value. * * @param string $attribute * The attribute to include. * @param string $value * The value of the attribute to set. * @return static */ public function withAttribute($attribute, $value); /** * Returns an instance with the specified attribute excluded. * * If the specified attribute is not present, this method MUST return * normally without errors. * * @param string $attribute * The attribute to remove. * @return static */ public function withoutAttribute($attribute); } 3.2 Psr\\Link\\LinkProviderInterface #  \u0026lt;?php namespace Psr\\Link; /** * A link provider object. */ interface LinkProviderInterface { /** * Returns an iterable of LinkInterface objects. * * The iterable may be an array or any PHP \\Traversable object. If no links * are available, an empty array or \\Traversable MUST be returned. * * @return LinkInterface[]|\\Traversable */ public function getLinks(); /** * Returns an iterable of LinkInterface objects that have a specific relationship. * * The iterable may be an array or any PHP \\Traversable object. If no links * with that relationship are available, an empty array or \\Traversable MUST be returned. * * @return LinkInterface[]|\\Traversable */ public function getLinksByRel($rel); } 3.3 Psr\\Link\\EvolvableLinkProviderInterface #  \u0026lt;?php namespace Psr\\Link; /** * An evolvable link provider value object. */ interface EvolvableLinkProviderInterface extends LinkProviderInterface { /** * Returns an instance with the specified link included. * * If the specified link is already present, this method MUST return normally * without errors. The link is present if $link is === identical to a link * object already in the collection. * * @param LinkInterface $link * A link object that should be included in this collection. * @return static */ public function withLink(LinkInterface $link); /** * Returns an instance with the specified link removed. * * If the specified link is not present, this method MUST return normally * without errors. The link is present if $link is === identical to a link * object already in the collection. * * @param LinkInterface $link * The link to remove. * @return static */ public function withoutLink(LinkInterface $link); } "});index.add({'id':12,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/10-psr-14/','title':"10 P S R 14",'section':"Php",'content':"Event Dispatcher #  Event Dispatching은 개발자가 어플리케이션에 로직을 쉽고 일관되게 주입 할 수있게 해주는 일반적이며 잘 테스트 된 메커니즘입니다.\n이 PSR의 목표는 라이브러리와 컴포넌트가가 다양한 어플리케이션과 프레임워크간에 보다 자유롭게 재사용 될 수 있도록 Event 기반 확장 및 협업을 위한 공통 메커니즘을 확립하는 것입니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n목표 #  Event 발송 및 처리를 위한 공통 인터페이스를 사용하면 개발자가 공통된 방식으로 여러 프레임워크 및 기타 라이브러리와 상호 작용할 수 있는 라이브러리를 만들 수 있습니다.\n몇 가지 예 :\n 사용자가 권한이 없을 때 데이터에 저장/액세스를 방지하는 보안 프레임워크. 일반적인 전체 페이지 캐싱 시스템. 다른 라이브러리를 확장하는 라이브러리. 프레임워크가 둘 다 통합되어 있는지 여부와 관계 없음. 어플리케이션 내에서 수행 된 모든 작업을 추적하는 로깅 패키지  정의 #   Event - Event는 Emitter가 생성 한 메시지입니다. 임의의 PHP 객체 일 수 있습니다. Listener - Listener는 Event를 전달할 실행가능한 어떠한 PHP 입니다. 동일한 Event를 0 개 이상의 Listener에 전달할 수 있습니다. Listener는 원할 경우 다른 비동기 동작을 큐에 넣을 수 있습니다 (MAY). Emitter - Emitter는 Event를 보내고자 하는 임의의 코드입니다. 이것은 \u0026ldquo;호출 코드\u0026quot;라고도합니다. 이것은 특정 데이터 구조로 표현되지 않고 유스케이스를 가르킵니다. Dispatcher - Dispatcher는 Emitter에 의해 Event 객체를 전달하는 서비스 객체입니다. Dispatcher는 Event가 관련된 모든 Listener에게 전달되도록 보장하지만, 실행할 Listener를 결정하는 것은 Listener Provider에게 위임해야합니다.(MUST) Listener Provider - Listener Provider는 주어진 Event와 관련이있는 Listener를 결정할 책임이 있지만 Listener 자신을 호출해서는 안됩니다(MUST NOT). Listener Provider는 0 개 이상의 관련 Listener를 지정할 수 있습니다.  이벤트 #  Event는 Emitter와 해당하는 Listener 간의 통신 단위 역할을 하는 객체입니다.\nEmitter에 정보를 다시 돌려주는 Listener를 호출하는 경우 Event 객체는 변경 될 수 있습니다(MAY).\n그러나 그러한 양방향 통신이 필요하지 않은 경우 Event는 변경 불가능한 것으로 정의하는 것이 좋습니다(RECOMMENDED). 즉, 뮤 테이터 (mutator) 메소드가 존재하지 않도록 정의합니다.\n구현체는 동일한 객체가 모든 Listener에게 반드시 전달된다고 가정해야합니다 (MUST).\nEvent 객체가 무손실 직렬화 및 비 직렬화를 지원한다는 것이 권장되지만(RECOMMENDED) 필수적이지는 않습니다(NOT REQUIRED). $event == unserialize(serialize($event))는 참이어야합니다 (SHOULD). 객체는 PHP의 Serializable 인터페이스, __sleep() 또는 __wakeup() 매직 메소드 또는 적절한 경우 언어(PHP) 내 유사한 기능을 활용 할 수 있습니다 (MAY).\n멈출수 있는 Event-Stoppable Event #  Stoppable Event는 더 많은 Listener가 호출되는 것을 방지하는 방법을 추가한, Event의 특별한 케이스입니다. 이것은 StoppableEventInterface를 구현하여 표현합니다.\nStoppableEventInterface를 구현 한 Event는 해당하는 Event가 완료되면 isPropagationStopped()로부터 true를 리턴해야합니다 (MUST). 그것이 언제인지를 결정하는 것은 클래스를 구현하는 자의 몫입니다. 예를 들어, PSR-7의 RequestInterface 객체가 대응하는 ResponseInterface 객체와 일치하도록 요청하는 Event는 Listener가 호출 할 setResponse(ResponseInterface $res)메소드를 가질 수 있습니다. 이것은 isPropagationStopped() 가 true를 반환합니다.\n리스너-Listener #  Listener는 실행가능한 어떤 PHP 일 것입니다. Listener는 하나의 매개 변수만을 가져야하며(MUST), 이것은 리스너가 반응해야하는 Event입니다.\nListener는 해당 유즈 케이스와 관련하여 파라메터에 구체적으로 타입 힌트를 입력해야합니다 (SHOULD).\n즉, Listener는 인터페이스에 대해 타입 힌트를 입력하여 해당 인터페이스를 구현하는 모든 Event 유형 또는 해당 인터페이스의 특정 구현과 호환 가능하다는 것을 표현합니다.\nListener는 void리턴을 가져야하고 (SHOULD), 명시 적으로 리턴하는 타입 힌트를 입력해야합니다 (SHOULD). Dispatcher는 Listener의 리턴 값을 무시해야합니다 (MUST).\nListener는 다른 코드에 행동을 위임 할 수 있습니다(MAY). 이것은 실제 비즈니스 로직을 실행하는 객체 둘러싼 얇은 래퍼(wrapper) 인 Listener가 포함됩니다.\nListener는 cron, 큐 서버 또는 유사한 기술을 사용하는 보조 프로세스를 통해 나중에 처리하기 위해 Event로부터 정보를 큐에 넣을 수 있습니다(MAY). 그러기 위해 Event 객체 자체를 직렬화 할 수있습니다. 그러나 모든 Event 객체가 안전하게 직렬화 될 수 있는 것은 아니므로주의해야합니다. 보조 프로세스는 Event 객체에 대한 모든 변경 사항이 다른 Listener에 전파되지 않는다고 가정해야합니다 (MUST).\n발송자-Dispatcher #  Dispatcher는 EventDispatcherInterface를 구현 한 서비스 객체입니다. Listener Provider로부터 전달 된 Event에 대한 Listener를 찾아서 해당 Event와 함께 각 Listener를 호출합니다.\nDispatcher는 :\n ListenerProvider에서 반환 된 순서대로 Listener를 동기적으로 호출해야합니다(MUST). Listener를 호출 한 후 전달 된 것과 동일한 Event 객체를 반환해야합니다(MUST). 모든 Listener가 실행완료될 때까지 Emitter로 돌아 가지 않아야합니다(MUST NOT).  Dispatcher는 Stoppable Event가 전달되면\n 각 Listener가 호출되기 전에 Event에 대해 반드시 isPropagationStopped()를 호출해야합니다 (MUST). 그 메소드가 true를 리턴하면, 반드시 Event를 Emitter에게 즉시 반환해야하고 더 이상의 Listener를 호출해서는 안됩니다. 이것은 isPropagationStopped()에서 항상 true를 반환하는 Event가 Dispatcher에 전달되면 0개의 Listener가 호출됨을 의미합니다.  Dispatcher는 Listener 제공자로부터 리턴 된 Listener가 type-safe하다고 가정해야합니다 (SHOULD). 즉, Dispatcher는 $listener($event)호출이 TypeError를 생성하지 않아야한다고 가정해야합니다 (SHOULD).\nError handling #  Listener가 던진 예외 또는 오류는 이후의 모든 Listener의 실행을 차단해야합니다(MUST). Listener에 의해 던져진 오류 또는 예외는 Emitter로 전달 되야합니다(MUST).\nDispatcher는 던져진 객체를 잡아서 기록 할 수 있고(MAY), 추가적인 조치가 행동을 하도록 허용하지만 반드시 원래의 Throwable을 다시 던져야합니다 (MUST).\nListener Provider #  Listener Provider는, Listener가 어느 Event에 관련이 있는지, 어떤 Listener가 호출되어야 하는지를 결정하는 서비스 객체입니다. Listener가 무엇을 의미하는지 그리고 Listener가 선택하는 방법에 따라 Listener를 돌려주는 순서를 결정할 수 있습니다. 다음이 포함될 수 있습니다(MAY):\n 구현자가 고정 된 순서로 Event에 Listener를 할당 할 수 있도록 일부 등록 메커니즘을 허용합니다. Event 유형 과 구현 된 인터페이스를 기반으로 리플렉션을 통해 해당 Listener 목록을 만듭니다. 런타임에 참조 될 수 있는 미리 컴파일 된 Listener의 목록 생성합니다. 현재 사용자에게 특정 권한이 있는 경우에만 특정 Listener가 호출되도록 액세스 제어 형식을 구현합니다. 엔티티와 같이 Event에 의해 참조되는 객체에서 일부 정보를 추출하고 해당 객체에 대해 미리 정의 된 라이프 사이클 메소드를 호출합니다. 임의의 로직를 사용하여 하나 이상의 다른 Listener Provider에게 책임을 위임합니다.  위의 메커니즘이나 다른 메커니즘을 원하는대로 사용할 수 있습니다(MAY).\nListener Provider는 Event의 클래스 이름을 사용하여 Event를 다른 Event와 구별해야합니다 (SHOULD). 또한 Event에 대한 다른 정보를 적절하게 고려할 수 있습니다(MAY).\nListener Provider는 Listener 적용 가능 여부를 결정할 때 부모 유형을 Event의 자체 유형과 동일하게 처리해야합니다(MUST).\n다음과 같은 경우 :\nclass A {} class B extends A {} $b = new B(); function listener(A $event): void {}; Listener Provider는 리스너의 다른 조건에 의해 타입이 호환되지 않는 한 호환성이 유효하므로, $b의 Listener로서 listener()를 처리 해야합니다 (MUST).\n오브젝트 구성-Object composition #  Dispatcher는 관련된 Listener를 판별하기 위해 Listener Provider를 구성해야합니다 (SHOULD). Listener Provider가 Dispatcher와는 별개의 오브젝트로 구현되지만 반드시 요구되지는 않는 것이 좋습니다 (RECOMMENDED).\nInterfaces #  namespace Psr\\EventDispatcher; /** * Defines a dispatcher for events. */ interface EventDispatcherInterface { /** * Provide all relevant listeners with an event to process. * * @param object $event * The object to process. * * @return object * The Event that was passed, now modified by listeners. */ public function dispatch(object $event); } namespace Psr\\EventDispatcher; /** * Mapper from an event to the listeners that are applicable to that event. */ interface ListenerProviderInterface { /** * @param object $event * An event for which to return the relevant listeners. * @return iterable[callable] * An iterable (array, iterator, or generator) of callables. Each * callable MUST be type-compatible with $event. */ public function getListenersForEvent(object $event) : iterable; } namespace Psr\\EventDispatcher; /** * An Event whose processing may be interrupted when the event has been handled. * * A Dispatcher implementation MUST check to determine if an Event * is marked as stopped after each listener is called. If it is then it should * return immediately without calling any further Listeners. */ interface StoppableEventInterface { /** * Is propagation stopped? * * This will typically only be used by the Dispatcher to determine if the * previous listener halted propagation. * * @return bool * True if the Event is complete and no further listeners should be called. * False to continue calling listeners. */ public function isPropagationStopped() : bool; } "});index.add({'id':13,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/11-psr-15/','title':"11 P S R 15",'section':"Php",'content':"HTTP Server Request Handlers #  이 문서에서는 PSR-7 또는 후속 PSR로 설명 된 HTTP 메시지를 사용하는 HTTP 서버 요청 처리기 (\u0026ldquo;요청 처리기\u0026rdquo;) 및 HTTP 서버 미들웨어 구성 요소 (\u0026ldquo;미들웨어\u0026rdquo;)에 대한 일반적인 인터페이스에 대해 설명합니다.\nHTTP 요청 처리기는 모든 웹 응용 프로그램의 기본 요소입니다. 서버 측 코드는 요청 메시지를 수신하여 처리하고 응답 메시지를 생성합니다. HTTP 미들웨어는 공통 요청 및 응답 처리를 응용 프로그램 계층에서 분리하는 한 방법입니다.\n이 문서에서 설명하는 인터페이스는 요청 처리기 및 미들웨어에 대한 추상화입니다.\n참고 : \u0026ldquo;요청 처리기\u0026quot;와 \u0026ldquo;미들웨어\u0026quot;에 대한 모든 참조는 서버 요청 처리에만 해당됩니다 .\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 rfc2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\nReferences #   PSR-7 RFC 2119  1. 명세서 #  1.1 Request Handlers #  요청 처리기는 PSR-7에 정의 된대로 요청을 처리하고 응답을 생성하는 개별 구성 요소입니다.\n요청 처리자가 응답을 생성하지 못하는 경우 요청 처리기가 예외를 던질 수 있습니다 (MAY). 예외 유형이 정의되지 않았습니다.\n이 표준을 사용하는 요청 처리기는 다음 인터페이스를 구현해야합니다 (MUST).\n Psr\\Http\\Server\\RequestHandlerInterface  1.2 Middleware #  미들웨어 구성 요소는 들어오는 요청을 처리하고 PSR-7에 정의 된 결과 응답을 생성 할 때 다른 미들웨어 구성 요소와 함께 참여하는 개별 구성 요소입니다.\n미들웨어 컴포넌트는 충분한 조건이 만족된다면 요청 처리자에게 위임하지 않고 응답을 생성하고 리턴 할 수 있습니다 (MAY).\n이 표준을 사용하는 미들웨어는 다음 인터페이스를 구현해야합니다(MUST).\n Psr\\Http\\Server\\MiddlewareInterface  1.3 Generating Responses #  응답을 생성하는 미들웨어 또는 요청 처리기는 특정 HTTP 메시지 구현에 대한 의존을 방지하기 위해 PSR-7 ResponseInterface 의 프로토타입 또는 ResponseInterface 인스턴스를 생성 할 수 있는 팩토리를 작성하는 것이 좋습니다(RECOMMENDED).\n1.4 Handling Exceptions #  미들웨어를 사용하는 모든 응용 프로그램에는 예외를 잡아서 응답으로 변환하는 구성 요소가 포함되는 것이 좋습니다(RECOMMENDED). 이 미들웨어는 실행 된 첫 번째 구성 요소 여야하며(SHOULD) 응답이 항상 생성되도록하기 위해 모든 추가 처리를 래핑해야합니다.\n2. Interfaces #  2.1 Psr\\Http\\Server\\RequestHandlerInterface #  요청 처리기는 다음의 인터페이스를 구현되어야합니다(MUST).\nnamespace Psr\\Http\\Server; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; /** * Handles a server request and produces a response. * * An HTTP request handler process an HTTP request in order to produce an * HTTP response. */ interface RequestHandlerInterface { /** * Handles a request and produces a response. * * May call other collaborating code to generate the response. */ public function handle(ServerRequestInterface $request): ResponseInterface; } 2.2 Psr\\Http\\Server\\MiddlewareInterface #  미들웨어 구성 요소는 다음 인터페이스에 호환 가능하게 구현해야합니다(MUST).\nnamespace Psr\\Http\\Server; use Psr\\Http\\Message\\ResponseInterface; use Psr\\Http\\Message\\ServerRequestInterface; /** * Participant in processing a server request and response. * * An HTTP middleware component participates in processing an HTTP message: * by acting on the request, generating the response, or forwarding the * request to a subsequent middleware and possibly acting on its response. */ interface MiddlewareInterface { /** * Process an incoming server request. * * Processes an incoming server request in order to produce a response. * If unable to produce the response itself, it may delegate to the provided * request handler to do so. */ public function process(ServerRequestInterface $request, RequestHandlerInterface $handler): ResponseInterface; } "});index.add({'id':14,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/12-psr-16/','title':"12 P S R 16",'section':"Php",'content':"Common Interface for Caching Libraries #  이 문서는 캐시 항목과 캐시 드라이버에 대한 간단하면서도 확장 가능한 인터페이스를 설명합니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n최종 구현체는 제시된 것보다 더 많은 기능을 가진 객체로 만들 수 있지만(MAY) 반드시 지정한 인터페이스/기능을 먼저 구현해야합니다(MUST).\n1. 명세서 #  1.1 소개 #  캐싱은 모든 프로젝트의 성능을 향상시키는 일반적인 방법이며, 캐싱 라이브러리를 많은 프레임 워크 및 라이브러리의 가장 일반적인 기능 중 하나로 만듭니다. 여기서 말하는 상호 운용성은 라이브러리가 자체 캐싱 구현을 중단하고 프레임 워크 또는 다른 캐시 전용 라이브러리에 의해 제공되는 구현에 쉽게 의지 할 수 있음을 의미합니다.\nPSR-6은 이미 이 문제를 해결했지만 단순한 유스 케이스에 필요한 이상으로 공식적이고 장황한 방법으로 해결합니다. 이 간단한 접근 방식은 일반적인 경우에 대해 표준화와 간소화 된 인터페이스를 구축하는 것을 목표로합니다. 이것은 PSR-6과 독립적이지만 PSR-6과의 호환성을 가진채 가능한 한 간단하게 만들도록 설계되었습니다.\n1.2 정의 #  호출 라이브러리, 구현 라이브러리, TTL, 만료 및 키에 대한 정의는 PSR-6에서 복사 한 것과 동일한 것으로 가정합니다\n  호출 라이브러리(Calling Library) - 실제로 캐시 서비스가 필요한 라이브러리 또는 코드. 이 라이브러리는이 표준의 인터페이스를 구현하는 캐싱 서비스를 활용할 것이며, 그렇지 않으면 이러한 캐싱 서비스의 구현에 대한 알지 못합니다. 역자주: 인터페이스를 구현한 캐싱 서비스를 사용만하고 구현을 하지 않는다.\n  구현 라이브러리(Implementing Library) - 이 라이브러리는 모든 호출 라이브러리에 캐싱 서비스를 제공하기 위해이 표준을 구현합니다. 구현 라이브러리는 Cache\\CacheItemPoolInterface 및 Cache\\CacheItemInterface 인터페이스를 구현하는 클래스를 제공해야합니다(MUST). 라이브러리 구현은 전체 초 단위로 아래에 설명 된 최소 TTL 기능을 지원해야만 합니다 (MUST).\n  TTL - TTL (Time To Live)은 해당 항목이 저장하고 보관하는 것으로 간주되는 시간입니다. TTL은 일반적으로 초 단위의 시간을 나타내는 정수 또는 DateInterval 개체로 정의됩니다.\n  만료(Expiration) - 항목이 만료로 설정되는 실제 시간입니다. 이것은 일반적으로 개체가 저장된 시간에 TTL을 추가하여 계산됩니다. 이것은 일반적으로 개체가 저장된 시간에 TTL을 추가하여 계산되지만 DateTime 개체로 명시 적으로 설정할 수도 있습니다. 1:30:00에 저장된 300 초 TTL을 가진 항목의 만료 시간은 1:35:00입니다. 구현 라이브러리는 요청한 만료 시간 전에 항목을 만료시킬 수도 있지만(MAY) 만료 시간에 도달하면 만료 된 것으로 간주해야합니다(MUST). 호출 라이브러리가 항목을 저장요청을 하지만 만료 시간을 지정하지 않거나 만료 시간 또는 TTL을 null로 지정되어 있다면 구현 라이브러리는 설정한 기본 기간을 사용할 수 있습니다 (MAY). 기본 기간이 설정되지 않은 경우 구현 라이브러리는 해당 항목을 영원히 캐시하는 요청으로 해석하거나 기본 구현이 지원하는 동안 저장하는 것으로 해석해야합니다(MUST).\n  Key - 캐시 된 항목을 고유하게 식별하는 적어도 하나의 문자로 구성된 문자열입니다. 구현 라이브러리는A-Z,a-z,0-9,_ 및. 문자로 구성된 키를 UTF-8 인코딩과 길이가 64 문자 이하의 순서로 지원해야합니다 (MUST). 구현 라이브러리은 추가 문자와 인코딩 또는 더 긴 길이를 지원할 수 있지만(MAY) 최소한 그 최소값을 지원해야합니다(MUST). 라이브러리는 적절하게 키 문자열을 이스케이프 처리해야하지만 원래의 수정되지 않은 키 문자열을 반환 할 수 있어야합니다(MUST). 다음 문자는 미래의 확장을 위해 예약되어 있으며, 구현 라이브러리에서 지원해서는 안됩니다(MUST NOT) :{} () / \\ @ :\n  Cache - Psr\\SimpleCache\\CacheInterface 인터페이스를 구현하는 객체.\n  Cache Misses - 캐시 미스 (cache miss)는 널(null)을 리턴 할 것이고 따라서 null이 하나만 저장된 경우 구별이 불가능합니다. 이것은 PSR-6와 가장 큰 차이입니다.\n  1.3 Cache #  구현체는 특정 캐시 항목에 대해 TTL을 지정되지 않은 경우 사용자가 기본 TTL을 지정하는 메커니즘을 제공 할 수 있습니다 (MAY). 사용자 지정 기본값도 제공되지 않으면 구현체은 기본 구현체에서 허용되는 최대 유효 값으로 기본 설정되어야합니다(MUST). 기본 구현체가 TTL을 지원하지 않으면 사용자 지정 TTL을 자동으로 무시해야합니다 (MUST).\n1.4 Data #  라이브러리를 구현할 때 다음을 포함하여 모든 직렬화 가능한 PHP 데이터 유형을 지원해야합니다 (MUST).\n Strings - PHP 호환 인코딩의 임의의 크기를 갖는 문자열. Integers - PHP가 지원하는 모든 크기의 정수 (최대 64 비트). Floats - 부호가 있는(signed) 모든 부동소수점 값. Booleans - True 와 False. Null - null값 (캐시미스와 구별이 되지 않습니다). Arrays - 인덱스된 임의의 깊이를 가진 연관 및 다차원 배열 Objects - $o == unserialize(serialize($o)) 와 같이 무손실 직렬화 및 직렬화 해제를 지원하는 객체. 객체는 PHP의 Serializable 인터페이스, 적절한 경우 __sleep() 또는 __wakeup() 매직 메서드 또는 유사한 언어 기능을 활용할 수 있습니다(MAY).  구현 라이브러리에 전달 된 모든 데이터는 전달 된 그대로 정확하게 반환되어야합니다(MUST). 여기에는 가변 유형이 포함됩니다. 즉, 만약 (int) 5가 저장된 값이었던 경우 (string) 5를 반환하는 것은 오류입니다. 구현 라이브러리는 PHP의 serialize()/unserialize() 함수를 내부적으로 사용할 수 있지만 꼭 그렇게 할 필요는 없습니다(MAY). 이들과의 호환성은 수용 가능한 객체 값의 기준선으로 사용됩니다.\n어떠한 이유로든 저장된 정확한 값을 반환 할 수없는 경우 구현 라이브러리는 데이터가 손상되지 않게 캐시 미스로 응답해야합니다(MUST).\n2. Interfaces #  2.1 CacheInterface #  캐시 인터페이스는 각 캐시 항목의 기본 읽기, 쓰기 및 삭제를 수반하는 캐시 항목 모음에 대한 가장 기본적인 작업을 정의합니다.\n또한 한 번에 여러 캐시 항목을 쓰거나, 읽거나 삭제하는 것과 같은 캐시 항목의 여러 세트를 처리하기위한 방법을 제공합니다. 이는 수행 할 캐시 읽기 / 쓰기가 많을 때 유용하며 대기 시간을 대폭 줄이는 캐시 서버에 대한 단일 호출로 작업을 수행 할 수 있습니다.\nCacheInterface의 인스턴스는 단일 키 네임 스페이스가있는 캐시 항목의 단일 모음에 해당하며 PSR-6의 \u0026ldquo;풀\u0026quot;과 동일합니다. 서로 다른 CacheInterface 인스턴스는 동일한 데이터 저장소에 의해 백업 될 수 있지만 (MAY) 반드시 논리적으로 독립적이어야합니다 (MUST).\n\u0026lt;?php namespace Psr\\SimpleCache; interface CacheInterface { /** * Fetches a value from the cache. * * @param string $key The unique key of this item in the cache. * @param mixed $default Default value to return if the key does not exist. * * @return mixed The value of the item from the cache, or $default in case of cache miss. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function get($key, $default = null); /** * Persists data in the cache, uniquely referenced by a key with an optional expiration TTL time. * * @param string $key The key of the item to store. * @param mixed $value The value of the item to store. Must be serializable. * @param null|int|\\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and * the driver supports TTL then the library may set a default value * for it or let the driver take care of that. * * @return bool True on success and false on failure. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function set($key, $value, $ttl = null); /** * Delete an item from the cache by its unique key. * * @param string $key The unique cache key of the item to delete. * * @return bool True if the item was successfully removed. False if there was an error. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function delete($key); /** * Wipes clean the entire cache\u0026#39;s keys. * * @return bool True on success and false on failure. */ public function clear(); /** * Obtains multiple cache items by their unique keys. * * @param iterable $keys A list of keys that can obtained in a single operation. * @param mixed $default Default value to return for keys that do not exist. * * @return iterable A list of key =\u0026gt; value pairs. Cache keys that do not exist or are stale will have $default as value. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $keys is neither an array nor a Traversable, * or if any of the $keys are not a legal value. */ public function getMultiple($keys, $default = null); /** * Persists a set of key =\u0026gt; value pairs in the cache, with an optional TTL. * * @param iterable $values A list of key =\u0026gt; value pairs for a multiple-set operation. * @param null|int|\\DateInterval $ttl Optional. The TTL value of this item. If no value is sent and * the driver supports TTL then the library may set a default value * for it or let the driver take care of that. * * @return bool True on success and false on failure. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $values is neither an array nor a Traversable, * or if any of the $values are not a legal value. */ public function setMultiple($values, $ttl = null); /** * Deletes multiple cache items in a single operation. * * @param iterable $keys A list of string-based keys to be deleted. * * @return bool True if the items were successfully removed. False if there was an error. * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if $keys is neither an array nor a Traversable, * or if any of the $keys are not a legal value. */ public function deleteMultiple($keys); /** * Determines whether an item is present in the cache. * * NOTE: It is recommended that has() is only to be used for cache warming type purposes * and not to be used within your live applications operations for get/set, as this method * is subject to a race condition where your has() will return true and immediately after, * another script can remove it, making the state of your app out of date. * * @param string $key The cache item key. * * @return bool * * @throws \\Psr\\SimpleCache\\InvalidArgumentException * MUST be thrown if the $key string is not a legal value. */ public function has($key); } 2.2 CacheException #  \u0026lt;?php namespace Psr\\SimpleCache; /** * Interface used for all types of exceptions thrown by the implementing library. */ interface CacheException { } 2.3 InvalidArgumentException #  \u0026lt;?php namespace Psr\\SimpleCache; /** * Exception interface for invalid cache arguments. * * When an invalid argument is passed it, must throw an exception which implements * this interface. */ interface InvalidArgumentException extends CacheException { } "});index.add({'id':15,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/13-psr-17/','title':"13 P S R 17",'section':"Php",'content':"HTTP Factories #  이 문서는 PSR-7에 호환하는 HTTP 객체를 만드는 팩토리의 공통 표준을 설명합니다.\nPSR-7은 HTTP 객체를 만드는 방법에 대한 권장 사항을 포함하지 않았기 때문에 PSR-7의 특정 구현과 관련되지 않은 구성 요소 내에 새로운 HTTP 객체를 생성해야 할 때 어려움을 겪습니다.\n이 문서에 설명 된 인터페이스는 PSR-7 객체를 인스턴스화 할 수 있는 방법을 설명합니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n1. 명세서 #  HTTP 팩토리는 PSR-7에 정의 된대로 새 HTTP 객체를 만드는 방법입니다. HTTP 팩토리는 패키지가 제공하는 각 객체 유형에 대해 이러한 인터페이스를 구현해야합니다 (MUST).\n2. Interfaces #  다음 인터페이스들은 단일 클래스 내에서 또는 별도의 클래스들 내에서 함께 구현 될 수있습니다 (MAY).\n2.1 RequestFactoryInterface #  클라이언트 요청을 생성하는 기능\nnamespace Psr\\Http\\Message; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\UriInterface; interface RequestFactoryInterface { /** * Create a new request. * * @param string $method The HTTP method associated with the request. * @param UriInterface|string $uri The URI associated with the request. */ public function createRequest(string $method, $uri): RequestInterface; } 2.2 ResponseFactoryInterface #  응답을 생성하는 하는 기능\nnamespace Psr\\Http\\Message; use Psr\\Http\\Message\\ResponseInterface; interface ResponseFactoryInterface { /** * Create a new response. * * @param int $code The HTTP status code. Defaults to 200. * @param string $reasonPhrase The reason phrase to associate with the status code * in the generated response. If none is provided, implementations MAY use * the defaults as suggested in the HTTP specification. */ public function createResponse(int $code = 200, string $reasonPhrase = \u0026#39;\u0026#39;): ResponseInterface; } 2.3 ServerRequestFactoryInterface #  서버 요청을 생성하는 기능\nnamespace Psr\\Http\\Message; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\UriInterface; interface ServerRequestFactoryInterface { /** * Create a new server request. * * Note that server parameters are taken precisely as given - no parsing/processing * of the given values is performed. In particular, no attempt is made to * determine the HTTP method or URI, which must be provided explicitly. * * @param string $method The HTTP method associated with the request. * @param UriInterface|string $uri The URI associated with the request. * @param array $serverParams An array of Server API (SAPI) parameters with * which to seed the generated request instance. */ public function createServerRequest(string $method, $uri, array $serverParams = []): ServerRequestInterface; } 2.4 StreamFactoryInterface #  요청 및 응답을 위한 스트림을 생성하는 기능\nnamespace Psr\\Http\\Message; use Psr\\Http\\Message\\StreamInterface; interface StreamFactoryInterface { /** * Create a new stream from a string. * * The stream SHOULD be created with a temporary resource. * * @param string $content String content with which to populate the stream. */ public function createStream(string $content = \u0026#39;\u0026#39;): StreamInterface; /** * Create a stream from an existing file. * * The file MUST be opened using the given mode, which may be any mode * supported by the `fopen` function. * * The `$filename` MAY be any string supported by `fopen()`. * * @param string $filename The filename or stream URI to use as basis of stream. * @param string $mode The mode with which to open the underlying filename/stream. * * @throws \\RuntimeException If the file cannot be opened. * @throws \\InvalidArgumentException If the mode is invalid. */ public function createStreamFromFile(string $filename, string $mode = \u0026#39;r\u0026#39;): StreamInterface; /** * Create a new stream from an existing resource. * * The stream MUST be readable and may be writable. * * @param resource $resource The PHP resource to use as the basis for the stream. */ public function createStreamFromResource($resource): StreamInterface; } 이 인터페이스의 구현은 문자열에서 리소스를 만들 때 임시 스트림을 사용해야합니다 (SHOULD). 이렇게하는 권장 방법은 다음과 같습니다 (RECOMMENDED).\n$resource = fopen(\u0026#39;php://temp\u0026#39;, \u0026#39;r+\u0026#39;); 2.5 UploadedFileFactoryInterface #  업로드 된 파일의 스트림을 만들 수 있는 기능\nnamespace Psr\\Http\\Message; use Psr\\Http\\Message\\StreamInterface; use Psr\\Http\\Message\\UploadedFileInterface; interface UploadedFileFactoryInterface { /** * Create a new uploaded file. * * If a size is not provided it will be determined by checking the size of * the stream. * * @link http://php.net/manual/features.file-upload.post-method.php * @link http://php.net/manual/features.file-upload.errors.php * * @param StreamInterface $stream The underlying stream representing the * uploaded file content. * @param int $size The size of the file in bytes. * @param int $error The PHP file upload error. * @param string $clientFilename The filename as provided by the client, if any. * @param string $clientMediaType The media type as provided by the client, if any. * * @throws \\InvalidArgumentException If the file resource is not readable. */ public function createUploadedFile( StreamInterface $stream, int $size = null, int $error = \\UPLOAD_ERR_OK, string $clientFilename = null, string $clientMediaType = null ): UploadedFileInterface; } 2.6 UriFactoryInterface #  클라이언트 및 서버 요청에 대한 URI를 생성하는 기능\nnamespace Psr\\Http\\Message; use Psr\\Http\\Message\\UriInterface; interface UriFactoryInterface { /** * Create a new URI. * * @param string $uri The URI to parse. * * @throws \\InvalidArgumentException If the given URI cannot be parsed. */ public function createUri(string $uri = \u0026#39;\u0026#39;) : UriInterface; } "});index.add({'id':16,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/php/accepted/14-psr-18/','title':"14 P S R 18",'section':"Php",'content':"HTTP Client #  이 문서에서는 HTTP 요청을 보내고 HTTP 응답을받는 일반적인 인터페이스에 대해 설명합니다.\n이 문서에서 핵심이 되는 단어는 \u0026ldquo;MUST\u0026rdquo;, \u0026ldquo;MUST NOT\u0026rdquo;, \u0026ldquo;REQUIRED\u0026rdquo;, \u0026ldquo;SHALL\u0026rdquo;, \u0026ldquo;SHALL NOT\u0026rdquo;, \u0026ldquo;SHOULD\u0026rdquo;, \u0026ldquo;SHOULD NOT\u0026rdquo;, \u0026ldquo;RECOMMENDED\u0026rdquo;, \u0026ldquo;MAY\u0026rdquo;, \u0026ldquo;OPTIONAL\u0026rdquo; 입니다. 이것은 RFC 2119에 설명 된대로 해석해야 합니다. 역자주: 위의 키워드는 아래의 번역문에 괄호안에 표시하였습니다\n목표 #  이 PSR의 목표는 개발자가 HTTP 클라이언트 구현에서 분리 된 라이브러리를 만들 수있게하는 것입니다. 이렇게하면 종속성 수가 줄어들고 버전 충돌의 가능성이 줄어들기 때문에 라이브러리를 더 많이 재사용 할 수 있습니다.\n두 번째 목표는 HTTP 클라이언트가 Liskov 치환 원칙에 따라 대체 될 수 있다는 것입니다. 즉, 요청을 보낼 때 모든 클라이언트가 동일한 방식으로 작동해야합니다.\n정의 #   클라이언트 - 클라이언트는 PSR-7 호환 HTTP 요청 메시지를 보내고 PSR-7 호환 HTTP 응답 메시지를 호출 라이브러리에 반환하기 위해 이 사양을 구현하는 라이브러리입니다. 호출 라이브러리 - 호출 라이브러리는 클라이언트를 사용하는 모든 코드입니다. 이 문서에 존재하는 인터페이스를 구현하지 않지만 이를 구현하는 객체 (클라이언트)를 사용합니다.  클라이언트 #  클라이언트는 ClientInterface를 구현 한 객체입니다.\n클라이언트는 다음과 같은 것을 할 수 있습니다.(MAY) :\n 제공된 HTTP 요청을 변경하여 보낼지 선택합니다. 예를 들어, 보내는 메시지 본문을 압축 할 수 있습니다. 수신 된 HTTP 응답을 호출 라이브러리로 되돌리기 전에 변경할 것인지 선택합니다. 예를 들어 들어오는 메시지 본문의 압축을 풀 수 있습니다.  클라이언트가 HTTP 요청이나 HTTP 응답을 변경하기로 결정한 경우, 객체가 내부적으로 일관성을 유지하는지 확인해야합니다 (MUST). 예를 들어, 클라이언트가 메시지 본문을 압축 해제하기로 선택한 경우, 반드시 Content-Encoding 헤더를 제거하고Content-Length 헤더를 조정해야합니다.\n결과적으로 PSR-7 객체는 불변이므로, 호출 라이브러리는 ClientInterface::sendRequest()에 전달 된 객체가 실제로 전송 된 것과 동일한 PHP 객체가 될 것이라고 가정해서는 안됩니다. 예를 들어, 예외에 의해 반환 된 Request 객체는 sendRequest()에 전달 된 것과 다른 객체 일 수 있기 때문에 참조 (===)로 비교할 수 없습니다.\n클라이언트는 반드시 다음을 지켜야합니다.(MUST) :\n 호출 라이브러리에 반환되는 내용이 상태 코드 200 이상의 유효한 HTTP 응답이 되도록 여러개의 HTTP 1xx 응답 자체를 재구성하십시오  오류 처리 #  클라이언트는 올바른 형식의 HTTP 요청이나 HTTP 응답을 오류 조건으로 취급해서는 안됩니다 (MUST NOT).\n예를 들어 400 및 500 범위의 응답 상태 코드는 예외를 발생시키지 않아야하며 정상적으로 호출 라이브러리에 반환되어야합니다 (MUST).\n클라이언트가 HTTP 요청을 전혀 보낼 수 없거나 HTTP 응답을 PSR-7 응답 객체로 구문 분석을 할 수없는 경우에만 클라이언트는 Psr\\Http\\Client\\ClientExceptionInterface 인스턴스를 던져야합니다.\n요청 메시지가 올바른 형식의 HTTP 요청이 아니거나 일부 중요한 정보 (예 : 호스트 또는 메서드)가 없어서 요청을 보낼 수없는 경우, 클라이언트는 Psr\\Http\\Client\\RequestExceptionInterface의 인스턴스를 던져야만 합니다.(MUST)\n타임 아웃을 포함하여 어떤 종류의 네트워크 장애로 인해 요청을 보낼 수없는 경우, 클라이언트는 Psr\\Http\\Client\\NetworkExceptionInterface의 인스턴스를 던져야만 합니다 (MUST).\n클라이언트는 위에서 정의된 인터페이스를 적합하게 구현한다면 여기에 정의 된 것보다 더 구체적인 예외 (예 :TimeOutException 또는 HostNotFoundException)를 던질 수도 있습니다 (MAY).\nInterfaces #  ClientInterface #  namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; use Psr\\Http\\Message\\ResponseInterface; interface ClientInterface { /** * Sends a PSR-7 request and returns a PSR-7 response. * * @param RequestInterface $request * * @return ResponseInterface * * @throws \\Psr\\Http\\Client\\ClientExceptionInterface If an error happens while processing the request. */ public function sendRequest(RequestInterface $request): ResponseInterface; } ClientExceptionInterface #  namespace Psr\\Http\\Client; /** * Every HTTP client related exception MUST implement this interface. */ interface ClientExceptionInterface extends \\Throwable { } RequestExceptionInterface #  namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; /** * Exception for when a request failed. * * Examples: * - Request is invalid (e.g. method is missing) * - Runtime request errors (e.g. the body stream is not seekable) */ interface RequestExceptionInterface extends ClientExceptionInterface { /** * Returns the request. * * The request object MAY be a different object from the one passed to ClientInterface::sendRequest() * * @return RequestInterface */ public function getRequest(): RequestInterface; } NetworkExceptionInterface #  namespace Psr\\Http\\Client; use Psr\\Http\\Message\\RequestInterface; /** * Thrown when the request cannot be completed because of network issues. * * There is no response object as this exception is thrown when no response has been received. * * Example: the target host name can not be resolved or the connection failed. */ interface NetworkExceptionInterface extends ClientExceptionInterface { /** * Returns the request. * * The request object MAY be a different object from the one passed to ClientInterface::sendRequest() * * @return RequestInterface */ public function getRequest(): RequestInterface; } "});index.add({'id':17,'href':'/docs/%EA%B0%9C%EB%B0%9C%EA%B0%80%EC%9D%B4%EB%93%9C/react_jsx/react_jsx/','title':"React Jsx",'section':"개발가이드",'content':"Laonstory React/JSX 스타일 가이드 #  A mostly reasonable approach to React and JSX\nThis style guide is mostly based on the standards that are currently prevalent in JavaScript, although some conventions (i.e async/await or static class fields) may still be included or prohibited on a case-by-case basis. Currently, anything prior to stage 3 is not included nor recommended in this guide.\nTable of Contents #   Basic Rules Class vs React.createClass vs stateless Mixins Naming Declaration Alignment Quotes Spacing Props Refs Parentheses Tags Methods Ordering isMounted  Basic Rules #   Only include one React component per file.  However, multiple Stateless, or Pure, Components are allowed per file. eslint: react/no-multi-comp.   Always use JSX syntax. Do not use React.createElement unless you’re initializing the app from a file that is not JSX. react/forbid-prop-types will allow arrays and objects only if it is explicitly noted what array and object contains, using arrayOf, objectOf, or shape.  Class vs React.createClass vs stateless #    If you have internal state and/or refs, prefer class extends React.Component over React.createClass. eslint: react/prefer-es6-class react/prefer-stateless-function\n// bad const Listing = React.createClass({ // ...  render() { return \u0026lt;div\u0026gt;{this.state.hello}\u0026lt;/div\u0026gt;; } }); // good class Listing extends React.Component { // ...  render() { return \u0026lt;div\u0026gt;{this.state.hello}\u0026lt;/div\u0026gt;; } } And if you don’t have state or refs, prefer normal functions (not arrow functions) over classes:\n// bad class Listing extends React.Component { render() { return \u0026lt;div\u0026gt;{this.props.hello}\u0026lt;/div\u0026gt;; } } // bad (relying on function name inference is discouraged) const Listing = ({ hello }) =\u0026gt; ( \u0026lt;div\u0026gt;{hello}\u0026lt;/div\u0026gt; ); // good function Listing({ hello }) { return \u0026lt;div\u0026gt;{hello}\u0026lt;/div\u0026gt;; }   Mixins #   Do not use mixins.   Why? Mixins introduce implicit dependencies, cause name clashes, and cause snowballing complexity. Most use cases for mixins can be accomplished in better ways via components, higher-order components, or utility modules.\n Naming #    Extensions: Use .jsx extension for React components. eslint: react/jsx-filename-extension\n  Filename: Use PascalCase for filenames. E.g., ReservationCard.jsx.\n  Reference Naming: Use PascalCase for React components and camelCase for their instances. eslint: react/jsx-pascal-case\n// bad import reservationCard from \u0026#39;./ReservationCard\u0026#39;; // good import ReservationCard from \u0026#39;./ReservationCard\u0026#39;; // bad const ReservationItem = \u0026lt;ReservationCard /\u0026gt;; // good const reservationItem = \u0026lt;ReservationCard /\u0026gt;;   Component Naming: Use the filename as the component name. For example, ReservationCard.jsx should have a reference name of ReservationCard. However, for root components of a directory, use index.jsx as the filename and use the directory name as the component name:\n// bad import Footer from \u0026#39;./Footer/Footer\u0026#39;; // bad import Footer from \u0026#39;./Footer/index\u0026#39;; // good import Footer from \u0026#39;./Footer\u0026#39;;   Higher-order Component Naming: Use a composite of the higher-order component’s name and the passed-in component’s name as the displayName on the generated component. For example, the higher-order component withFoo(), when passed a component Bar should produce a component with a displayName of withFoo(Bar).\n Why? A component’s displayName may be used by developer tools or in error messages, and having a value that clearly expresses this relationship helps people understand what is happening.\n // bad export default function withFoo(WrappedComponent) { return function WithFoo(props) { return \u0026lt;WrappedComponent {...props} foo /\u0026gt;; } } // good export default function withFoo(WrappedComponent) { function WithFoo(props) { return \u0026lt;WrappedComponent {...props} foo /\u0026gt;; } const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || \u0026#39;Component\u0026#39;; WithFoo.displayName = `withFoo(${wrappedComponentName})`; return WithFoo; }   Props Naming: Avoid using DOM component prop names for different purposes.\n Why? People expect props like style and className to mean one specific thing. Varying this API for a subset of your app makes the code less readable and less maintainable, and may cause bugs.\n // bad \u0026lt;MyComponent style=\u0026#34;fancy\u0026#34; /\u0026gt; // bad \u0026lt;MyComponent className=\u0026#34;fancy\u0026#34; /\u0026gt; // good \u0026lt;MyComponent variant=\u0026#34;fancy\u0026#34; /\u0026gt;   Declaration #    Do not use displayName for naming components. Instead, name the component by reference.\n// bad export default React.createClass({ displayName: \u0026#39;ReservationCard\u0026#39;, // stuff goes here }); // good export default class ReservationCard extends React.Component { }   Alignment #    Follow these alignment styles for JSX syntax. eslint: react/jsx-closing-bracket-location react/jsx-closing-tag-location\n// bad \u0026lt;Foo superLongParam=\u0026#34;bar\u0026#34; anotherSuperLongParam=\u0026#34;baz\u0026#34; /\u0026gt; // good \u0026lt;Foo superLongParam=\u0026#34;bar\u0026#34; anotherSuperLongParam=\u0026#34;baz\u0026#34; /\u0026gt; // if props fit in one line then keep it on the same line \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; // children get indented normally \u0026lt;Foo superLongParam=\u0026#34;bar\u0026#34; anotherSuperLongParam=\u0026#34;baz\u0026#34; \u0026gt; \u0026lt;Quux /\u0026gt; \u0026lt;/Foo\u0026gt; // bad {showButton \u0026amp;\u0026amp; \u0026lt;Button /\u0026gt; } // bad { showButton \u0026amp;\u0026amp; \u0026lt;Button /\u0026gt; } // good {showButton \u0026amp;\u0026amp; ( \u0026lt;Button /\u0026gt; )} // good {showButton \u0026amp;\u0026amp; \u0026lt;Button /\u0026gt;}   Quotes #    Always use double quotes (\u0026quot;) for JSX attributes, but single quotes (') for all other JS. eslint: jsx-quotes\n Why? Regular HTML attributes also typically use double quotes instead of single, so JSX attributes mirror this convention.\n // bad \u0026lt;Foo bar=\u0026#39;bar\u0026#39; /\u0026gt; // good \u0026lt;Foo bar=\u0026#34;bar\u0026#34; /\u0026gt; // bad \u0026lt;Foo style={{ left: \u0026#34;20px\u0026#34; }} /\u0026gt; // good \u0026lt;Foo style={{ left: \u0026#39;20px\u0026#39; }} /\u0026gt;   Spacing #    Always include a single space in your self-closing tag. eslint: no-multi-spaces, react/jsx-tag-spacing\n// bad \u0026lt;Foo/\u0026gt; // very bad \u0026lt;Foo /\u0026gt; // bad \u0026lt;Foo /\u0026gt; // good \u0026lt;Foo /\u0026gt;   Do not pad JSX curly braces with spaces. eslint: react/jsx-curly-spacing\n// bad \u0026lt;Foo bar={ baz } /\u0026gt; // good \u0026lt;Foo bar={baz} /\u0026gt;   Props #    Always use camelCase for prop names.\n// bad \u0026lt;Foo UserName=\u0026#34;hello\u0026#34; phone_number={12345678} /\u0026gt; // good \u0026lt;Foo userName=\u0026#34;hello\u0026#34; phoneNumber={12345678} /\u0026gt;   Omit the value of the prop when it is explicitly true. eslint: react/jsx-boolean-value\n// bad \u0026lt;Foo hidden={true} /\u0026gt; // good \u0026lt;Foo hidden /\u0026gt; // good \u0026lt;Foo hidden /\u0026gt;   Always include an alt prop on \u0026lt;img\u0026gt; tags. If the image is presentational, alt can be an empty string or the \u0026lt;img\u0026gt; must have role=\u0026quot;presentation\u0026quot;. eslint: jsx-a11y/alt-text\n// bad \u0026lt;img src=\u0026#34;hello.jpg\u0026#34; /\u0026gt; // good \u0026lt;img src=\u0026#34;hello.jpg\u0026#34; alt=\u0026#34;Me waving hello\u0026#34; /\u0026gt; // good \u0026lt;img src=\u0026#34;hello.jpg\u0026#34; alt=\u0026#34;\u0026#34; /\u0026gt; // good \u0026lt;img src=\u0026#34;hello.jpg\u0026#34; role=\u0026#34;presentation\u0026#34; /\u0026gt;   Do not use words like \u0026ldquo;image\u0026rdquo;, \u0026ldquo;photo\u0026rdquo;, or \u0026ldquo;picture\u0026rdquo; in \u0026lt;img\u0026gt; alt props. eslint: jsx-a11y/img-redundant-alt\n Why? Screenreaders already announce img elements as images, so there is no need to include this information in the alt text.\n // bad \u0026lt;img src=\u0026#34;hello.jpg\u0026#34; alt=\u0026#34;Picture of me waving hello\u0026#34; /\u0026gt; // good \u0026lt;img src=\u0026#34;hello.jpg\u0026#34; alt=\u0026#34;Me waving hello\u0026#34; /\u0026gt;   Use only valid, non-abstract ARIA roles. eslint: jsx-a11y/aria-role\n// bad - not an ARIA role \u0026lt;div role=\u0026#34;datepicker\u0026#34; /\u0026gt; // bad - abstract ARIA role \u0026lt;div role=\u0026#34;range\u0026#34; /\u0026gt; // good \u0026lt;div role=\u0026#34;button\u0026#34; /\u0026gt;   Do not use accessKey on elements. eslint: jsx-a11y/no-access-key\n   Why? Inconsistencies between keyboard shortcuts and keyboard commands used by people using screenreaders and keyboards complicate accessibility.\n // bad \u0026lt;div accessKey=\u0026#34;h\u0026#34; /\u0026gt; // good \u0026lt;div /\u0026gt;  Avoid using an array index as key prop, prefer a stable ID. eslint: react/no-array-index-key   Why? Not using a stable ID is an anti-pattern because it can negatively impact performance and cause issues with component state.\n We don’t recommend using indexes for keys if the order of items may change.\n// bad {todos.map((todo, index) =\u0026gt; \u0026lt;Todo {...todo} key={index} /\u0026gt; )} // good {todos.map(todo =\u0026gt; ( \u0026lt;Todo {...todo} key={todo.id} /\u0026gt; ))}  Always define explicit defaultProps for all non-required props.   Why? propTypes are a form of documentation, and providing defaultProps means the reader of your code doesn’t have to assume as much. In addition, it can mean that your code can omit certain type checks.\n // bad function SFC({ foo, bar, children }) { return \u0026lt;div\u0026gt;{foo}{bar}{children}\u0026lt;/div\u0026gt;; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; // good function SFC({ foo, bar, children }) { return \u0026lt;div\u0026gt;{foo}{bar}{children}\u0026lt;/div\u0026gt;; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; SFC.defaultProps = { bar: \u0026#39;\u0026#39;, children: null, };  Use spread props sparingly.   Why? Otherwise you’re more likely to pass unnecessary props down to components. And for React v15.6.1 and older, you could pass invalid HTML attributes to the DOM.\n Exceptions:\n HOCs that proxy down props and hoist propTypes  function HOC(WrappedComponent) { return class Proxy extends React.Component { Proxy.propTypes = { text: PropTypes.string, isLoading: PropTypes.bool }; render() { return \u0026lt;WrappedComponent {...this.props} /\u0026gt; } } }  Spreading objects with known, explicit props. This can be particularly useful when testing React components with Mocha’s beforeEach construct.  export default function Foo { const props = { text: \u0026#39;\u0026#39;, isPublished: false } return (\u0026lt;div {...props} /\u0026gt;); } Notes for use: Filter out unnecessary props when possible. Also, use prop-types-exact to help prevent bugs.\n// bad render() { const { irrelevantProp, ...relevantProps } = this.props; return \u0026lt;WrappedComponent {...this.props} /\u0026gt; } // good render() { const { irrelevantProp, ...relevantProps } = this.props; return \u0026lt;WrappedComponent {...relevantProps} /\u0026gt; } Refs #    Always use ref callbacks. eslint: react/no-string-refs\n// bad \u0026lt;Foo ref=\u0026#34;myRef\u0026#34; /\u0026gt; // good \u0026lt;Foo ref={(ref) =\u0026gt; { this.myRef = ref; }} /\u0026gt;   Parentheses #    Wrap JSX tags in parentheses when they span more than one line. eslint: react/jsx-wrap-multilines\n// bad render() { return \u0026lt;MyComponent variant=\u0026#34;long body\u0026#34; foo=\u0026#34;bar\u0026#34;\u0026gt; \u0026lt;MyChild /\u0026gt; \u0026lt;/MyComponent\u0026gt;; } // good render() { return ( \u0026lt;MyComponent variant=\u0026#34;long body\u0026#34; foo=\u0026#34;bar\u0026#34;\u0026gt; \u0026lt;MyChild /\u0026gt; \u0026lt;/MyComponent\u0026gt; ); } // good, when single line render() { const body = \u0026lt;div\u0026gt;hello\u0026lt;/div\u0026gt;; return \u0026lt;MyComponent\u0026gt;{body}\u0026lt;/MyComponent\u0026gt;; }   Tags #    Always self-close tags that have no children. eslint: react/self-closing-comp\n// bad \u0026lt;Foo variant=\u0026#34;stuff\u0026#34;\u0026gt;\u0026lt;/Foo\u0026gt; // good \u0026lt;Foo variant=\u0026#34;stuff\u0026#34; /\u0026gt;   If your component has multiline properties, close its tag on a new line. eslint: react/jsx-closing-bracket-location\n// bad \u0026lt;Foo bar=\u0026#34;bar\u0026#34; baz=\u0026#34;baz\u0026#34; /\u0026gt; // good \u0026lt;Foo bar=\u0026#34;bar\u0026#34; baz=\u0026#34;baz\u0026#34; /\u0026gt;   Methods #    Use arrow functions to close over local variables. It is handy when you need to pass additional data to an event handler. Although, make sure they do not massively hurt performance, in particular when passed to custom components that might be PureComponents, because they will trigger a possibly needless rerender every time.\nfunction ItemList(props) { return ( \u0026lt;ul\u0026gt; {props.items.map((item, index) =\u0026gt; ( \u0026lt;Item key={item.key} onClick={(event) =\u0026gt; { doSomethingWith(event, item.name, index); }} /\u0026gt; ))} \u0026lt;/ul\u0026gt; ); }   Bind event handlers for the render method in the constructor. eslint: react/jsx-no-bind\n Why? A bind call in the render path creates a brand new function on every single render. Do not use arrow functions in class fields, because it makes them challenging to test and debug, and can negatively impact performance, and because conceptually, class fields are for data, not logic.\n // bad class extends React.Component { onClickDiv() { // do stuff  } render() { return \u0026lt;div onClick={this.onClickDiv.bind(this)} /\u0026gt;; } } // very bad class extends React.Component { onClickDiv = () =\u0026gt; { // do stuff  } render() { return \u0026lt;div onClick={this.onClickDiv} /\u0026gt; } } // good class extends React.Component { constructor(props) { super(props); this.onClickDiv = this.onClickDiv.bind(this); } onClickDiv() { // do stuff  } render() { return \u0026lt;div onClick={this.onClickDiv} /\u0026gt;; } }   Do not use underscore prefix for internal methods of a React component.\n Why? Underscore prefixes are sometimes used as a convention in other languages to denote privacy. But, unlike those languages, there is no native support for privacy in JavaScript, everything is public. Regardless of your intentions, adding underscore prefixes to your properties does not actually make them private, and any property (underscore-prefixed or not) should be treated as being public. See issues #1024, and #490 for a more in-depth discussion.\n // bad React.createClass({ _onClickSubmit() { // do stuff  }, // other stuff }); // good class extends React.Component { onClickSubmit() { // do stuff  } // other stuff }   Be sure to return a value in your render methods. eslint: react/require-render-return\n// bad render() { (\u0026lt;div /\u0026gt;); } // good render() { return (\u0026lt;div /\u0026gt;); }   Ordering #   Ordering for class extends React.Component:   optional static methods constructor getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() optional render methods like renderNavigation() or renderProfilePicture() render    How to define propTypes, defaultProps, contextTypes, etc\u0026hellip;\nimport React from \u0026#39;react\u0026#39;; import PropTypes from \u0026#39;prop-types\u0026#39;; const propTypes = { id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string, }; const defaultProps = { text: \u0026#39;Hello World\u0026#39;, }; class Link extends React.Component { static methodsAreOk() { return true; } render() { return \u0026lt;a href={this.props.url} data-id={this.props.id}\u0026gt;{this.props.text}\u0026lt;/a\u0026gt;; } } Link.propTypes = propTypes; Link.defaultProps = defaultProps; export default Link;   Ordering for React.createClass: eslint: react/sort-comp\n   displayName propTypes contextTypes childContextTypes mixins statics defaultProps getDefaultProps getInitialState getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() optional render methods like renderNavigation() or renderProfilePicture() render  isMounted #   Do not use isMounted. eslint: react/no-is-mounted   Why? isMounted is an anti-pattern, is not available when using ES6 classes, and is on its way to being officially deprecated.\n Translation #  This JSX/React style guide is also available in other languages:\n Chinese (Simplified): jhcccc/javascript Chinese (Traditional): jigsawye/javascript Español: agrcrobles/javascript Japanese: mitsuruog/javascript-style-guide Korean: apple77y/javascript Polish: pietraszekl/javascript Portuguese: ronal2do/javascript Russian: leonidlebedev/javascript-airbnb Thai: lvarayut/javascript-style-guide Turkish: alioguzhan/react-style-guide Ukrainian: ivanzusko/javascript Vietnam: uetcodecamp/jsx-style-guide  ⬆ back to top\n"});})();